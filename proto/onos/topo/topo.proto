/*
Copyright 2019-present Open Networking Foundation.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

// Package onos.topo defines interfaces for managing network topology
package onos.topo;

import "google/protobuf/any.proto";
import "gogoproto/gogo.proto";

// EntityService provides an API for managing entities.
service Topo {
  // Create a new topology object
  rpc Create (CreateRequest) returns (CreateResponse) {
  }

  // Get an object from topology
  rpc Get (GetRequest) returns (GetResponse) {
  }

  // Update an existing topology object
  rpc Update (UpdateRequest) returns (UpdateResponse) {
  }
  // Delete an object from topology
  rpc Delete (DeleteRequest) returns (DeleteResponse) {
  }

  // List gets a stream of requested objects
  rpc List (ListRequest) returns (ListResponse) {
  }

  // Watch returns a stream of topo change notifications
  rpc Watch (WatchRequest) returns (stream WatchResponse) {
  }
}

// EventType is a topo operation event type
enum EventType {
  NONE = 0;
  ADDED = 1;
  UPDATED = 2;
  REMOVED = 3;
}

// Event is a topo operation event
message Event {
  EventType type = 1;
  Object object = 2 [(gogoproto.nullable) = false];
}


message CreateRequest {
  Object object = 1;
}

message CreateResponse {
  Object object = 1;
}

message GetRequest {
  string id = 1 [(gogoproto.customname) = "ID", (gogoproto.casttype) = "ID"];
}

message GetResponse {
  Object object = 1;
}

message UpdateRequest {
  Object object = 1;
}

message UpdateResponse {
  Object object = 1;
}

message DeleteRequest {
  string id = 1 [(gogoproto.customname) = "ID", (gogoproto.casttype) = "ID"];
}

message DeleteResponse {
}

message Filter {
  oneof filter {
    EqualFilter equal = 1;
    NotFilter not = 2;
    InFilter in = 3;
  }
  string key = 4; // optional key
}
message EqualFilter {
  string value = 1;
}
message NotFilter {
  string value = 1;
}
message InFilter {
  repeated string values = 1;
}

message Filters {
  repeated Filter kind_filter = 1;
  repeated Filter label_filter = 2;
}

message ListRequest {
  repeated Filters filters = 1;
}

message ListResponse {
  repeated Object objects = 1 [(gogoproto.nullable) = false];
}

message WatchRequest {
  repeated Filters filters = 1;
  bool noreplay = 2;
}

message WatchResponse {
  Event event = 1 [(gogoproto.nullable) = false];
}

// Object is an one of the following: a kind (archetype of entity or relation), an entity, a relation
message Object {
  string id = 1 [(gogoproto.customname) = "ID", (gogoproto.casttype) = "ID"];
  uint64 revision = 2 [(gogoproto.casttype) = "Revision"];

  enum Type {
    UNSPECIFIED = 0;
    ENTITY = 1;
    RELATION = 2;
    KIND = 3;
  }
  Type type = 3;

  oneof obj {
    Entity entity = 4;
    Relation relation = 5;
    Kind kind = 6;
  }

  // Map of aspects as typed values; for kind, these represent expected aspects and their default values
  map<string, google.protobuf.Any> aspects = 7;

  // Arbitrary labels for classification/search
  map<string,string> labels = 8;
}

// Entity represents any "thing" that is represented in the topology
message Entity {
  // user-defined entity kind
  string kind_id = 1 [(gogoproto.customname) = "KindID", (gogoproto.casttype) = "ID"];
  repeated ProtocolState protocols = 2;
}

// Relation represents any "relation" between two entitites in the topology.
message Relation {
  // user defined relation kind
  string kind_id = 1 [(gogoproto.customname) = "KindID", (gogoproto.casttype) = "ID"];

  string src_entity_id = 2 [(gogoproto.customname) = "SrcEntityID", (gogoproto.casttype) = "ID"];
  string tgt_entity_id = 3 [(gogoproto.customname) = "TgtEntityID", (gogoproto.casttype) = "ID"];
}

// Kind represents an archetype of an object, i.e. entity or relation
message Kind {
  string name = 1;  // Friendly name of the kind
}

// ProtocolState contains information related to service and connectivity to a device
message ProtocolState {

  //The protocol to which state relates
  Protocol protocol = 1;

  //ConnectivityState contains the L3 connectivity information
  ConnectivityState connectivityState = 2;

  //ChannelState relates to the availability of the gRPC channel
  ChannelState channelState = 3;

  //ServiceState indicates the availability of the gRPC servic on top of the channel
  ServiceState serviceState = 4;
}


// Protocol to interact with a device
enum Protocol {
  //UNKNOWN_PROTOCOL constant needed to go around proto3 nullifying the 0 values
  UNKNOWN_PROTOCOL = 0;

  // GNMI protocol reference
  GNMI = 1;

  // P4RUNTIME protocol reference
  P4RUNTIME = 2;

  // GNOI protocol reference
  GNOI = 3;

  // E2 Control Plane Protocol
  E2AP = 4;
}

//ConnectivityState represents the L3 reachability of a device from the service container (e.g. enos-config), independently of gRPC or the service itself (e.g. gNMI)
enum ConnectivityState {
  //UNKNOWN_CONNECTIVITY_STATE constant needed to go around proto3 nullifying the 0 values
  UNKNOWN_CONNECTIVITY_STATE = 0;

  // REACHABLE indicates the the service can reach the device at L3
  REACHABLE = 1;

  // UNREACHABLE indicates the the service can't reach the device at L3
  UNREACHABLE = 2;
}

//ConnectivityState represents the state of a gRPC channel to the device from the service container
enum ChannelState {
  //UNKNOWN_CHANNEL_STATE constant needed to go around proto3 nullifying the 0 values
  UNKNOWN_CHANNEL_STATE = 0;

  // CONNECTED indicates the corresponding grpc channel is connected on this device
  CONNECTED = 1;

  // DISCONNECTED indicates the corresponding grpc channel is not connected on this device
  DISCONNECTED = 2;
}

//ServiceState represents the state of the gRPC service (e.g. gNMI) to the device from the service container
enum ServiceState {
  //UNKNOWN_SERVICE_STATE constant needed to go around proto3 nullifying the 0 values
  UNKNOWN_SERVICE_STATE = 0;

  // AVAILABLE indicates the corresponding grpc service is available
  AVAILABLE = 1;

  // UNAVAILABLE indicates the corresponding grpc service is not available
  UNAVAILABLE = 2;

  // CONNECTING indicates the corresponding protocol is in the connecting phase on this device
  CONNECTING = 3;
}

