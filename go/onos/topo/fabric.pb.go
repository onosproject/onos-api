// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/topo/fabric.proto

package topo

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NetworkLayer_Type int32

const (
	NetworkLayer_UNDERLAY NetworkLayer_Type = 0
)

var NetworkLayer_Type_name = map[int32]string{
	0: "UNDERLAY",
}

var NetworkLayer_Type_value = map[string]int32{
	"UNDERLAY": 0,
}

func (x NetworkLayer_Type) String() string {
	return proto.EnumName(NetworkLayer_Type_name, int32(x))
}

func (NetworkLayer_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0, 0}
}

type Controller_Type int32

const (
	Controller_P4RUNTIME Controller_Type = 0
)

var Controller_Type_name = map[int32]string{
	0: "P4RUNTIME",
}

var Controller_Type_value = map[string]int32{
	"P4RUNTIME": 0,
}

func (x Controller_Type) String() string {
	return proto.EnumName(Controller_Type_name, int32(x))
}

func (Controller_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{4, 0}
}

type IPAddress_Type int32

const (
	IPAddress_IPV4 IPAddress_Type = 0
	IPAddress_IPV6 IPAddress_Type = 1
)

var IPAddress_Type_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}

var IPAddress_Type_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x IPAddress_Type) String() string {
	return proto.EnumName(IPAddress_Type_name, int32(x))
}

func (IPAddress_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{6, 0}
}

// NetworkLayer aspect; aspect for a NetworkLayer entity with a specific kind
type NetworkLayer struct {
	Type        NetworkLayer_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.NetworkLayer_Type" json:"type,omitempty"`
	DisplayName string            `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *NetworkLayer) Reset()         { *m = NetworkLayer{} }
func (m *NetworkLayer) String() string { return proto.CompactTextString(m) }
func (*NetworkLayer) ProtoMessage()    {}
func (*NetworkLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0}
}
func (m *NetworkLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkLayer.Merge(m, src)
}
func (m *NetworkLayer) XXX_Size() int {
	return m.Size()
}
func (m *NetworkLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkLayer.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkLayer proto.InternalMessageInfo

func (m *NetworkLayer) GetType() NetworkLayer_Type {
	if m != nil {
		return m.Type
	}
	return NetworkLayer_UNDERLAY
}

func (m *NetworkLayer) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// Switch aspect; aspect for a SWITCH entity
type Switch struct {
	ModelID            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,4,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Switch) Reset()         { *m = Switch{} }
func (m *Switch) String() string { return proto.CompactTextString(m) }
func (*Switch) ProtoMessage()    {}
func (*Switch) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{1}
}
func (m *Switch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Switch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Switch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Switch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Switch.Merge(m, src)
}
func (m *Switch) XXX_Size() int {
	return m.Size()
}
func (m *Switch) XXX_DiscardUnknown() {
	xxx_messageInfo_Switch.DiscardUnknown(m)
}

var xxx_messageInfo_Switch proto.InternalMessageInfo

func (m *Switch) GetModelID() string {
	if m != nil {
		return m.ModelID
	}
	return ""
}

func (m *Switch) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Switch) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// Router aspect; aspect of a ROUTER entity (Layer 3)
type Router struct {
	ModelId            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,3,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{2}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *Router) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Router) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// PhyPort aspect; an aspect to represent a physical switch port
type PhyPort struct {
	DisplayName   string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Speed         string `protobuf:"bytes,2,opt,name=speed,proto3" json:"speed,omitempty"`
	PortNumber    uint32 `protobuf:"varint,3,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	ChannelNumber uint32 `protobuf:"varint,4,opt,name=channel_number,json=channelNumber,proto3" json:"channel_number,omitempty"`
}

func (m *PhyPort) Reset()         { *m = PhyPort{} }
func (m *PhyPort) String() string { return proto.CompactTextString(m) }
func (*PhyPort) ProtoMessage()    {}
func (*PhyPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{3}
}
func (m *PhyPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhyPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhyPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhyPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhyPort.Merge(m, src)
}
func (m *PhyPort) XXX_Size() int {
	return m.Size()
}
func (m *PhyPort) XXX_DiscardUnknown() {
	xxx_messageInfo_PhyPort.DiscardUnknown(m)
}

var xxx_messageInfo_PhyPort proto.InternalMessageInfo

func (m *PhyPort) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PhyPort) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *PhyPort) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *PhyPort) GetChannelNumber() uint32 {
	if m != nil {
		return m.ChannelNumber
	}
	return 0
}

// Controller aspect; represents an instance of the controller deployment
type Controller struct {
	Type Controller_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.Controller_Type" json:"type,omitempty"`
	Role string          `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *Controller) Reset()         { *m = Controller{} }
func (m *Controller) String() string { return proto.CompactTextString(m) }
func (*Controller) ProtoMessage()    {}
func (*Controller) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{4}
}
func (m *Controller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Controller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Controller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Controller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Controller.Merge(m, src)
}
func (m *Controller) XXX_Size() int {
	return m.Size()
}
func (m *Controller) XXX_DiscardUnknown() {
	xxx_messageInfo_Controller.DiscardUnknown(m)
}

var xxx_messageInfo_Controller proto.InternalMessageInfo

func (m *Controller) GetType() Controller_Type {
	if m != nil {
		return m.Type
	}
	return Controller_P4RUNTIME
}

func (m *Controller) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Endpoint specifies ip and port number for an endpoint address
type Endpoint struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{5}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Endpoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// IPAddress defines an ipv4 or ipv6 address
type IPAddress struct {
	Type IPAddress_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.IPAddress_Type" json:"type,omitempty"`
	IP   string         `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *IPAddress) Reset()         { *m = IPAddress{} }
func (m *IPAddress) String() string { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()    {}
func (*IPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{6}
}
func (m *IPAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddress.Merge(m, src)
}
func (m *IPAddress) XXX_Size() int {
	return m.Size()
}
func (m *IPAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddress proto.InternalMessageInfo

func (m *IPAddress) GetType() IPAddress_Type {
	if m != nil {
		return m.Type
	}
	return IPAddress_IPV4
}

func (m *IPAddress) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

// P4RTServerInfo aspect; specifies the control end point in a programmable device
type P4RTServerInfo struct {
	ControlEndpoint *Endpoint      `protobuf:"bytes,1,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Timeout         *time.Duration `protobuf:"bytes,5,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
}

func (m *P4RTServerInfo) Reset()         { *m = P4RTServerInfo{} }
func (m *P4RTServerInfo) String() string { return proto.CompactTextString(m) }
func (*P4RTServerInfo) ProtoMessage()    {}
func (*P4RTServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{7}
}
func (m *P4RTServerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RTServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RTServerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RTServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RTServerInfo.Merge(m, src)
}
func (m *P4RTServerInfo) XXX_Size() int {
	return m.Size()
}
func (m *P4RTServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RTServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_P4RTServerInfo proto.InternalMessageInfo

func (m *P4RTServerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *P4RTServerInfo) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

// SdnControllerInfo aspect; specifies the configuration endpoint of an SDN Controller
type SdnControllerInfo struct {
	ControlEndpoint *Endpoint `protobuf:"bytes,1,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Username        string    `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password        string    `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *SdnControllerInfo) Reset()         { *m = SdnControllerInfo{} }
func (m *SdnControllerInfo) String() string { return proto.CompactTextString(m) }
func (*SdnControllerInfo) ProtoMessage()    {}
func (*SdnControllerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{8}
}
func (m *SdnControllerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SdnControllerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SdnControllerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SdnControllerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SdnControllerInfo.Merge(m, src)
}
func (m *SdnControllerInfo) XXX_Size() int {
	return m.Size()
}
func (m *SdnControllerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SdnControllerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SdnControllerInfo proto.InternalMessageInfo

func (m *SdnControllerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *SdnControllerInfo) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *SdnControllerInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func init() {
	proto.RegisterEnum("onos.topo.NetworkLayer_Type", NetworkLayer_Type_name, NetworkLayer_Type_value)
	proto.RegisterEnum("onos.topo.Controller_Type", Controller_Type_name, Controller_Type_value)
	proto.RegisterEnum("onos.topo.IPAddress_Type", IPAddress_Type_name, IPAddress_Type_value)
	proto.RegisterType((*NetworkLayer)(nil), "onos.topo.NetworkLayer")
	proto.RegisterType((*Switch)(nil), "onos.topo.Switch")
	proto.RegisterType((*Router)(nil), "onos.topo.Router")
	proto.RegisterType((*PhyPort)(nil), "onos.topo.PhyPort")
	proto.RegisterType((*Controller)(nil), "onos.topo.Controller")
	proto.RegisterType((*Endpoint)(nil), "onos.topo.Endpoint")
	proto.RegisterType((*IPAddress)(nil), "onos.topo.IPAddress")
	proto.RegisterType((*P4RTServerInfo)(nil), "onos.topo.P4RTServerInfo")
	proto.RegisterType((*SdnControllerInfo)(nil), "onos.topo.SdnControllerInfo")
}

func init() { proto.RegisterFile("onos/topo/fabric.proto", fileDescriptor_705cdab724be9631) }

var fileDescriptor_705cdab724be9631 = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xcd, 0xa6, 0x6e, 0x3e, 0x26, 0x4d, 0x09, 0xdb, 0x52, 0xa5, 0x11, 0x72, 0x8a, 0x25, 0x50,
	0x2f, 0x38, 0xa8, 0x54, 0x08, 0x2e, 0x48, 0x0d, 0xe9, 0xc1, 0x52, 0x1b, 0x59, 0xdb, 0x16, 0x89,
	0x53, 0xe4, 0xc4, 0xdb, 0xd4, 0xc2, 0xde, 0xb5, 0xd6, 0x1b, 0xaa, 0x1c, 0xf8, 0x03, 0xe5, 0xc2,
	0x91, 0x9f, 0xc4, 0xb1, 0x47, 0x4e, 0x05, 0x25, 0x7f, 0x04, 0x79, 0x6d, 0x27, 0x2e, 0x85, 0x03,
	0x88, 0xdb, 0xcc, 0x9b, 0xb7, 0x3b, 0x6f, 0xde, 0xce, 0xc2, 0x16, 0x67, 0x3c, 0xea, 0x48, 0x1e,
	0xf2, 0xce, 0xb9, 0x33, 0x14, 0xde, 0xc8, 0x0c, 0x05, 0x97, 0x1c, 0x57, 0x63, 0xdc, 0x8c, 0xf1,
	0xd6, 0xe6, 0x98, 0x8f, 0xb9, 0x42, 0x3b, 0x71, 0x94, 0x10, 0x5a, 0xfa, 0x98, 0xf3, 0xb1, 0x4f,
	0x3b, 0x2a, 0x1b, 0x4e, 0xce, 0x3b, 0xee, 0x44, 0x38, 0xd2, 0xe3, 0x2c, 0xa9, 0x1b, 0x53, 0x58,
	0xeb, 0x53, 0x79, 0xc9, 0xc5, 0xfb, 0x23, 0x67, 0x4a, 0x05, 0x7e, 0x06, 0x9a, 0x9c, 0x86, 0xb4,
	0x89, 0x76, 0xd0, 0xee, 0xfa, 0xde, 0x43, 0x73, 0x71, 0xbf, 0x99, 0xa7, 0x99, 0xa7, 0xd3, 0x90,
	0x12, 0xc5, 0xc4, 0x8f, 0x60, 0xcd, 0xf5, 0xa2, 0xd0, 0x77, 0xa6, 0x03, 0xe6, 0x04, 0xb4, 0x59,
	0xdc, 0x41, 0xbb, 0x55, 0x52, 0x4b, 0xb1, 0xbe, 0x13, 0x50, 0x63, 0x13, 0xb4, 0xf8, 0x00, 0x5e,
	0x83, 0xca, 0x59, 0xbf, 0x77, 0x48, 0x8e, 0x0e, 0xde, 0x35, 0x0a, 0xc6, 0x15, 0x82, 0xd2, 0xc9,
	0xa5, 0x27, 0x47, 0x17, 0xf8, 0x09, 0x54, 0x02, 0xee, 0x52, 0x7f, 0xe0, 0xb9, 0xaa, 0x73, 0xb5,
	0x5b, 0x9b, 0xdd, 0xb4, 0xcb, 0xc7, 0x31, 0x66, 0xf5, 0x48, 0x59, 0x15, 0x2d, 0x17, 0x63, 0xd0,
	0x04, 0xf7, 0xb3, 0x1e, 0x2a, 0xc6, 0x3d, 0xd8, 0x08, 0x1c, 0xe6, 0x8c, 0x69, 0x40, 0x99, 0x1c,
	0x50, 0xe6, 0x86, 0xdc, 0x63, 0xb2, 0xa9, 0xed, 0xa0, 0xdd, 0xda, 0xde, 0x46, 0x6e, 0x80, 0xc3,
	0xb4, 0x44, 0xf0, 0x92, 0x9f, 0x61, 0xc6, 0x47, 0x28, 0x11, 0x3e, 0x91, 0x54, 0xe0, 0xed, 0x5f,
	0xb5, 0xfc, 0x53, 0xfb, 0x95, 0xbf, 0x6b, 0x7f, 0x85, 0xa0, 0x6c, 0x5f, 0x4c, 0x6d, 0x2e, 0xe4,
	0x1d, 0x43, 0xd1, 0x1d, 0x43, 0xf1, 0x26, 0xac, 0x46, 0x21, 0xa5, 0x6e, 0xaa, 0x24, 0x49, 0x70,
	0x1b, 0x6a, 0x21, 0x17, 0x72, 0xc0, 0x26, 0xc1, 0x90, 0x0a, 0x25, 0xa1, 0x4e, 0x20, 0x86, 0xfa,
	0x0a, 0xc1, 0x8f, 0x61, 0x7d, 0x74, 0xe1, 0x30, 0x46, 0xfd, 0x8c, 0xa3, 0x29, 0x4e, 0x3d, 0x45,
	0x13, 0x9a, 0x31, 0x06, 0x78, 0xc3, 0x99, 0x14, 0xdc, 0xf7, 0xa9, 0xc0, 0xe6, 0xad, 0x8d, 0x68,
	0xe5, 0x26, 0x5a, 0x92, 0xf2, 0xfb, 0xf0, 0x1b, 0x93, 0x8c, 0x07, 0xe9, 0x02, 0xd4, 0xa1, 0x6a,
	0xef, 0x93, 0xb3, 0xfe, 0xa9, 0x75, 0x7c, 0xd8, 0x28, 0x18, 0x2f, 0xa1, 0x92, 0x39, 0x80, 0x9b,
	0x50, 0x76, 0x5c, 0x57, 0xd0, 0x28, 0xca, 0x5c, 0x4f, 0xd3, 0xf8, 0xc2, 0x78, 0x06, 0x75, 0x61,
	0x9d, 0xa8, 0xd8, 0x60, 0x50, 0xb5, 0xec, 0x83, 0x94, 0xf0, 0xf4, 0x96, 0xc2, 0xed, 0x9c, 0xc2,
	0x05, 0x27, 0x2f, 0x70, 0x0b, 0x8a, 0x5e, 0x98, 0xc8, 0xeb, 0x96, 0x66, 0x37, 0xed, 0xa2, 0x65,
	0x93, 0xa2, 0x17, 0x1a, 0xad, 0x54, 0x64, 0x05, 0x34, 0xcb, 0x7e, 0xbb, 0xdf, 0x28, 0xa4, 0xd1,
	0x8b, 0x06, 0x32, 0x3e, 0x21, 0x58, 0xb7, 0xf7, 0xc9, 0xe9, 0x09, 0x15, 0x1f, 0xa8, 0xb0, 0xd8,
	0x39, 0xc7, 0xaf, 0xa1, 0x31, 0x4a, 0x0c, 0x58, 0xbe, 0x3a, 0xfa, 0xf3, 0xab, 0xdf, 0x4b, 0xc9,
	0x8b, 0x81, 0x5f, 0x41, 0x59, 0x7a, 0x01, 0xe5, 0x13, 0xd9, 0x5c, 0x55, 0xc7, 0xb6, 0xcd, 0xe4,
	0xaf, 0x9a, 0xd9, 0x5f, 0x35, 0x7b, 0xe9, 0x5f, 0xed, 0x6a, 0x5f, 0xbe, 0xb7, 0x11, 0xc9, 0xf8,
	0xb1, 0x9a, 0xfb, 0x27, 0x2e, 0x5b, 0xfa, 0xff, 0x5f, 0x04, 0xb5, 0xa0, 0x32, 0x89, 0xa8, 0x50,
	0x3b, 0xb7, 0xa2, 0x9e, 0x60, 0x91, 0xc7, 0xb5, 0xd0, 0x89, 0xa2, 0x4b, 0x2e, 0x5c, 0xb5, 0x33,
	0x55, 0xb2, 0xc8, 0xbb, 0xcd, 0xaf, 0x33, 0x1d, 0x5d, 0xcf, 0x74, 0xf4, 0x63, 0xa6, 0xa3, 0xcf,
	0x73, 0xbd, 0x70, 0x3d, 0xd7, 0x0b, 0xdf, 0xe6, 0x7a, 0x61, 0x58, 0x52, 0x93, 0x3c, 0xff, 0x19,
	0x00, 0x00, 0xff, 0xff, 0xd3, 0x99, 0xc3, 0x59, 0xbe, 0x04, 0x00, 0x00,
}

func (m *NetworkLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Switch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelID) > 0 {
		i -= len(m.ModelID)
		copy(dAtA[i:], m.ModelID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhyPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhyPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhyPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChannelNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.ChannelNumber))
		i--
		dAtA[i] = 0x20
	}
	if m.PortNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.PortNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Speed) > 0 {
		i -= len(m.Speed)
		copy(dAtA[i:], m.Speed)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Speed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Controller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Controller) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Controller) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *P4RTServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RTServerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RTServerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintFabric(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x2a
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SdnControllerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdnControllerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SdnControllerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFabric(dAtA []byte, offset int, v uint64) int {
	offset -= sovFabric(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NetworkLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *PhyPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.PortNumber != 0 {
		n += 1 + sovFabric(uint64(m.PortNumber))
	}
	if m.ChannelNumber != 0 {
		n += 1 + sovFabric(uint64(m.ChannelNumber))
	}
	return n
}

func (m *Controller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovFabric(uint64(m.Port))
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *P4RTServerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *SdnControllerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func sovFabric(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFabric(x uint64) (n int) {
	return sovFabric(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NetworkLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkLayer_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Switch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhyPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhyPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhyPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelNumber", wireType)
			}
			m.ChannelNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Controller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Controller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Controller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Controller_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IPAddress_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RTServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RTServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RTServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdnControllerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdnControllerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdnControllerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFabric(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFabric
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFabric
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFabric
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFabric        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFabric          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFabric = fmt.Errorf("proto: unexpected end of group")
)
