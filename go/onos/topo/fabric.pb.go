// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/topo/fabric.proto

package topo

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Network_Type int32

const (
	Network_Layer2 Network_Type = 0
	Network_Layer3 Network_Type = 1
)

var Network_Type_name = map[int32]string{
	0: "Layer2",
	1: "Layer3",
}

var Network_Type_value = map[string]int32{
	"Layer2": 0,
	"Layer3": 1,
}

func (x Network_Type) String() string {
	return proto.EnumName(Network_Type_name, int32(x))
}

func (Network_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0, 0}
}

type Controller_Type int32

const (
	Controller_P4RUNTIME Controller_Type = 0
)

var Controller_Type_name = map[int32]string{
	0: "P4RUNTIME",
}

var Controller_Type_value = map[string]int32{
	"P4RUNTIME": 0,
}

func (x Controller_Type) String() string {
	return proto.EnumName(Controller_Type_name, int32(x))
}

func (Controller_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{8, 0}
}

type IPAddress_Type int32

const (
	IPAddress_IPV4 IPAddress_Type = 0
	IPAddress_IPV6 IPAddress_Type = 1
)

var IPAddress_Type_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}

var IPAddress_Type_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x IPAddress_Type) String() string {
	return proto.EnumName(IPAddress_Type_name, int32(x))
}

func (IPAddress_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{11, 0}
}

// Network aspect; aspect for a network entity with a specific kind  (e.g. L2 Network, L3 Network)
type Network struct {
	Type        Network_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.Network_Type" json:"type,omitempty"`
	DisplayName string       `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *Network) Reset()         { *m = Network{} }
func (m *Network) String() string { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()    {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func (m *Network) GetType() Network_Type {
	if m != nil {
		return m.Type
	}
	return Network_Layer2
}

func (m *Network) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// PacketSwitch aspect; aspect for a PACKET_SWITCH entity (Layer 2)
type PacketSwitch struct {
	ModelID            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	Vlans              []*VLAN   `protobuf:"bytes,3,rep,name=vlans,proto3" json:"vlans,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,4,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *PacketSwitch) Reset()         { *m = PacketSwitch{} }
func (m *PacketSwitch) String() string { return proto.CompactTextString(m) }
func (*PacketSwitch) ProtoMessage()    {}
func (*PacketSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{1}
}
func (m *PacketSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketSwitch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketSwitch.Merge(m, src)
}
func (m *PacketSwitch) XXX_Size() int {
	return m.Size()
}
func (m *PacketSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_PacketSwitch proto.InternalMessageInfo

func (m *PacketSwitch) GetModelID() string {
	if m != nil {
		return m.ModelID
	}
	return ""
}

func (m *PacketSwitch) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *PacketSwitch) GetVlans() []*VLAN {
	if m != nil {
		return m.Vlans
	}
	return nil
}

func (m *PacketSwitch) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// Router aspect; aspect of a ROUTER entity (Layer 3)
type Router struct {
	ModelId            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,3,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{2}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *Router) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Router) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// L2Port aspect; an aspect to represent a layer switch port
type L2Port struct {
	DisplayName   string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Speed         string `protobuf:"bytes,2,opt,name=speed,proto3" json:"speed,omitempty"`
	CageNumber    uint32 `protobuf:"varint,3,opt,name=cage_number,json=cageNumber,proto3" json:"cage_number,omitempty"`
	ChannelNumber uint32 `protobuf:"varint,4,opt,name=channel_number,json=channelNumber,proto3" json:"channel_number,omitempty"`
}

func (m *L2Port) Reset()         { *m = L2Port{} }
func (m *L2Port) String() string { return proto.CompactTextString(m) }
func (*L2Port) ProtoMessage()    {}
func (*L2Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{3}
}
func (m *L2Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2Port.Merge(m, src)
}
func (m *L2Port) XXX_Size() int {
	return m.Size()
}
func (m *L2Port) XXX_DiscardUnknown() {
	xxx_messageInfo_L2Port.DiscardUnknown(m)
}

var xxx_messageInfo_L2Port proto.InternalMessageInfo

func (m *L2Port) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *L2Port) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *L2Port) GetCageNumber() uint32 {
	if m != nil {
		return m.CageNumber
	}
	return 0
}

func (m *L2Port) GetChannelNumber() uint32 {
	if m != nil {
		return m.ChannelNumber
	}
	return 0
}

// L3Interface aspect; represents an L3 interface
type L3Interface struct {
	Ip           *IPAddress `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	PrefixLength uint32     `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength,proto3" json:"prefix_length,omitempty"`
}

func (m *L3Interface) Reset()         { *m = L3Interface{} }
func (m *L3Interface) String() string { return proto.CompactTextString(m) }
func (*L3Interface) ProtoMessage()    {}
func (*L3Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{4}
}
func (m *L3Interface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L3Interface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L3Interface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L3Interface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3Interface.Merge(m, src)
}
func (m *L3Interface) XXX_Size() int {
	return m.Size()
}
func (m *L3Interface) XXX_DiscardUnknown() {
	xxx_messageInfo_L3Interface.DiscardUnknown(m)
}

var xxx_messageInfo_L3Interface proto.InternalMessageInfo

func (m *L3Interface) GetIp() *IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *L3Interface) GetPrefixLength() uint32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

// Link aspect; an aspect to represent the origin and termination point of a link between two L2 Ports or two L3 interfaces
type Link struct {
	// Types that are valid to be assigned to Link:
	//	*Link_PhyPacketLink
	//	*Link_LogicalPacketLink
	Link isLink_Link `protobuf_oneof:"link"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{5}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

type isLink_Link interface {
	isLink_Link()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Link_PhyPacketLink struct {
	PhyPacketLink *PhyPacketLink `protobuf:"bytes,1,opt,name=phy_packet_link,json=phyPacketLink,proto3,oneof" json:"phy_packet_link,omitempty"`
}
type Link_LogicalPacketLink struct {
	LogicalPacketLink *LogicalPacketLink `protobuf:"bytes,2,opt,name=logical_packet_link,json=logicalPacketLink,proto3,oneof" json:"logical_packet_link,omitempty"`
}

func (*Link_PhyPacketLink) isLink_Link()     {}
func (*Link_LogicalPacketLink) isLink_Link() {}

func (m *Link) GetLink() isLink_Link {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *Link) GetPhyPacketLink() *PhyPacketLink {
	if x, ok := m.GetLink().(*Link_PhyPacketLink); ok {
		return x.PhyPacketLink
	}
	return nil
}

func (m *Link) GetLogicalPacketLink() *LogicalPacketLink {
	if x, ok := m.GetLink().(*Link_LogicalPacketLink); ok {
		return x.LogicalPacketLink
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Link) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Link_PhyPacketLink)(nil),
		(*Link_LogicalPacketLink)(nil),
	}
}

// PhyPacketLink a link between two l2 ports
type PhyPacketLink struct {
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *PhyPacketLink) Reset()         { *m = PhyPacketLink{} }
func (m *PhyPacketLink) String() string { return proto.CompactTextString(m) }
func (*PhyPacketLink) ProtoMessage()    {}
func (*PhyPacketLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{6}
}
func (m *PhyPacketLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhyPacketLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhyPacketLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhyPacketLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhyPacketLink.Merge(m, src)
}
func (m *PhyPacketLink) XXX_Size() int {
	return m.Size()
}
func (m *PhyPacketLink) XXX_DiscardUnknown() {
	xxx_messageInfo_PhyPacketLink.DiscardUnknown(m)
}

var xxx_messageInfo_PhyPacketLink proto.InternalMessageInfo

func (m *PhyPacketLink) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// LogicalPacketLink a link between two l3 interfaces
type LogicalPacketLink struct {
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *LogicalPacketLink) Reset()         { *m = LogicalPacketLink{} }
func (m *LogicalPacketLink) String() string { return proto.CompactTextString(m) }
func (*LogicalPacketLink) ProtoMessage()    {}
func (*LogicalPacketLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{7}
}
func (m *LogicalPacketLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalPacketLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalPacketLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalPacketLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalPacketLink.Merge(m, src)
}
func (m *LogicalPacketLink) XXX_Size() int {
	return m.Size()
}
func (m *LogicalPacketLink) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalPacketLink.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalPacketLink proto.InternalMessageInfo

func (m *LogicalPacketLink) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// Controller aspect; represents an instance of the controller deployment
type Controller struct {
	Type Controller_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.Controller_Type" json:"type,omitempty"`
	Role string          `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *Controller) Reset()         { *m = Controller{} }
func (m *Controller) String() string { return proto.CompactTextString(m) }
func (*Controller) ProtoMessage()    {}
func (*Controller) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{8}
}
func (m *Controller) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Controller) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Controller.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Controller) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Controller.Merge(m, src)
}
func (m *Controller) XXX_Size() int {
	return m.Size()
}
func (m *Controller) XXX_DiscardUnknown() {
	xxx_messageInfo_Controller.DiscardUnknown(m)
}

var xxx_messageInfo_Controller proto.InternalMessageInfo

func (m *Controller) GetType() Controller_Type {
	if m != nil {
		return m.Type
	}
	return Controller_P4RUNTIME
}

func (m *Controller) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Vlan VLAN attributes
type VLAN struct {
	Subnet      string `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet,omitempty"`
	ID          string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *VLAN) Reset()         { *m = VLAN{} }
func (m *VLAN) String() string { return proto.CompactTextString(m) }
func (*VLAN) ProtoMessage()    {}
func (*VLAN) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{9}
}
func (m *VLAN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VLAN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VLAN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VLAN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VLAN.Merge(m, src)
}
func (m *VLAN) XXX_Size() int {
	return m.Size()
}
func (m *VLAN) XXX_DiscardUnknown() {
	xxx_messageInfo_VLAN.DiscardUnknown(m)
}

var xxx_messageInfo_VLAN proto.InternalMessageInfo

func (m *VLAN) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *VLAN) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *VLAN) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *VLAN) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Endpoint specifies ip and port number for an endpoint address
type Endpoint struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{10}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Endpoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// IPAddress defines an ipv4 or ipv6 address
type IPAddress struct {
	Type IPAddress_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.IPAddress_Type" json:"type,omitempty"`
	IP   string         `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *IPAddress) Reset()         { *m = IPAddress{} }
func (m *IPAddress) String() string { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()    {}
func (*IPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{11}
}
func (m *IPAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddress.Merge(m, src)
}
func (m *IPAddress) XXX_Size() int {
	return m.Size()
}
func (m *IPAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddress proto.InternalMessageInfo

func (m *IPAddress) GetType() IPAddress_Type {
	if m != nil {
		return m.Type
	}
	return IPAddress_IPV4
}

func (m *IPAddress) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

// P4RTServerInfo aspect; specifies the control end point in a programmable device
type P4RTServerInfo struct {
	ControlEndpoint *Endpoint      `protobuf:"bytes,1,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Timeout         *time.Duration `protobuf:"bytes,5,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
}

func (m *P4RTServerInfo) Reset()         { *m = P4RTServerInfo{} }
func (m *P4RTServerInfo) String() string { return proto.CompactTextString(m) }
func (*P4RTServerInfo) ProtoMessage()    {}
func (*P4RTServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{12}
}
func (m *P4RTServerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RTServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RTServerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RTServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RTServerInfo.Merge(m, src)
}
func (m *P4RTServerInfo) XXX_Size() int {
	return m.Size()
}
func (m *P4RTServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RTServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_P4RTServerInfo proto.InternalMessageInfo

func (m *P4RTServerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *P4RTServerInfo) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func init() {
	proto.RegisterEnum("onos.topo.Network_Type", Network_Type_name, Network_Type_value)
	proto.RegisterEnum("onos.topo.Controller_Type", Controller_Type_name, Controller_Type_value)
	proto.RegisterEnum("onos.topo.IPAddress_Type", IPAddress_Type_name, IPAddress_Type_value)
	proto.RegisterType((*Network)(nil), "onos.topo.Network")
	proto.RegisterType((*PacketSwitch)(nil), "onos.topo.PacketSwitch")
	proto.RegisterType((*Router)(nil), "onos.topo.Router")
	proto.RegisterType((*L2Port)(nil), "onos.topo.L2Port")
	proto.RegisterType((*L3Interface)(nil), "onos.topo.L3Interface")
	proto.RegisterType((*Link)(nil), "onos.topo.Link")
	proto.RegisterType((*PhyPacketLink)(nil), "onos.topo.PhyPacketLink")
	proto.RegisterType((*LogicalPacketLink)(nil), "onos.topo.LogicalPacketLink")
	proto.RegisterType((*Controller)(nil), "onos.topo.Controller")
	proto.RegisterType((*VLAN)(nil), "onos.topo.VLAN")
	proto.RegisterType((*Endpoint)(nil), "onos.topo.Endpoint")
	proto.RegisterType((*IPAddress)(nil), "onos.topo.IPAddress")
	proto.RegisterType((*P4RTServerInfo)(nil), "onos.topo.P4RTServerInfo")
}

func init() { proto.RegisterFile("onos/topo/fabric.proto", fileDescriptor_705cdab724be9631) }

var fileDescriptor_705cdab724be9631 = []byte{
	// 801 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xce, 0xa4, 0x6e, 0xd2, 0xbc, 0x34, 0x6d, 0x76, 0x5a, 0x8a, 0x5b, 0x21, 0x37, 0x18, 0x16,
	0x55, 0x42, 0x38, 0x52, 0x5a, 0xad, 0xe0, 0x82, 0xb4, 0xa1, 0x2b, 0x61, 0x29, 0x1b, 0x59, 0xde,
	0xb2, 0xe2, 0x16, 0x39, 0xf6, 0xc4, 0x19, 0xd5, 0x99, 0xb1, 0xc6, 0x93, 0x5d, 0x22, 0xc4, 0x0f,
	0x40, 0x5c, 0x38, 0x72, 0xe6, 0x4f, 0xf0, 0x17, 0x38, 0xee, 0x91, 0xd3, 0x82, 0xd2, 0x3f, 0x82,
	0x3c, 0x9e, 0x34, 0xce, 0x66, 0x17, 0x2d, 0xb7, 0x99, 0x6f, 0xbe, 0xf7, 0xde, 0xf7, 0x66, 0xbe,
	0x37, 0x70, 0xc2, 0x19, 0xcf, 0xba, 0x92, 0xa7, 0xbc, 0x3b, 0x09, 0xc6, 0x82, 0x86, 0x4e, 0x2a,
	0xb8, 0xe4, 0xb8, 0x91, 0xe3, 0x4e, 0x8e, 0x9f, 0x1d, 0xc7, 0x3c, 0xe6, 0x0a, 0xed, 0xe6, 0xab,
	0x82, 0x70, 0x66, 0xc5, 0x9c, 0xc7, 0x09, 0xe9, 0xaa, 0xdd, 0x78, 0x3e, 0xe9, 0x46, 0x73, 0x11,
	0x48, 0xca, 0x59, 0x71, 0x6e, 0x2f, 0xa0, 0x3e, 0x24, 0xf2, 0x25, 0x17, 0xb7, 0xf8, 0x73, 0x30,
	0xe4, 0x22, 0x25, 0x26, 0xea, 0xa0, 0x8b, 0x83, 0xde, 0x87, 0xce, 0x7d, 0x6a, 0x47, 0x33, 0x9c,
	0x9b, 0x45, 0x4a, 0x7c, 0x45, 0xc2, 0x1f, 0xc3, 0x7e, 0x44, 0xb3, 0x34, 0x09, 0x16, 0x23, 0x16,
	0xcc, 0x88, 0x59, 0xed, 0xa0, 0x8b, 0x86, 0xdf, 0xd4, 0xd8, 0x30, 0x98, 0x11, 0xdb, 0x02, 0x23,
	0x0f, 0xc0, 0x00, 0xb5, 0x41, 0xb0, 0x20, 0xa2, 0xd7, 0xae, 0xdc, 0xaf, 0x2f, 0xdb, 0xc8, 0xfe,
	0x03, 0xc1, 0xbe, 0x17, 0x84, 0xb7, 0x44, 0x3e, 0x7b, 0x49, 0x65, 0x38, 0xc5, 0x9f, 0xc1, 0xde,
	0x8c, 0x47, 0x24, 0x19, 0xd1, 0x48, 0x89, 0x68, 0xf4, 0x9b, 0xcb, 0xd7, 0xe7, 0xf5, 0xa7, 0x39,
	0xe6, 0x5e, 0xfb, 0x75, 0x75, 0xe8, 0x46, 0x18, 0x83, 0x21, 0x78, 0xb2, 0xaa, 0xa9, 0xd6, 0xf8,
	0x21, 0xec, 0xbe, 0x48, 0x02, 0x96, 0x99, 0x3b, 0x9d, 0x9d, 0x8b, 0x66, 0xef, 0xb0, 0xa4, 0xfe,
	0xf9, 0xe0, 0xf1, 0xd0, 0x2f, 0x4e, 0xf1, 0x35, 0x1c, 0xcd, 0x02, 0x16, 0xc4, 0x64, 0x46, 0x98,
	0x1c, 0x11, 0x16, 0xa5, 0x9c, 0x32, 0x69, 0x1a, 0x1d, 0x74, 0xd1, 0xec, 0x1d, 0x95, 0x82, 0x9e,
	0xe8, 0x23, 0x1f, 0xaf, 0xf9, 0x2b, 0xcc, 0xfe, 0x09, 0x6a, 0x3e, 0x9f, 0x4b, 0x22, 0xf0, 0xe9,
	0x9b, 0x92, 0xff, 0x5b, 0xe5, 0x3b, 0xca, 0xef, 0xfc, 0xbf, 0xf2, 0x3f, 0x23, 0xa8, 0x0d, 0x7a,
	0x1e, 0x17, 0x72, 0xeb, 0x19, 0xd0, 0xd6, 0x33, 0xe0, 0x63, 0xd8, 0xcd, 0x52, 0x42, 0x22, 0x2d,
	0xa4, 0xd8, 0xe0, 0x73, 0x68, 0x86, 0x41, 0x4c, 0x46, 0x6c, 0x3e, 0x1b, 0x13, 0xa1, 0x14, 0xb4,
	0x7c, 0xc8, 0xa1, 0xa1, 0x42, 0xf0, 0x43, 0x38, 0x08, 0xa7, 0x01, 0x63, 0x24, 0x59, 0x71, 0x0c,
	0xc5, 0x69, 0x69, 0xb4, 0xa0, 0xd9, 0xdf, 0x43, 0x73, 0x70, 0xe9, 0x32, 0x49, 0xc4, 0x24, 0x08,
	0x09, 0xfe, 0x14, 0xaa, 0x34, 0x55, 0x2a, 0x9a, 0xbd, 0xe3, 0x52, 0x3f, 0xae, 0xf7, 0x38, 0x8a,
	0x04, 0xc9, 0x32, 0xbf, 0x4a, 0x53, 0xfc, 0x09, 0xb4, 0x52, 0x41, 0x26, 0xf4, 0x87, 0x51, 0x42,
	0x58, 0x2c, 0xa7, 0x4a, 0x5a, 0xcb, 0xdf, 0x2f, 0xc0, 0x81, 0xc2, 0xec, 0xdf, 0x11, 0x18, 0x03,
	0xca, 0x6e, 0x71, 0x1f, 0x0e, 0xd3, 0xe9, 0x62, 0x94, 0x2a, 0xab, 0x8c, 0x12, 0xca, 0x6e, 0x75,
	0x01, 0xb3, 0x54, 0xc0, 0x9b, 0x2e, 0x0a, 0x2f, 0xe5, 0x21, 0xdf, 0x56, 0xfc, 0x56, 0x5a, 0x06,
	0xf0, 0x10, 0x8e, 0x12, 0x1e, 0xd3, 0x30, 0x48, 0x36, 0xf2, 0x54, 0x55, 0x9e, 0x8f, 0x4a, 0x79,
	0x06, 0x05, 0x6b, 0x23, 0xd7, 0x83, 0xe4, 0x4d, 0xb0, 0x5f, 0x03, 0x23, 0x4f, 0x60, 0xf7, 0xa0,
	0xb5, 0x51, 0xf9, 0x3d, 0x1e, 0xc4, 0x7e, 0x04, 0x0f, 0xb6, 0xaa, 0xbc, 0x4f, 0x5c, 0x0c, 0xf0,
	0x0d, 0x67, 0x52, 0xf0, 0x24, 0x21, 0x02, 0x3b, 0x1b, 0xd3, 0x7a, 0x56, 0x6a, 0x61, 0x4d, 0x2a,
	0x0f, 0xec, 0x5b, 0xec, 0x68, 0x7f, 0xa0, 0x27, 0xb4, 0x05, 0x0d, 0xef, 0xca, 0xff, 0x6e, 0x78,
	0xe3, 0x3e, 0x7d, 0xd2, 0xae, 0xd8, 0x3f, 0x82, 0x91, 0xcf, 0x0c, 0x3e, 0x81, 0x5a, 0x36, 0x1f,
	0x33, 0x22, 0xb5, 0x1a, 0xbd, 0xc3, 0x27, 0x50, 0xa5, 0xda, 0x4e, 0xfd, 0xda, 0xf2, 0xf5, 0x79,
	0xd5, 0xbd, 0xf6, 0xab, 0x34, 0xda, 0xea, 0x61, 0x67, 0xdb, 0x8c, 0x1d, 0x68, 0x46, 0x24, 0x0b,
	0x05, 0x4d, 0xf3, 0x3f, 0x48, 0x59, 0x2a, 0x67, 0xac, 0x21, 0xfb, 0x4b, 0xd8, 0x5b, 0x19, 0x1d,
	0x9b, 0x50, 0x0f, 0x0a, 0xdb, 0xac, 0x86, 0x4b, 0x6f, 0xf3, 0x6e, 0x52, 0x2e, 0xa4, 0x36, 0x8e,
	0x5a, 0xdb, 0x0c, 0x1a, 0xf7, 0x36, 0xc3, 0x5f, 0x6c, 0x5c, 0xcf, 0xe9, 0xdb, 0xac, 0x58, 0xbe,
	0x9d, 0x13, 0xe5, 0xdb, 0x72, 0x4b, 0x5e, 0xee, 0x54, 0xfb, 0x4c, 0xdf, 0xd0, 0x1e, 0x18, 0xae,
	0xf7, 0xfc, 0xaa, 0x5d, 0xd1, 0xab, 0x47, 0x6d, 0x64, 0xff, 0x82, 0xe0, 0xc0, 0xbb, 0xf2, 0x6f,
	0x9e, 0x11, 0xf1, 0x82, 0x08, 0x97, 0x4d, 0x38, 0xfe, 0x1a, 0xda, 0x61, 0x71, 0xfb, 0xeb, 0xe1,
	0x46, 0xef, 0x1e, 0xee, 0x43, 0x4d, 0xbe, 0x6f, 0xf8, 0x2b, 0xa8, 0x4b, 0x3a, 0x23, 0x7c, 0x2e,
	0xcd, 0x5d, 0x15, 0x76, 0xea, 0x14, 0xff, 0xb7, 0xb3, 0xfa, 0xbf, 0x9d, 0x6b, 0xfd, 0x7f, 0xf7,
	0x8d, 0xdf, 0xfe, 0x3e, 0x47, 0xfe, 0x8a, 0xdf, 0x37, 0xff, 0x5c, 0x5a, 0xe8, 0xd5, 0xd2, 0x42,
	0xff, 0x2c, 0x2d, 0xf4, 0xeb, 0x9d, 0x55, 0x79, 0x75, 0x67, 0x55, 0xfe, 0xba, 0xb3, 0x2a, 0xe3,
	0x9a, 0x8a, 0xbd, 0xfc, 0x37, 0x00, 0x00, 0xff, 0xff, 0x27, 0xce, 0x30, 0x13, 0x44, 0x06, 0x00,
	0x00,
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PacketSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vlans) > 0 {
		for iNdEx := len(m.Vlans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vlans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFabric(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelID) > 0 {
		i -= len(m.ModelID)
		copy(dAtA[i:], m.ModelID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L2Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChannelNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.ChannelNumber))
		i--
		dAtA[i] = 0x20
	}
	if m.CageNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.CageNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Speed) > 0 {
		i -= len(m.Speed)
		copy(dAtA[i:], m.Speed)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Speed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L3Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L3Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L3Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrefixLength != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.PrefixLength))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Link != nil {
		{
			size := m.Link.Size()
			i -= size
			if _, err := m.Link.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Link_PhyPacketLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link_PhyPacketLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PhyPacketLink != nil {
		{
			size, err := m.PhyPacketLink.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Link_LogicalPacketLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link_LogicalPacketLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogicalPacketLink != nil {
		{
			size, err := m.LogicalPacketLink.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PhyPacketLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhyPacketLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhyPacketLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogicalPacketLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalPacketLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalPacketLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Controller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Controller) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Controller) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VLAN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VLAN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VLAN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subnet) > 0 {
		i -= len(m.Subnet)
		copy(dAtA[i:], m.Subnet)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *P4RTServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RTServerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RTServerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintFabric(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x2a
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFabric(dAtA []byte, offset int, v uint64) int {
	offset -= sovFabric(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *PacketSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if len(m.Vlans) > 0 {
		for _, e := range m.Vlans {
			l = e.Size()
			n += 1 + l + sovFabric(uint64(l))
		}
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *L2Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.CageNumber != 0 {
		n += 1 + sovFabric(uint64(m.CageNumber))
	}
	if m.ChannelNumber != 0 {
		n += 1 + sovFabric(uint64(m.ChannelNumber))
	}
	return n
}

func (m *L3Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.PrefixLength != 0 {
		n += 1 + sovFabric(uint64(m.PrefixLength))
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		n += m.Link.Size()
	}
	return n
}

func (m *Link_PhyPacketLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhyPacketLink != nil {
		l = m.PhyPacketLink.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}
func (m *Link_LogicalPacketLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogicalPacketLink != nil {
		l = m.LogicalPacketLink.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}
func (m *PhyPacketLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *LogicalPacketLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Controller) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *VLAN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subnet)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovFabric(uint64(m.Port))
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *P4RTServerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func sovFabric(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFabric(x uint64) (n int) {
	return sovFabric(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Network_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vlans = append(m.Vlans, &VLAN{})
			if err := m.Vlans[len(m.Vlans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CageNumber", wireType)
			}
			m.CageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CageNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelNumber", wireType)
			}
			m.ChannelNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L3Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L3Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L3Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &IPAddress{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLength", wireType)
			}
			m.PrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhyPacketLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PhyPacketLink{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Link = &Link_PhyPacketLink{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalPacketLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalPacketLink{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Link = &Link_LogicalPacketLink{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhyPacketLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhyPacketLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhyPacketLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalPacketLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalPacketLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalPacketLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Controller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Controller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Controller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Controller_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VLAN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VLAN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VLAN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IPAddress_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RTServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RTServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RTServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFabric(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFabric
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFabric
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFabric
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFabric        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFabric          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFabric = fmt.Errorf("proto: unexpected end of group")
)
