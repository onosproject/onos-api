// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/topo/fabric.proto

package topo

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NetworkLayer_Type int32

const (
	NetworkLayer_UNDERLAY NetworkLayer_Type = 0
)

var NetworkLayer_Type_name = map[int32]string{
	0: "UNDERLAY",
}

var NetworkLayer_Type_value = map[string]int32{
	"UNDERLAY": 0,
}

func (x NetworkLayer_Type) String() string {
	return proto.EnumName(NetworkLayer_Type_name, int32(x))
}

func (NetworkLayer_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0, 0}
}

type ControllerInfo_Type int32

const (
	ControllerInfo_P4RUNTIME ControllerInfo_Type = 0
)

var ControllerInfo_Type_name = map[int32]string{
	0: "P4RUNTIME",
}

var ControllerInfo_Type_value = map[string]int32{
	"P4RUNTIME": 0,
}

func (x ControllerInfo_Type) String() string {
	return proto.EnumName(ControllerInfo_Type_name, int32(x))
}

func (ControllerInfo_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{4, 0}
}

type IPAddress_Type int32

const (
	IPAddress_IPV4 IPAddress_Type = 0
	IPAddress_IPV6 IPAddress_Type = 1
)

var IPAddress_Type_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}

var IPAddress_Type_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x IPAddress_Type) String() string {
	return proto.EnumName(IPAddress_Type_name, int32(x))
}

func (IPAddress_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{7, 0}
}

// ConfigurationAction
type P4PipelineInfo_ConfigurationAction int32

const (
	P4PipelineInfo_UNSPECIFIED P4PipelineInfo_ConfigurationAction = 0
	// Verifies that the target can realize the given config. The forwarding state in the target is not modified.
	P4PipelineInfo_VERIFY P4PipelineInfo_ConfigurationAction = 1
	// Saves the config if the P4Runtime target can realize it. The forwarding state in the target is not modified.
	P4PipelineInfo_VERIFY_AND_SAVE P4PipelineInfo_ConfigurationAction = 2
	// Saves and realizes the given config if the P4Runtime target can realize it. The forwarding state in the target is cleared.
	P4PipelineInfo_VERIFY_AND_COMMIT P4PipelineInfo_ConfigurationAction = 3
	// Realizes the last saved, but not yet committed, config.
	// The forwarding state in the target is updated by replaying the write requests to the target device since the last config was saved
	P4PipelineInfo_COMMIT P4PipelineInfo_ConfigurationAction = 4
	// Verifies, saves and realizes the given config, while preserving the forwarding state in the target.
	P4PipelineInfo_RECONCILE_AND_COMMIT P4PipelineInfo_ConfigurationAction = 5
)

var P4PipelineInfo_ConfigurationAction_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "VERIFY",
	2: "VERIFY_AND_SAVE",
	3: "VERIFY_AND_COMMIT",
	4: "COMMIT",
	5: "RECONCILE_AND_COMMIT",
}

var P4PipelineInfo_ConfigurationAction_value = map[string]int32{
	"UNSPECIFIED":          0,
	"VERIFY":               1,
	"VERIFY_AND_SAVE":      2,
	"VERIFY_AND_COMMIT":    3,
	"COMMIT":               4,
	"RECONCILE_AND_COMMIT": 5,
}

func (x P4PipelineInfo_ConfigurationAction) String() string {
	return proto.EnumName(P4PipelineInfo_ConfigurationAction_name, int32(x))
}

func (P4PipelineInfo_ConfigurationAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{9, 0}
}

// NetworkLayer aspect; aspect for a NetworkLayer entity with a specific kind
type NetworkLayer struct {
	Type        NetworkLayer_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.NetworkLayer_Type" json:"type,omitempty"`
	DisplayName string            `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *NetworkLayer) Reset()         { *m = NetworkLayer{} }
func (m *NetworkLayer) String() string { return proto.CompactTextString(m) }
func (*NetworkLayer) ProtoMessage()    {}
func (*NetworkLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0}
}
func (m *NetworkLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkLayer.Merge(m, src)
}
func (m *NetworkLayer) XXX_Size() int {
	return m.Size()
}
func (m *NetworkLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkLayer.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkLayer proto.InternalMessageInfo

func (m *NetworkLayer) GetType() NetworkLayer_Type {
	if m != nil {
		return m.Type
	}
	return NetworkLayer_UNDERLAY
}

func (m *NetworkLayer) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// Switch aspect; aspect for a SWITCH entity
type Switch struct {
	ModelID            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,4,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Switch) Reset()         { *m = Switch{} }
func (m *Switch) String() string { return proto.CompactTextString(m) }
func (*Switch) ProtoMessage()    {}
func (*Switch) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{1}
}
func (m *Switch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Switch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Switch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Switch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Switch.Merge(m, src)
}
func (m *Switch) XXX_Size() int {
	return m.Size()
}
func (m *Switch) XXX_DiscardUnknown() {
	xxx_messageInfo_Switch.DiscardUnknown(m)
}

var xxx_messageInfo_Switch proto.InternalMessageInfo

func (m *Switch) GetModelID() string {
	if m != nil {
		return m.ModelID
	}
	return ""
}

func (m *Switch) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Switch) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// Router aspect; aspect of a ROUTER entity (Layer 3)
type Router struct {
	ModelId            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,3,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{2}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *Router) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Router) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// PhyPort aspect; an aspect to represent a physical switch port
type PhyPort struct {
	DisplayName     string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Speed           string `protobuf:"bytes,2,opt,name=speed,proto3" json:"speed,omitempty"`
	PortNumber      uint32 `protobuf:"varint,3,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	ChannelNumber   uint32 `protobuf:"varint,4,opt,name=channel_number,json=channelNumber,proto3" json:"channel_number,omitempty"`
	TargetID        string `protobuf:"bytes,5,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	Enabled         bool   `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	HealthIndicator string `protobuf:"bytes,7,opt,name=health_indicator,json=healthIndicator,proto3" json:"health_indicator,omitempty"`
	IfIndex         uint32 `protobuf:"varint,8,opt,name=if_index,json=ifIndex,proto3" json:"if_index,omitempty"`
}

func (m *PhyPort) Reset()         { *m = PhyPort{} }
func (m *PhyPort) String() string { return proto.CompactTextString(m) }
func (*PhyPort) ProtoMessage()    {}
func (*PhyPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{3}
}
func (m *PhyPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhyPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhyPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhyPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhyPort.Merge(m, src)
}
func (m *PhyPort) XXX_Size() int {
	return m.Size()
}
func (m *PhyPort) XXX_DiscardUnknown() {
	xxx_messageInfo_PhyPort.DiscardUnknown(m)
}

var xxx_messageInfo_PhyPort proto.InternalMessageInfo

func (m *PhyPort) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PhyPort) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *PhyPort) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *PhyPort) GetChannelNumber() uint32 {
	if m != nil {
		return m.ChannelNumber
	}
	return 0
}

func (m *PhyPort) GetTargetID() string {
	if m != nil {
		return m.TargetID
	}
	return ""
}

func (m *PhyPort) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PhyPort) GetHealthIndicator() string {
	if m != nil {
		return m.HealthIndicator
	}
	return ""
}

func (m *PhyPort) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

// Controller aspect; represents an instance of the controller deployment
type ControllerInfo struct {
	Type            ControllerInfo_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.ControllerInfo_Type" json:"type,omitempty"`
	Role            *ControllerRole     `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ControlEndpoint *Endpoint           `protobuf:"bytes,3,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Username        string              `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password        string              `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *ControllerInfo) Reset()         { *m = ControllerInfo{} }
func (m *ControllerInfo) String() string { return proto.CompactTextString(m) }
func (*ControllerInfo) ProtoMessage()    {}
func (*ControllerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{4}
}
func (m *ControllerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControllerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControllerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControllerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerInfo.Merge(m, src)
}
func (m *ControllerInfo) XXX_Size() int {
	return m.Size()
}
func (m *ControllerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerInfo proto.InternalMessageInfo

func (m *ControllerInfo) GetType() ControllerInfo_Type {
	if m != nil {
		return m.Type
	}
	return ControllerInfo_P4RUNTIME
}

func (m *ControllerInfo) GetRole() *ControllerRole {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *ControllerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *ControllerInfo) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ControllerInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type ControllerRole struct {
	Name   string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Config *types.Any `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *ControllerRole) Reset()         { *m = ControllerRole{} }
func (m *ControllerRole) String() string { return proto.CompactTextString(m) }
func (*ControllerRole) ProtoMessage()    {}
func (*ControllerRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{5}
}
func (m *ControllerRole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControllerRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControllerRole.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControllerRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerRole.Merge(m, src)
}
func (m *ControllerRole) XXX_Size() int {
	return m.Size()
}
func (m *ControllerRole) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerRole.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerRole proto.InternalMessageInfo

func (m *ControllerRole) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ControllerRole) GetConfig() *types.Any {
	if m != nil {
		return m.Config
	}
	return nil
}

// Endpoint specifies ip and port number for an endpoint address
type Endpoint struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{6}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Endpoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// IPAddress defines an ipv4 or ipv6 address
type IPAddress struct {
	Type IPAddress_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.IPAddress_Type" json:"type,omitempty"`
	IP   string         `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *IPAddress) Reset()         { *m = IPAddress{} }
func (m *IPAddress) String() string { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()    {}
func (*IPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{7}
}
func (m *IPAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddress.Merge(m, src)
}
func (m *IPAddress) XXX_Size() int {
	return m.Size()
}
func (m *IPAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddress proto.InternalMessageInfo

func (m *IPAddress) GetType() IPAddress_Type {
	if m != nil {
		return m.Type
	}
	return IPAddress_IPV4
}

func (m *IPAddress) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

// P4RTServerInfo aspect; specifies the control end point in a programmable device
type P4RTServerInfo struct {
	ControlEndpoint *Endpoint         `protobuf:"bytes,1,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Timeout         *time.Duration    `protobuf:"bytes,2,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
	DeviceID        uint64            `protobuf:"varint,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	Pipelines       []*P4PipelineInfo `protobuf:"bytes,4,rep,name=pipelines,proto3" json:"pipelines,omitempty"`
}

func (m *P4RTServerInfo) Reset()         { *m = P4RTServerInfo{} }
func (m *P4RTServerInfo) String() string { return proto.CompactTextString(m) }
func (*P4RTServerInfo) ProtoMessage()    {}
func (*P4RTServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{8}
}
func (m *P4RTServerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RTServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RTServerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RTServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RTServerInfo.Merge(m, src)
}
func (m *P4RTServerInfo) XXX_Size() int {
	return m.Size()
}
func (m *P4RTServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RTServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_P4RTServerInfo proto.InternalMessageInfo

func (m *P4RTServerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *P4RTServerInfo) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *P4RTServerInfo) GetDeviceID() uint64 {
	if m != nil {
		return m.DeviceID
	}
	return 0
}

func (m *P4RTServerInfo) GetPipelines() []*P4PipelineInfo {
	if m != nil {
		return m.Pipelines
	}
	return nil
}

// P4PipelineInfo p4 pipeline information
type P4PipelineInfo struct {
	Name                string                             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version             string                             `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Architecture        string                             `protobuf:"bytes,3,opt,name=architecture,proto3" json:"architecture,omitempty"`
	ConfigurationAction P4PipelineInfo_ConfigurationAction `protobuf:"varint,4,opt,name=configuration_action,json=configurationAction,proto3,enum=onos.topo.P4PipelineInfo_ConfigurationAction" json:"configuration_action,omitempty"`
}

func (m *P4PipelineInfo) Reset()         { *m = P4PipelineInfo{} }
func (m *P4PipelineInfo) String() string { return proto.CompactTextString(m) }
func (*P4PipelineInfo) ProtoMessage()    {}
func (*P4PipelineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{9}
}
func (m *P4PipelineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4PipelineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4PipelineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4PipelineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4PipelineInfo.Merge(m, src)
}
func (m *P4PipelineInfo) XXX_Size() int {
	return m.Size()
}
func (m *P4PipelineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_P4PipelineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_P4PipelineInfo proto.InternalMessageInfo

func (m *P4PipelineInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *P4PipelineInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *P4PipelineInfo) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *P4PipelineInfo) GetConfigurationAction() P4PipelineInfo_ConfigurationAction {
	if m != nil {
		return m.ConfigurationAction
	}
	return P4PipelineInfo_UNSPECIFIED
}

// P4RTMastershipState mastership state for the P4runtime targets
type P4RTMastershipState struct {
	Term         uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	ConnectionID string `protobuf:"bytes,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Role         string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *P4RTMastershipState) Reset()         { *m = P4RTMastershipState{} }
func (m *P4RTMastershipState) String() string { return proto.CompactTextString(m) }
func (*P4RTMastershipState) ProtoMessage()    {}
func (*P4RTMastershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{10}
}
func (m *P4RTMastershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RTMastershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RTMastershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RTMastershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RTMastershipState.Merge(m, src)
}
func (m *P4RTMastershipState) XXX_Size() int {
	return m.Size()
}
func (m *P4RTMastershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RTMastershipState.DiscardUnknown(m)
}

var xxx_messageInfo_P4RTMastershipState proto.InternalMessageInfo

func (m *P4RTMastershipState) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *P4RTMastershipState) GetConnectionID() string {
	if m != nil {
		return m.ConnectionID
	}
	return ""
}

func (m *P4RTMastershipState) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Service service entity which will be used to store mastership state for an application
type Service struct {
	TargetID        string               `protobuf:"bytes,1,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	Mastershipstate *P4RTMastershipState `protobuf:"bytes,2,opt,name=mastershipstate,proto3" json:"mastershipstate,omitempty"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{11}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetTargetID() string {
	if m != nil {
		return m.TargetID
	}
	return ""
}

func (m *Service) GetMastershipstate() *P4RTMastershipState {
	if m != nil {
		return m.Mastershipstate
	}
	return nil
}

func init() {
	proto.RegisterEnum("onos.topo.NetworkLayer_Type", NetworkLayer_Type_name, NetworkLayer_Type_value)
	proto.RegisterEnum("onos.topo.ControllerInfo_Type", ControllerInfo_Type_name, ControllerInfo_Type_value)
	proto.RegisterEnum("onos.topo.IPAddress_Type", IPAddress_Type_name, IPAddress_Type_value)
	proto.RegisterEnum("onos.topo.P4PipelineInfo_ConfigurationAction", P4PipelineInfo_ConfigurationAction_name, P4PipelineInfo_ConfigurationAction_value)
	proto.RegisterType((*NetworkLayer)(nil), "onos.topo.NetworkLayer")
	proto.RegisterType((*Switch)(nil), "onos.topo.Switch")
	proto.RegisterType((*Router)(nil), "onos.topo.Router")
	proto.RegisterType((*PhyPort)(nil), "onos.topo.PhyPort")
	proto.RegisterType((*ControllerInfo)(nil), "onos.topo.ControllerInfo")
	proto.RegisterType((*ControllerRole)(nil), "onos.topo.ControllerRole")
	proto.RegisterType((*Endpoint)(nil), "onos.topo.Endpoint")
	proto.RegisterType((*IPAddress)(nil), "onos.topo.IPAddress")
	proto.RegisterType((*P4RTServerInfo)(nil), "onos.topo.P4RTServerInfo")
	proto.RegisterType((*P4PipelineInfo)(nil), "onos.topo.P4PipelineInfo")
	proto.RegisterType((*P4RTMastershipState)(nil), "onos.topo.P4RTMastershipState")
	proto.RegisterType((*Service)(nil), "onos.topo.Service")
}

func init() { proto.RegisterFile("onos/topo/fabric.proto", fileDescriptor_705cdab724be9631) }

var fileDescriptor_705cdab724be9631 = []byte{
	// 1028 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4d, 0x6f, 0xeb, 0x44,
	0x17, 0x8e, 0x53, 0x37, 0x1f, 0x27, 0x69, 0x9b, 0x77, 0x92, 0x7b, 0xe5, 0x56, 0xaf, 0x92, 0x62,
	0x09, 0xd4, 0x2b, 0xd1, 0x14, 0x95, 0xf2, 0xb5, 0x41, 0x4a, 0x93, 0x5c, 0x61, 0xa9, 0xcd, 0x8d,
	0xa6, 0x1f, 0xd2, 0x5d, 0x05, 0xd7, 0x9e, 0x24, 0x16, 0xce, 0x8c, 0x35, 0x9e, 0xb4, 0x64, 0x01,
	0x0b, 0xc4, 0x8a, 0x15, 0x1b, 0x24, 0x7e, 0x12, 0x12, 0x9b, 0xbb, 0x64, 0x55, 0x50, 0xfa, 0x03,
	0xf8, 0x0b, 0x68, 0xc6, 0x93, 0xd4, 0x69, 0x0b, 0xe2, 0xb2, 0xca, 0x39, 0xcf, 0x79, 0x26, 0x73,
	0x3e, 0x9e, 0x33, 0x86, 0xe7, 0x8c, 0xb2, 0xf8, 0x40, 0xb0, 0x88, 0x1d, 0x0c, 0xdd, 0x2b, 0x1e,
	0x78, 0xcd, 0x88, 0x33, 0xc1, 0x50, 0x51, 0xe2, 0x4d, 0x89, 0xef, 0xd4, 0x46, 0x6c, 0xc4, 0x14,
	0x7a, 0x20, 0xad, 0x84, 0xb0, 0x53, 0x1f, 0x31, 0x36, 0x0a, 0xc9, 0x81, 0xf2, 0xae, 0xa6, 0xc3,
	0x03, 0x7f, 0xca, 0x5d, 0x11, 0x30, 0xaa, 0xe3, 0xdb, 0x0f, 0xe3, 0x2e, 0x9d, 0x25, 0x21, 0x7b,
	0x06, 0xe5, 0x1e, 0x11, 0x37, 0x8c, 0x7f, 0x75, 0xe2, 0xce, 0x08, 0x47, 0x1f, 0x80, 0x29, 0x66,
	0x11, 0xb1, 0x8c, 0x5d, 0x63, 0x6f, 0xf3, 0xf0, 0xff, 0xcd, 0xe5, 0xd5, 0xcd, 0x34, 0xad, 0x79,
	0x3e, 0x8b, 0x08, 0x56, 0x4c, 0xf4, 0x0e, 0x94, 0xfd, 0x20, 0x8e, 0x42, 0x77, 0x36, 0xa0, 0xee,
	0x84, 0x58, 0xd9, 0x5d, 0x63, 0xaf, 0x88, 0x4b, 0x1a, 0xeb, 0xb9, 0x13, 0x62, 0xd7, 0xc0, 0x94,
	0x07, 0x50, 0x19, 0x0a, 0x17, 0xbd, 0x4e, 0x17, 0x9f, 0xb4, 0x5e, 0x57, 0x32, 0xf6, 0x0f, 0x06,
	0xe4, 0xce, 0x6e, 0x02, 0xe1, 0x8d, 0xd1, 0x7b, 0x50, 0x98, 0x30, 0x9f, 0x84, 0x83, 0xc0, 0x57,
	0x37, 0x17, 0x8f, 0x4b, 0xf3, 0xdb, 0x46, 0xfe, 0x54, 0x62, 0x4e, 0x07, 0xe7, 0x55, 0xd0, 0xf1,
	0x11, 0x02, 0x93, 0xb3, 0x70, 0x71, 0x87, 0xb2, 0x51, 0x07, 0xaa, 0x13, 0x97, 0xba, 0x23, 0x32,
	0x21, 0x54, 0x0c, 0x08, 0xf5, 0x23, 0x16, 0x50, 0x61, 0x99, 0xbb, 0xc6, 0x5e, 0xe9, 0xb0, 0x9a,
	0x2a, 0xa0, 0xab, 0x43, 0x18, 0xdd, 0xf3, 0x17, 0x98, 0xfd, 0x0d, 0xe4, 0x30, 0x9b, 0x0a, 0xc2,
	0xd1, 0xf6, 0xc3, 0x5c, 0xfe, 0xd3, 0xf5, 0x6b, 0x6f, 0x77, 0xfd, 0x4f, 0x59, 0xc8, 0xf7, 0xc7,
	0xb3, 0x3e, 0xe3, 0xe2, 0x51, 0x43, 0x8d, 0x47, 0x0d, 0x45, 0x35, 0x58, 0x8f, 0x23, 0x42, 0x7c,
	0x9d, 0x49, 0xe2, 0xa0, 0x06, 0x94, 0x22, 0xc6, 0xc5, 0x80, 0x4e, 0x27, 0x57, 0x84, 0xab, 0x14,
	0x36, 0x30, 0x48, 0xa8, 0xa7, 0x10, 0xf4, 0x2e, 0x6c, 0x7a, 0x63, 0x97, 0x52, 0x12, 0x2e, 0x38,
	0xa6, 0xe2, 0x6c, 0x68, 0x54, 0xd3, 0x5e, 0x40, 0x51, 0xb8, 0x7c, 0x44, 0x84, 0x6c, 0xc1, 0xba,
	0x1a, 0x47, 0x79, 0x7e, 0xdb, 0x28, 0x9c, 0x2b, 0xd0, 0xe9, 0xe0, 0x42, 0x12, 0x76, 0x7c, 0x64,
	0x41, 0x9e, 0x50, 0xf7, 0x2a, 0x24, 0xbe, 0x95, 0xdb, 0x35, 0xf6, 0x0a, 0x78, 0xe1, 0xa2, 0x17,
	0x50, 0x19, 0x13, 0x37, 0x14, 0xe3, 0x41, 0x40, 0xfd, 0xc0, 0x73, 0x05, 0xe3, 0x56, 0x5e, 0x65,
	0xbb, 0x95, 0xe0, 0xce, 0x02, 0x96, 0x1d, 0x0f, 0x86, 0x92, 0x46, 0xbe, 0xb6, 0x0a, 0x2a, 0xa1,
	0x7c, 0x30, 0x74, 0xa4, 0x6b, 0x7f, 0x97, 0x85, 0xcd, 0x36, 0xa3, 0x82, 0xb3, 0x30, 0x24, 0xdc,
	0xa1, 0x43, 0x86, 0x0e, 0x57, 0x14, 0x5a, 0x4f, 0x75, 0x78, 0x95, 0x98, 0xd6, 0xe8, 0x7e, 0x6a,
	0x70, 0xa5, 0xc3, 0xed, 0x27, 0xcf, 0x60, 0x16, 0x12, 0x3d, 0xd3, 0xcf, 0xa1, 0xe2, 0x25, 0xf8,
	0xbf, 0x1a, 0xe8, 0x96, 0x26, 0x2f, 0x00, 0xb4, 0x03, 0x85, 0x69, 0x4c, 0xb8, 0x9a, 0x9e, 0xa9,
	0x6a, 0x5e, 0xfa, 0x32, 0x16, 0xb9, 0x71, 0x7c, 0xc3, 0xb8, 0xee, 0x2d, 0x5e, 0xfa, 0xf6, 0x33,
	0xbd, 0x27, 0x1b, 0x50, 0xec, 0x1f, 0xe1, 0x8b, 0xde, 0xb9, 0x73, 0xda, 0xad, 0x64, 0x6c, 0x9c,
	0xee, 0x81, 0x4c, 0x53, 0x0a, 0x31, 0x25, 0x0d, 0x65, 0xa3, 0xf7, 0x21, 0xe7, 0x31, 0x3a, 0x0c,
	0x46, 0xba, 0xca, 0x5a, 0x33, 0xd9, 0xfa, 0xe6, 0x62, 0xeb, 0x9b, 0x2d, 0x3a, 0xc3, 0x9a, 0x63,
	0x7f, 0x0a, 0x85, 0x65, 0xba, 0x16, 0xe4, 0x5d, 0xdf, 0xe7, 0x24, 0x8e, 0x17, 0x82, 0xd7, 0xae,
	0xbc, 0x47, 0xca, 0x47, 0xfd, 0xe3, 0x06, 0x56, 0xb6, 0x4d, 0xa1, 0xe8, 0xf4, 0x5b, 0x9a, 0xb0,
	0xbf, 0x32, 0x8c, 0x74, 0x63, 0x97, 0x9c, 0xf4, 0x1c, 0x9e, 0x43, 0x36, 0x88, 0x12, 0xd1, 0x1e,
	0xe7, 0xe6, 0xb7, 0x8d, 0xac, 0xd3, 0xc7, 0xd9, 0x20, 0xb2, 0x77, 0x74, 0xe1, 0x05, 0x30, 0x9d,
	0xfe, 0xe5, 0x51, 0x25, 0xa3, 0xad, 0x8f, 0x2b, 0x86, 0xfd, 0xa7, 0x01, 0x9b, 0xfd, 0x23, 0x7c,
	0x7e, 0x46, 0xf8, 0xb5, 0x96, 0xc0, 0x53, 0xf3, 0x31, 0xde, 0x62, 0x3e, 0x9f, 0x41, 0x5e, 0x04,
	0x13, 0xc2, 0xa6, 0x62, 0xa9, 0x88, 0x87, 0xbd, 0xea, 0xe8, 0x17, 0xf4, 0xd8, 0xfc, 0xf9, 0xf7,
	0x86, 0x81, 0x17, 0x7c, 0xb9, 0x1b, 0x3e, 0xb9, 0x0e, 0x3c, 0x22, 0x77, 0x43, 0x6a, 0xc2, 0x4c,
	0x76, 0xa3, 0xa3, 0x40, 0xb9, 0x1b, 0x49, 0xd8, 0xf1, 0xd1, 0x27, 0x50, 0x8c, 0x82, 0x88, 0x84,
	0x01, 0x25, 0xb1, 0x65, 0xee, 0xae, 0x3d, 0x50, 0x5e, 0xff, 0xa8, 0xaf, 0xa3, 0xb2, 0x26, 0x7c,
	0xcf, 0xb5, 0x7f, 0xcd, 0xca, 0x8a, 0xd3, 0xd1, 0x27, 0x07, 0x6e, 0x41, 0xfe, 0x9a, 0xf0, 0x38,
	0x60, 0x54, 0x3f, 0x03, 0x0b, 0x17, 0xd9, 0x50, 0x76, 0xb9, 0x37, 0x0e, 0x04, 0xf1, 0xc4, 0x94,
	0x13, 0x95, 0x67, 0x11, 0xaf, 0x60, 0xe8, 0x4b, 0xa8, 0x25, 0x52, 0xd0, 0x85, 0x0e, 0x5c, 0x4f,
	0xfe, 0x28, 0xbd, 0x6e, 0x1e, 0xee, 0xff, 0x6d, 0xa2, 0x72, 0x63, 0xee, 0x4f, 0xb5, 0xd4, 0x21,
	0x5c, 0xf5, 0x1e, 0x83, 0xf6, 0xf7, 0x06, 0x54, 0x9f, 0x20, 0xa3, 0x2d, 0x28, 0x5d, 0xf4, 0xce,
	0xfa, 0xdd, 0xb6, 0xf3, 0xd2, 0xe9, 0x76, 0x2a, 0x19, 0x04, 0x90, 0xbb, 0xec, 0x62, 0xe7, 0xe5,
	0xeb, 0x8a, 0x81, 0xaa, 0xb0, 0x95, 0xd8, 0x83, 0x56, 0xaf, 0x33, 0x38, 0x6b, 0x5d, 0x76, 0x2b,
	0x59, 0xf4, 0x0c, 0xfe, 0x97, 0x02, 0xdb, 0xaf, 0x4e, 0x4f, 0x9d, 0xf3, 0xca, 0x9a, 0x3c, 0xa7,
	0x6d, 0x13, 0x59, 0x50, 0xc3, 0xdd, 0xf6, 0xab, 0x5e, 0xdb, 0x39, 0xe9, 0xa6, 0x59, 0xeb, 0xb6,
	0x80, 0xaa, 0x94, 0xcf, 0xa9, 0x1b, 0x0b, 0xc2, 0xe3, 0x71, 0x10, 0x9d, 0x09, 0x57, 0xa8, 0x15,
	0x12, 0x84, 0x4f, 0x54, 0x47, 0x4d, 0xac, 0x6c, 0xf4, 0x11, 0x6c, 0x78, 0x8c, 0x52, 0xa2, 0xf2,
	0x94, 0x03, 0x4e, 0x94, 0x5a, 0x99, 0xdf, 0x36, 0xca, 0xed, 0x65, 0xc0, 0xe9, 0xe0, 0xf2, 0x3d,
	0x2d, 0xf5, 0x59, 0x58, 0xbb, 0xff, 0x2c, 0xd8, 0xdf, 0x42, 0x5e, 0x0a, 0x36, 0xf0, 0xc8, 0xea,
	0x73, 0x6a, 0xfc, 0xe3, 0x73, 0xfa, 0x05, 0x6c, 0x4d, 0x96, 0x79, 0xc6, 0x32, 0x4f, 0x2d, 0xd0,
	0xfa, 0xca, 0x3c, 0x1e, 0x55, 0x83, 0x1f, 0x1e, 0x3b, 0xb6, 0x7e, 0x99, 0xd7, 0x8d, 0x37, 0xf3,
	0xba, 0xf1, 0xc7, 0xbc, 0x6e, 0xfc, 0x78, 0x57, 0xcf, 0xbc, 0xb9, 0xab, 0x67, 0x7e, 0xbb, 0xab,
	0x67, 0xae, 0x72, 0x4a, 0xe3, 0x1f, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0xdc, 0xa8, 0x4c, 0x5c,
	0x6e, 0x08, 0x00, 0x00,
}

func (m *NetworkLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Switch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelID) > 0 {
		i -= len(m.ModelID)
		copy(dAtA[i:], m.ModelID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhyPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhyPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhyPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IfIndex != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x40
	}
	if len(m.HealthIndicator) > 0 {
		i -= len(m.HealthIndicator)
		copy(dAtA[i:], m.HealthIndicator)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.HealthIndicator)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.TargetID) > 0 {
		i -= len(m.TargetID)
		copy(dAtA[i:], m.TargetID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.TargetID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ChannelNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.ChannelNumber))
		i--
		dAtA[i] = 0x20
	}
	if m.PortNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.PortNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Speed) > 0 {
		i -= len(m.Speed)
		copy(dAtA[i:], m.Speed)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Speed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControllerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControllerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControllerRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControllerRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *P4RTServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RTServerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RTServerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pipelines) > 0 {
		for iNdEx := len(m.Pipelines) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pipelines[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFabric(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DeviceID != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.DeviceID))
		i--
		dAtA[i] = 0x18
	}
	if m.Timeout != nil {
		n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintFabric(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x12
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P4PipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4PipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4PipelineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigurationAction != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.ConfigurationAction))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P4RTMastershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RTMastershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RTMastershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConnectionID) > 0 {
		i -= len(m.ConnectionID)
		copy(dAtA[i:], m.ConnectionID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ConnectionID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Term != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mastershipstate != nil {
		{
			size, err := m.Mastershipstate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TargetID) > 0 {
		i -= len(m.TargetID)
		copy(dAtA[i:], m.TargetID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.TargetID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFabric(dAtA []byte, offset int, v uint64) int {
	offset -= sovFabric(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NetworkLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *PhyPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.PortNumber != 0 {
		n += 1 + sovFabric(uint64(m.PortNumber))
	}
	if m.ChannelNumber != 0 {
		n += 1 + sovFabric(uint64(m.ChannelNumber))
	}
	l = len(m.TargetID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.HealthIndicator)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.IfIndex != 0 {
		n += 1 + sovFabric(uint64(m.IfIndex))
	}
	return n
}

func (m *ControllerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *ControllerRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovFabric(uint64(m.Port))
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *P4RTServerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.DeviceID != 0 {
		n += 1 + sovFabric(uint64(m.DeviceID))
	}
	if len(m.Pipelines) > 0 {
		for _, e := range m.Pipelines {
			l = e.Size()
			n += 1 + l + sovFabric(uint64(l))
		}
	}
	return n
}

func (m *P4PipelineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ConfigurationAction != 0 {
		n += 1 + sovFabric(uint64(m.ConfigurationAction))
	}
	return n
}

func (m *P4RTMastershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovFabric(uint64(m.Term))
	}
	l = len(m.ConnectionID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TargetID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Mastershipstate != nil {
		l = m.Mastershipstate.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func sovFabric(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFabric(x uint64) (n int) {
	return sovFabric(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NetworkLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkLayer_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Switch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhyPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhyPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhyPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelNumber", wireType)
			}
			m.ChannelNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthIndicator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthIndicator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ControllerInfo_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &ControllerRole{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &types.Any{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IPAddress_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RTServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RTServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RTServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			m.DeviceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipelines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pipelines = append(m.Pipelines, &P4PipelineInfo{})
			if err := m.Pipelines[len(m.Pipelines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4PipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4PipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4PipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationAction", wireType)
			}
			m.ConfigurationAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationAction |= P4PipelineInfo_ConfigurationAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RTMastershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RTMastershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RTMastershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mastershipstate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mastershipstate == nil {
				m.Mastershipstate = &P4RTMastershipState{}
			}
			if err := m.Mastershipstate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFabric(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFabric
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFabric
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFabric
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFabric        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFabric          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFabric = fmt.Errorf("proto: unexpected end of group")
)
