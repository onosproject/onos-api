// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/topo/fabric.proto

package topo

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NetworkLayer_Type int32

const (
	NetworkLayer_UNDERLAY NetworkLayer_Type = 0
)

var NetworkLayer_Type_name = map[int32]string{
	0: "UNDERLAY",
}

var NetworkLayer_Type_value = map[string]int32{
	"UNDERLAY": 0,
}

func (x NetworkLayer_Type) String() string {
	return proto.EnumName(NetworkLayer_Type_name, int32(x))
}

func (NetworkLayer_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{8, 0}
}

type IPAddress_Type int32

const (
	IPAddress_IPV4 IPAddress_Type = 0
	IPAddress_IPV6 IPAddress_Type = 1
)

var IPAddress_Type_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}

var IPAddress_Type_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x IPAddress_Type) String() string {
	return proto.EnumName(IPAddress_Type_name, int32(x))
}

func (IPAddress_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{11, 0}
}

type ControllerInfo_Type int32

const (
	ControllerInfo_P4RUNTIME ControllerInfo_Type = 0
)

var ControllerInfo_Type_name = map[int32]string{
	0: "P4RUNTIME",
}

var ControllerInfo_Type_value = map[string]int32{
	"P4RUNTIME": 0,
}

func (x ControllerInfo_Type) String() string {
	return proto.EnumName(ControllerInfo_Type_name, int32(x))
}

func (ControllerInfo_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{14, 0}
}

// ConfigurationAction
type P4PipelineInfo_ConfigurationAction int32

const (
	P4PipelineInfo_UNSPECIFIED P4PipelineInfo_ConfigurationAction = 0
	// Verifies that the target can realize the given config. The forwarding state in the target is not modified.
	P4PipelineInfo_VERIFY P4PipelineInfo_ConfigurationAction = 1
	// Saves the config if the P4Runtime target can realize it. The forwarding state in the target is not modified.
	P4PipelineInfo_VERIFY_AND_SAVE P4PipelineInfo_ConfigurationAction = 2
	// Saves and realizes the given config if the P4Runtime target can realize it. The forwarding state in the target is cleared.
	P4PipelineInfo_VERIFY_AND_COMMIT P4PipelineInfo_ConfigurationAction = 3
	// Realizes the last saved, but not yet committed, config.
	// The forwarding state in the target is updated by replaying the write requests to the target device since the last config was saved
	P4PipelineInfo_COMMIT P4PipelineInfo_ConfigurationAction = 4
	// Verifies, saves and realizes the given config, while preserving the forwarding state in the target.
	P4PipelineInfo_RECONCILE_AND_COMMIT P4PipelineInfo_ConfigurationAction = 5
)

var P4PipelineInfo_ConfigurationAction_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "VERIFY",
	2: "VERIFY_AND_SAVE",
	3: "VERIFY_AND_COMMIT",
	4: "COMMIT",
	5: "RECONCILE_AND_COMMIT",
}

var P4PipelineInfo_ConfigurationAction_value = map[string]int32{
	"UNSPECIFIED":          0,
	"VERIFY":               1,
	"VERIFY_AND_SAVE":      2,
	"VERIFY_AND_COMMIT":    3,
	"COMMIT":               4,
	"RECONCILE_AND_COMMIT": 5,
}

func (x P4PipelineInfo_ConfigurationAction) String() string {
	return proto.EnumName(P4PipelineInfo_ConfigurationAction_name, int32(x))
}

func (P4PipelineInfo_ConfigurationAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{17, 0}
}

// Endpoint is a pair of an IP Address or DNS name and a TCP port number
type Endpoint struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{0}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

func (m *Endpoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Endpoint) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// StratumAgents is an aspect carrying information required to interact with a Stratum device agents
type StratumAgents struct {
	P4RTEndpoint *Endpoint `protobuf:"bytes,1,opt,name=p4rt_endpoint,json=p4rtEndpoint,proto3" json:"p4rt_endpoint,omitempty"`
	GNMIEndpoint *Endpoint `protobuf:"bytes,2,opt,name=gnmi_endpoint,json=gnmiEndpoint,proto3" json:"gnmi_endpoint,omitempty"`
	DeviceID     uint64    `protobuf:"varint,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *StratumAgents) Reset()         { *m = StratumAgents{} }
func (m *StratumAgents) String() string { return proto.CompactTextString(m) }
func (*StratumAgents) ProtoMessage()    {}
func (*StratumAgents) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{1}
}
func (m *StratumAgents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StratumAgents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StratumAgents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StratumAgents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StratumAgents.Merge(m, src)
}
func (m *StratumAgents) XXX_Size() int {
	return m.Size()
}
func (m *StratumAgents) XXX_DiscardUnknown() {
	xxx_messageInfo_StratumAgents.DiscardUnknown(m)
}

var xxx_messageInfo_StratumAgents proto.InternalMessageInfo

func (m *StratumAgents) GetP4RTEndpoint() *Endpoint {
	if m != nil {
		return m.P4RTEndpoint
	}
	return nil
}

func (m *StratumAgents) GetGNMIEndpoint() *Endpoint {
	if m != nil {
		return m.GNMIEndpoint
	}
	return nil
}

func (m *StratumAgents) GetDeviceID() uint64 {
	if m != nil {
		return m.DeviceID
	}
	return 0
}

// LocalAgents is an aspect carrying information required to interact with various Stratum device local agents
type LocalAgents struct {
	LinkAgentEndpoint *Endpoint `protobuf:"bytes,1,opt,name=link_agent_endpoint,json=linkAgentEndpoint,proto3" json:"link_agent_endpoint,omitempty"`
	HostAgentEndpoint *Endpoint `protobuf:"bytes,2,opt,name=host_agent_endpoint,json=hostAgentEndpoint,proto3" json:"host_agent_endpoint,omitempty"`
	NATAgentEndpoint  *Endpoint `protobuf:"bytes,3,opt,name=nat_agent_endpoint,json=natAgentEndpoint,proto3" json:"nat_agent_endpoint,omitempty"`
}

func (m *LocalAgents) Reset()         { *m = LocalAgents{} }
func (m *LocalAgents) String() string { return proto.CompactTextString(m) }
func (*LocalAgents) ProtoMessage()    {}
func (*LocalAgents) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{2}
}
func (m *LocalAgents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalAgents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalAgents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalAgents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalAgents.Merge(m, src)
}
func (m *LocalAgents) XXX_Size() int {
	return m.Size()
}
func (m *LocalAgents) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalAgents.DiscardUnknown(m)
}

var xxx_messageInfo_LocalAgents proto.InternalMessageInfo

func (m *LocalAgents) GetLinkAgentEndpoint() *Endpoint {
	if m != nil {
		return m.LinkAgentEndpoint
	}
	return nil
}

func (m *LocalAgents) GetHostAgentEndpoint() *Endpoint {
	if m != nil {
		return m.HostAgentEndpoint
	}
	return nil
}

func (m *LocalAgents) GetNATAgentEndpoint() *Endpoint {
	if m != nil {
		return m.NATAgentEndpoint
	}
	return nil
}

// Port is an aspect carrying the basic port information
type Port struct {
	Index       uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Number      uint32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Enabled     bool   `protobuf:"varint,4,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Speed       string `protobuf:"bytes,5,opt,name=speed,proto3" json:"speed,omitempty"`
	Status      string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	LastChange  uint64 `protobuf:"varint,7,opt,name=last_change,json=lastChange,proto3" json:"last_change,omitempty"`
}

func (m *Port) Reset()         { *m = Port{} }
func (m *Port) String() string { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()    {}
func (*Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{3}
}
func (m *Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Port.Merge(m, src)
}
func (m *Port) XXX_Size() int {
	return m.Size()
}
func (m *Port) XXX_DiscardUnknown() {
	xxx_messageInfo_Port.DiscardUnknown(m)
}

var xxx_messageInfo_Port proto.InternalMessageInfo

func (m *Port) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Port) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Port) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Port) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *Port) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Port) GetLastChange() uint64 {
	if m != nil {
		return m.LastChange
	}
	return 0
}

// Link is an aspect carrying basic link information
type Link struct {
	Status     string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	LastChange uint64 `protobuf:"varint,2,opt,name=last_change,json=lastChange,proto3" json:"last_change,omitempty"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{4}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Link) GetLastChange() uint64 {
	if m != nil {
		return m.LastChange
	}
	return 0
}

// NetworkInterface is an aspect carrying basic network interface information
type NetworkInterface struct {
	MAC string     `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
	IP  *IPAddress `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *NetworkInterface) Reset()         { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()    {}
func (*NetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{5}
}
func (m *NetworkInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterface.Merge(m, src)
}
func (m *NetworkInterface) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterface proto.InternalMessageInfo

func (m *NetworkInterface) GetMAC() string {
	if m != nil {
		return m.MAC
	}
	return ""
}

func (m *NetworkInterface) GetIP() *IPAddress {
	if m != nil {
		return m.IP
	}
	return nil
}

// DEPRECATED: P4RuntimeServer is an entity aspect tracking P4Runtime server contact details
type P4RuntimeServer struct {
	Endpoint *Endpoint `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	DeviceID uint64    `protobuf:"varint,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
}

func (m *P4RuntimeServer) Reset()         { *m = P4RuntimeServer{} }
func (m *P4RuntimeServer) String() string { return proto.CompactTextString(m) }
func (*P4RuntimeServer) ProtoMessage()    {}
func (*P4RuntimeServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{6}
}
func (m *P4RuntimeServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RuntimeServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RuntimeServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RuntimeServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RuntimeServer.Merge(m, src)
}
func (m *P4RuntimeServer) XXX_Size() int {
	return m.Size()
}
func (m *P4RuntimeServer) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RuntimeServer.DiscardUnknown(m)
}

var xxx_messageInfo_P4RuntimeServer proto.InternalMessageInfo

func (m *P4RuntimeServer) GetEndpoint() *Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *P4RuntimeServer) GetDeviceID() uint64 {
	if m != nil {
		return m.DeviceID
	}
	return 0
}

// DEPRECATED: GNMIServer is an entity aspect tracking gNMI server contact details
type GNMIServer struct {
	Endpoint *Endpoint `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
}

func (m *GNMIServer) Reset()         { *m = GNMIServer{} }
func (m *GNMIServer) String() string { return proto.CompactTextString(m) }
func (*GNMIServer) ProtoMessage()    {}
func (*GNMIServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{7}
}
func (m *GNMIServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GNMIServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GNMIServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GNMIServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GNMIServer.Merge(m, src)
}
func (m *GNMIServer) XXX_Size() int {
	return m.Size()
}
func (m *GNMIServer) XXX_DiscardUnknown() {
	xxx_messageInfo_GNMIServer.DiscardUnknown(m)
}

var xxx_messageInfo_GNMIServer proto.InternalMessageInfo

func (m *GNMIServer) GetEndpoint() *Endpoint {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

// NetworkLayer aspect; aspect for a NetworkLayer entity with a specific kind
type NetworkLayer struct {
	Type        NetworkLayer_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.NetworkLayer_Type" json:"type,omitempty"`
	DisplayName string            `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *NetworkLayer) Reset()         { *m = NetworkLayer{} }
func (m *NetworkLayer) String() string { return proto.CompactTextString(m) }
func (*NetworkLayer) ProtoMessage()    {}
func (*NetworkLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{8}
}
func (m *NetworkLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkLayer.Merge(m, src)
}
func (m *NetworkLayer) XXX_Size() int {
	return m.Size()
}
func (m *NetworkLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkLayer.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkLayer proto.InternalMessageInfo

func (m *NetworkLayer) GetType() NetworkLayer_Type {
	if m != nil {
		return m.Type
	}
	return NetworkLayer_UNDERLAY
}

func (m *NetworkLayer) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// Switch aspect; aspect for a SWITCH entity
type Switch struct {
	ModelID            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,4,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Switch) Reset()         { *m = Switch{} }
func (m *Switch) String() string { return proto.CompactTextString(m) }
func (*Switch) ProtoMessage()    {}
func (*Switch) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{9}
}
func (m *Switch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Switch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Switch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Switch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Switch.Merge(m, src)
}
func (m *Switch) XXX_Size() int {
	return m.Size()
}
func (m *Switch) XXX_DiscardUnknown() {
	xxx_messageInfo_Switch.DiscardUnknown(m)
}

var xxx_messageInfo_Switch proto.InternalMessageInfo

func (m *Switch) GetModelID() string {
	if m != nil {
		return m.ModelID
	}
	return ""
}

func (m *Switch) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Switch) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// Router aspect; aspect of a ROUTER entity (Layer 3)
type Router struct {
	ModelId            string    `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	Role               string    `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ManagementEndpoint *Endpoint `protobuf:"bytes,3,opt,name=management_endpoint,json=managementEndpoint,proto3" json:"management_endpoint,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{10}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *Router) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *Router) GetManagementEndpoint() *Endpoint {
	if m != nil {
		return m.ManagementEndpoint
	}
	return nil
}

// IPAddress defines an IPv4 or IPv6 address
type IPAddress struct {
	Type IPAddress_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.IPAddress_Type" json:"type,omitempty"`
	IP   string         `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *IPAddress) Reset()         { *m = IPAddress{} }
func (m *IPAddress) String() string { return proto.CompactTextString(m) }
func (*IPAddress) ProtoMessage()    {}
func (*IPAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{11}
}
func (m *IPAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddress.Merge(m, src)
}
func (m *IPAddress) XXX_Size() int {
	return m.Size()
}
func (m *IPAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddress proto.InternalMessageInfo

func (m *IPAddress) GetType() IPAddress_Type {
	if m != nil {
		return m.Type
	}
	return IPAddress_IPV4
}

func (m *IPAddress) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

// LogicalLink link aspect; represents a link between two physical interfaces
type LogicalLink struct {
	SourceIP      *IPAddress `protobuf:"bytes,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	DestinationIP *IPAddress `protobuf:"bytes,2,opt,name=dest_ip,json=destIp,proto3" json:"dest_ip,omitempty"`
}

func (m *LogicalLink) Reset()         { *m = LogicalLink{} }
func (m *LogicalLink) String() string { return proto.CompactTextString(m) }
func (*LogicalLink) ProtoMessage()    {}
func (*LogicalLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{12}
}
func (m *LogicalLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicalLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalLink.Merge(m, src)
}
func (m *LogicalLink) XXX_Size() int {
	return m.Size()
}
func (m *LogicalLink) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalLink.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalLink proto.InternalMessageInfo

func (m *LogicalLink) GetSourceIP() *IPAddress {
	if m != nil {
		return m.SourceIP
	}
	return nil
}

func (m *LogicalLink) GetDestinationIP() *IPAddress {
	if m != nil {
		return m.DestinationIP
	}
	return nil
}

// PhyInterface  aspect; an aspect to represent a physical switch interface
type PhyInterface struct {
	DisplayName     string     `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	Speed           string     `protobuf:"bytes,2,opt,name=speed,proto3" json:"speed,omitempty"`
	PortNumber      uint32     `protobuf:"varint,3,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	ChannelNumber   uint32     `protobuf:"varint,4,opt,name=channel_number,json=channelNumber,proto3" json:"channel_number,omitempty"`
	TargetID        string     `protobuf:"bytes,5,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	Enabled         bool       `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	HealthIndicator string     `protobuf:"bytes,7,opt,name=health_indicator,json=healthIndicator,proto3" json:"health_indicator,omitempty"`
	IfIndex         uint32     `protobuf:"varint,8,opt,name=if_index,json=ifIndex,proto3" json:"if_index,omitempty"`
	MacAddress      string     `protobuf:"bytes,9,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	AutoNegotiate   bool       `protobuf:"varint,10,opt,name=auto_negotiate,json=autoNegotiate,proto3" json:"auto_negotiate,omitempty"`
	Ip              *IPAddress `protobuf:"bytes,11,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *PhyInterface) Reset()         { *m = PhyInterface{} }
func (m *PhyInterface) String() string { return proto.CompactTextString(m) }
func (*PhyInterface) ProtoMessage()    {}
func (*PhyInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{13}
}
func (m *PhyInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhyInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhyInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhyInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhyInterface.Merge(m, src)
}
func (m *PhyInterface) XXX_Size() int {
	return m.Size()
}
func (m *PhyInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_PhyInterface.DiscardUnknown(m)
}

var xxx_messageInfo_PhyInterface proto.InternalMessageInfo

func (m *PhyInterface) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PhyInterface) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *PhyInterface) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *PhyInterface) GetChannelNumber() uint32 {
	if m != nil {
		return m.ChannelNumber
	}
	return 0
}

func (m *PhyInterface) GetTargetID() string {
	if m != nil {
		return m.TargetID
	}
	return ""
}

func (m *PhyInterface) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *PhyInterface) GetHealthIndicator() string {
	if m != nil {
		return m.HealthIndicator
	}
	return ""
}

func (m *PhyInterface) GetIfIndex() uint32 {
	if m != nil {
		return m.IfIndex
	}
	return 0
}

func (m *PhyInterface) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *PhyInterface) GetAutoNegotiate() bool {
	if m != nil {
		return m.AutoNegotiate
	}
	return false
}

func (m *PhyInterface) GetIp() *IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

// Controller aspect; represents an instance of the controller deployment
type ControllerInfo struct {
	Type            ControllerInfo_Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.topo.ControllerInfo_Type" json:"type,omitempty"`
	Role            *ControllerRole     `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	ControlEndpoint *Endpoint           `protobuf:"bytes,3,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Username        string              `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password        string              `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *ControllerInfo) Reset()         { *m = ControllerInfo{} }
func (m *ControllerInfo) String() string { return proto.CompactTextString(m) }
func (*ControllerInfo) ProtoMessage()    {}
func (*ControllerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{14}
}
func (m *ControllerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControllerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControllerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControllerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerInfo.Merge(m, src)
}
func (m *ControllerInfo) XXX_Size() int {
	return m.Size()
}
func (m *ControllerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerInfo proto.InternalMessageInfo

func (m *ControllerInfo) GetType() ControllerInfo_Type {
	if m != nil {
		return m.Type
	}
	return ControllerInfo_P4RUNTIME
}

func (m *ControllerInfo) GetRole() *ControllerRole {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *ControllerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *ControllerInfo) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ControllerInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type ControllerRole struct {
	Name   string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Config *types.Any `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *ControllerRole) Reset()         { *m = ControllerRole{} }
func (m *ControllerRole) String() string { return proto.CompactTextString(m) }
func (*ControllerRole) ProtoMessage()    {}
func (*ControllerRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{15}
}
func (m *ControllerRole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControllerRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControllerRole.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControllerRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerRole.Merge(m, src)
}
func (m *ControllerRole) XXX_Size() int {
	return m.Size()
}
func (m *ControllerRole) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerRole.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerRole proto.InternalMessageInfo

func (m *ControllerRole) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ControllerRole) GetConfig() *types.Any {
	if m != nil {
		return m.Config
	}
	return nil
}

// DEPRECATED: P4RTServerInfo aspect; specifies the control end point in a programmable device
type P4RTServerInfo struct {
	ControlEndpoint *Endpoint         `protobuf:"bytes,1,opt,name=control_endpoint,json=controlEndpoint,proto3" json:"control_endpoint,omitempty"`
	Timeout         *time.Duration    `protobuf:"bytes,2,opt,name=timeout,proto3,stdduration" json:"timeout,omitempty"`
	DeviceID        uint64            `protobuf:"varint,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	Pipelines       []*P4PipelineInfo `protobuf:"bytes,4,rep,name=pipelines,proto3" json:"pipelines,omitempty"`
}

func (m *P4RTServerInfo) Reset()         { *m = P4RTServerInfo{} }
func (m *P4RTServerInfo) String() string { return proto.CompactTextString(m) }
func (*P4RTServerInfo) ProtoMessage()    {}
func (*P4RTServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{16}
}
func (m *P4RTServerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RTServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RTServerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RTServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RTServerInfo.Merge(m, src)
}
func (m *P4RTServerInfo) XXX_Size() int {
	return m.Size()
}
func (m *P4RTServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RTServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_P4RTServerInfo proto.InternalMessageInfo

func (m *P4RTServerInfo) GetControlEndpoint() *Endpoint {
	if m != nil {
		return m.ControlEndpoint
	}
	return nil
}

func (m *P4RTServerInfo) GetTimeout() *time.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *P4RTServerInfo) GetDeviceID() uint64 {
	if m != nil {
		return m.DeviceID
	}
	return 0
}

func (m *P4RTServerInfo) GetPipelines() []*P4PipelineInfo {
	if m != nil {
		return m.Pipelines
	}
	return nil
}

// DEPRECATED: P4PipelineInfo p4 pipeline information
type P4PipelineInfo struct {
	Name                string                             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version             string                             `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Architecture        string                             `protobuf:"bytes,3,opt,name=architecture,proto3" json:"architecture,omitempty"`
	ConfigurationAction P4PipelineInfo_ConfigurationAction `protobuf:"varint,4,opt,name=configuration_action,json=configurationAction,proto3,enum=onos.topo.P4PipelineInfo_ConfigurationAction" json:"configuration_action,omitempty"`
}

func (m *P4PipelineInfo) Reset()         { *m = P4PipelineInfo{} }
func (m *P4PipelineInfo) String() string { return proto.CompactTextString(m) }
func (*P4PipelineInfo) ProtoMessage()    {}
func (*P4PipelineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{17}
}
func (m *P4PipelineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4PipelineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4PipelineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4PipelineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4PipelineInfo.Merge(m, src)
}
func (m *P4PipelineInfo) XXX_Size() int {
	return m.Size()
}
func (m *P4PipelineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_P4PipelineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_P4PipelineInfo proto.InternalMessageInfo

func (m *P4PipelineInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *P4PipelineInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *P4PipelineInfo) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *P4PipelineInfo) GetConfigurationAction() P4PipelineInfo_ConfigurationAction {
	if m != nil {
		return m.ConfigurationAction
	}
	return P4PipelineInfo_UNSPECIFIED
}

// DEPRECATED: P4RTMastershipState mastership state for the P4runtime targets
type P4RTMastershipState struct {
	Term         uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	ConnectionID string `protobuf:"bytes,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Role         string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *P4RTMastershipState) Reset()         { *m = P4RTMastershipState{} }
func (m *P4RTMastershipState) String() string { return proto.CompactTextString(m) }
func (*P4RTMastershipState) ProtoMessage()    {}
func (*P4RTMastershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{18}
}
func (m *P4RTMastershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P4RTMastershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P4RTMastershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P4RTMastershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P4RTMastershipState.Merge(m, src)
}
func (m *P4RTMastershipState) XXX_Size() int {
	return m.Size()
}
func (m *P4RTMastershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_P4RTMastershipState.DiscardUnknown(m)
}

var xxx_messageInfo_P4RTMastershipState proto.InternalMessageInfo

func (m *P4RTMastershipState) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *P4RTMastershipState) GetConnectionID() string {
	if m != nil {
		return m.ConnectionID
	}
	return ""
}

func (m *P4RTMastershipState) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// DEPRECATED: Service service entity which will be used to store mastership state for an application
type Service struct {
	TargetID        string               `protobuf:"bytes,1,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	Mastershipstate *P4RTMastershipState `protobuf:"bytes,2,opt,name=mastershipstate,proto3" json:"mastershipstate,omitempty"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_705cdab724be9631, []int{19}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetTargetID() string {
	if m != nil {
		return m.TargetID
	}
	return ""
}

func (m *Service) GetMastershipstate() *P4RTMastershipState {
	if m != nil {
		return m.Mastershipstate
	}
	return nil
}

func init() {
	proto.RegisterEnum("onos.topo.NetworkLayer_Type", NetworkLayer_Type_name, NetworkLayer_Type_value)
	proto.RegisterEnum("onos.topo.IPAddress_Type", IPAddress_Type_name, IPAddress_Type_value)
	proto.RegisterEnum("onos.topo.ControllerInfo_Type", ControllerInfo_Type_name, ControllerInfo_Type_value)
	proto.RegisterEnum("onos.topo.P4PipelineInfo_ConfigurationAction", P4PipelineInfo_ConfigurationAction_name, P4PipelineInfo_ConfigurationAction_value)
	proto.RegisterType((*Endpoint)(nil), "onos.topo.Endpoint")
	proto.RegisterType((*StratumAgents)(nil), "onos.topo.StratumAgents")
	proto.RegisterType((*LocalAgents)(nil), "onos.topo.LocalAgents")
	proto.RegisterType((*Port)(nil), "onos.topo.Port")
	proto.RegisterType((*Link)(nil), "onos.topo.Link")
	proto.RegisterType((*NetworkInterface)(nil), "onos.topo.NetworkInterface")
	proto.RegisterType((*P4RuntimeServer)(nil), "onos.topo.P4RuntimeServer")
	proto.RegisterType((*GNMIServer)(nil), "onos.topo.gNMIServer")
	proto.RegisterType((*NetworkLayer)(nil), "onos.topo.NetworkLayer")
	proto.RegisterType((*Switch)(nil), "onos.topo.Switch")
	proto.RegisterType((*Router)(nil), "onos.topo.Router")
	proto.RegisterType((*IPAddress)(nil), "onos.topo.IPAddress")
	proto.RegisterType((*LogicalLink)(nil), "onos.topo.LogicalLink")
	proto.RegisterType((*PhyInterface)(nil), "onos.topo.PhyInterface")
	proto.RegisterType((*ControllerInfo)(nil), "onos.topo.ControllerInfo")
	proto.RegisterType((*ControllerRole)(nil), "onos.topo.ControllerRole")
	proto.RegisterType((*P4RTServerInfo)(nil), "onos.topo.P4RTServerInfo")
	proto.RegisterType((*P4PipelineInfo)(nil), "onos.topo.P4PipelineInfo")
	proto.RegisterType((*P4RTMastershipState)(nil), "onos.topo.P4RTMastershipState")
	proto.RegisterType((*Service)(nil), "onos.topo.Service")
}

func init() { proto.RegisterFile("onos/topo/fabric.proto", fileDescriptor_705cdab724be9631) }

var fileDescriptor_705cdab724be9631 = []byte{
	// 1437 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4b, 0x6f, 0x1b, 0x47,
	0x12, 0xd6, 0x90, 0x63, 0x3e, 0x8a, 0xa4, 0x44, 0x37, 0x65, 0x83, 0x12, 0x16, 0xa4, 0x76, 0xb0,
	0x5e, 0xc8, 0x80, 0x2d, 0x2d, 0xb4, 0xda, 0xd7, 0x61, 0xd7, 0x4b, 0x91, 0x74, 0x32, 0x86, 0x48,
	0x13, 0x2d, 0xd9, 0x81, 0x91, 0x03, 0xd3, 0x9a, 0x69, 0x91, 0x03, 0x73, 0xba, 0x07, 0x33, 0x4d,
	0x3b, 0x3c, 0x24, 0x87, 0x20, 0x87, 0x20, 0x27, 0x1f, 0xf3, 0x73, 0x72, 0x0c, 0x90, 0x8b, 0x91,
	0x53, 0x4e, 0x4a, 0x40, 0xff, 0x80, 0xe4, 0x27, 0x04, 0xdd, 0xf3, 0xe0, 0x50, 0x0f, 0xdb, 0xf2,
	0x69, 0xba, 0xbe, 0xae, 0xaa, 0xae, 0xaa, 0xfe, 0xaa, 0x7a, 0xe0, 0x36, 0x67, 0x3c, 0xd8, 0x15,
	0xdc, 0xe3, 0xbb, 0xa7, 0xe4, 0xc4, 0x77, 0xac, 0x1d, 0xcf, 0xe7, 0x82, 0xa3, 0xa2, 0xc4, 0x77,
	0x24, 0xbe, 0xb9, 0x3e, 0xe2, 0x23, 0xae, 0xd0, 0x5d, 0xb9, 0x0a, 0x15, 0x36, 0x1b, 0x23, 0xce,
	0x47, 0x13, 0xba, 0xab, 0xa4, 0x93, 0xe9, 0xe9, 0xae, 0x3d, 0xf5, 0x89, 0x70, 0x38, 0x8b, 0xf6,
	0x37, 0xce, 0xef, 0x13, 0x36, 0x0b, 0xb7, 0x8c, 0x7f, 0x43, 0xa1, 0xcb, 0x6c, 0x8f, 0x3b, 0x4c,
	0xa0, 0x3a, 0xe4, 0x89, 0x6d, 0xfb, 0x34, 0x08, 0xea, 0xda, 0x96, 0xb6, 0x5d, 0xc4, 0xb1, 0x88,
	0x10, 0xe8, 0x1e, 0xf7, 0x45, 0x3d, 0xb3, 0xa5, 0x6d, 0x57, 0xb0, 0x5a, 0x1b, 0x3f, 0x69, 0x50,
	0x39, 0x12, 0x3e, 0x11, 0x53, 0xb7, 0x35, 0xa2, 0x4c, 0x04, 0xe8, 0x11, 0x54, 0xbc, 0x7d, 0x5f,
	0x0c, 0x69, 0xe4, 0x50, 0x79, 0x29, 0xed, 0xd5, 0x76, 0x92, 0xf8, 0x77, 0xe2, 0xb3, 0x0e, 0xaa,
	0xf3, 0xb3, 0x66, 0x79, 0xb0, 0x8f, 0x8f, 0x63, 0x04, 0x97, 0xa5, 0x6d, 0x12, 0xcb, 0x23, 0xa8,
	0x8c, 0x98, 0xeb, 0x2c, 0x7c, 0x65, 0xde, 0xe1, 0xeb, 0xa3, 0x7e, 0xcf, 0x5c, 0xf8, 0x92, 0xb6,
	0x89, 0xaf, 0xbb, 0x50, 0xb4, 0xe9, 0x0b, 0xc7, 0xa2, 0x43, 0xc7, 0xae, 0x67, 0xb7, 0xb4, 0x6d,
	0xfd, 0xa0, 0x3c, 0x3f, 0x6b, 0x16, 0x3a, 0x0a, 0x34, 0x3b, 0xb8, 0x10, 0x6e, 0x9b, 0xb6, 0xf1,
	0xbb, 0x06, 0xa5, 0x43, 0x6e, 0x91, 0x49, 0x94, 0x52, 0x1b, 0x6a, 0x13, 0x87, 0x3d, 0x1f, 0x12,
	0x29, 0xbe, 0x4f, 0x62, 0xf8, 0xa6, 0xd4, 0x57, 0xd6, 0xc9, 0xf9, 0x6d, 0xa8, 0x8d, 0x79, 0x20,
	0xce, 0x3b, 0xc9, 0xbc, 0xc5, 0x89, 0xd4, 0x5f, 0x76, 0xf2, 0x09, 0x20, 0x46, 0x2e, 0xf8, 0xc8,
	0x5e, 0x5d, 0x95, 0xf5, 0xf9, 0x59, 0xb3, 0xda, 0x6f, 0x1d, 0x2f, 0xb9, 0xc1, 0x55, 0x46, 0x96,
	0x1d, 0x1b, 0xdf, 0x6b, 0xa0, 0x0f, 0xb8, 0x2f, 0xd0, 0x3a, 0xdc, 0x70, 0x98, 0x4d, 0x3f, 0x57,
	0xd9, 0x55, 0x70, 0x28, 0xa0, 0xdb, 0x90, 0x63, 0x53, 0xf7, 0x84, 0xfa, 0xd1, 0xe5, 0x47, 0x12,
	0xfa, 0x33, 0x94, 0x6d, 0x27, 0xf0, 0x26, 0x64, 0x36, 0x64, 0xc4, 0xa5, 0x2a, 0x92, 0x22, 0x2e,
	0x45, 0x58, 0x9f, 0xb8, 0x54, 0xf2, 0x89, 0x32, 0x72, 0x32, 0xa1, 0x76, 0x5d, 0xdf, 0xd2, 0xb6,
	0x0b, 0x38, 0x16, 0xe5, 0x51, 0x81, 0x47, 0xa9, 0x5d, 0xbf, 0xa1, 0xac, 0x42, 0x41, 0x1e, 0x15,
	0x08, 0x22, 0xa6, 0x41, 0x3d, 0xa7, 0xe0, 0x48, 0x42, 0x4d, 0x28, 0x4d, 0x48, 0x20, 0x86, 0xd6,
	0x98, 0xb0, 0x11, 0xad, 0xe7, 0xe5, 0x0d, 0x62, 0x90, 0x50, 0x5b, 0x21, 0xc6, 0x03, 0xd0, 0x0f,
	0x1d, 0xf6, 0x3c, 0xe5, 0x40, 0x7b, 0x9b, 0x83, 0xcc, 0x05, 0x07, 0x9f, 0x42, 0xb5, 0x4f, 0xc5,
	0x4b, 0xee, 0x3f, 0x37, 0x99, 0xa0, 0xfe, 0x29, 0xb1, 0x28, 0xda, 0x80, 0xac, 0x4b, 0xac, 0xd0,
	0xd3, 0x41, 0x7e, 0x7e, 0xd6, 0xcc, 0xf6, 0x5a, 0x6d, 0x2c, 0x31, 0x74, 0x0f, 0x32, 0x8e, 0x17,
	0xdd, 0xdf, 0x7a, 0xaa, 0xf6, 0xe6, 0xa0, 0x15, 0x36, 0xcc, 0x41, 0x6e, 0x7e, 0xd6, 0xcc, 0x98,
	0x03, 0x9c, 0x71, 0x3c, 0xc3, 0x85, 0xb5, 0xc1, 0x3e, 0x9e, 0x32, 0xe1, 0xb8, 0xf4, 0x88, 0xfa,
	0x2f, 0xa8, 0x8f, 0x76, 0xa1, 0xf0, 0x3e, 0x5c, 0x4a, 0x94, 0xae, 0x43, 0xe1, 0xff, 0x02, 0x8c,
	0xfa, 0x3d, 0xf3, 0x03, 0x4f, 0x32, 0x66, 0x50, 0x8e, 0x4a, 0x71, 0x48, 0x66, 0xd4, 0x47, 0x7f,
	0x03, 0x5d, 0xcc, 0x3c, 0xaa, 0x8c, 0x57, 0xf7, 0xfe, 0x94, 0x32, 0x4e, 0xab, 0xed, 0x1c, 0xcf,
	0x3c, 0x8a, 0x95, 0xe6, 0x05, 0x66, 0x64, 0x2e, 0x30, 0xc3, 0x58, 0x07, 0x5d, 0x1a, 0xa0, 0x32,
	0x14, 0x9e, 0xf4, 0x3b, 0x5d, 0x7c, 0xd8, 0x7a, 0x56, 0x5d, 0x31, 0xbe, 0xd5, 0x20, 0x77, 0xf4,
	0xd2, 0x11, 0xd6, 0x18, 0xfd, 0x15, 0x0a, 0x2e, 0xb7, 0xe9, 0x44, 0xa6, 0x1b, 0xde, 0x40, 0x69,
	0x7e, 0xd6, 0xcc, 0xf7, 0x24, 0x66, 0x76, 0x70, 0x5e, 0x6d, 0x9a, 0xb6, 0x1c, 0x4c, 0x3e, 0x9f,
	0xc4, 0x67, 0xa8, 0x35, 0xea, 0x40, 0xcd, 0x25, 0x8c, 0x8c, 0xa8, 0xbb, 0xd4, 0x2a, 0xfa, 0xd5,
	0xd9, 0xa3, 0x85, 0x7e, 0xd2, 0x16, 0x5f, 0x40, 0x0e, 0xf3, 0xa9, 0xa0, 0x3e, 0xda, 0x38, 0x1f,
	0xcb, 0x07, 0x1d, 0x9f, 0xbd, 0xde, 0xf1, 0x0c, 0x8a, 0x09, 0x9b, 0xd0, 0xfd, 0xa5, 0x3b, 0xd8,
	0xb8, 0x8c, 0x71, 0xe9, 0x0b, 0xb8, 0x9d, 0xd0, 0xb3, 0xb8, 0x44, 0xc4, 0xcd, 0xa8, 0xea, 0x05,
	0xd0, 0xcd, 0xc1, 0xd3, 0xfd, 0xea, 0x4a, 0xb4, 0xfa, 0x67, 0x55, 0x33, 0x5e, 0xa9, 0xc1, 0x37,
	0x72, 0x2c, 0x32, 0x51, 0xad, 0xf4, 0x00, 0x8a, 0x01, 0x9f, 0xfa, 0x92, 0x70, 0x5e, 0x44, 0x9c,
	0xcb, 0x99, 0xae, 0x68, 0x78, 0xa4, 0x54, 0xcd, 0x01, 0x2e, 0x84, 0x46, 0xa6, 0x87, 0xfe, 0x0f,
	0x79, 0x9b, 0x06, 0x62, 0xf8, 0x8e, 0x46, 0xb9, 0x39, 0x3f, 0x6b, 0x56, 0x3a, 0x34, 0x10, 0x0e,
	0x53, 0x2f, 0x96, 0x39, 0xc0, 0x39, 0x69, 0x67, 0x7a, 0xc6, 0x37, 0x59, 0x28, 0x0f, 0xc6, 0xb3,
	0x45, 0x47, 0x9e, 0x27, 0x96, 0x76, 0x71, 0xe4, 0x24, 0x83, 0x25, 0x93, 0x1e, 0x2c, 0x4d, 0x28,
	0xc9, 0x27, 0x6b, 0x18, 0x0d, 0xb2, 0xac, 0x1a, 0x64, 0x20, 0xa1, 0x7e, 0x38, 0xcc, 0xee, 0xc0,
	0xaa, 0x9c, 0x0d, 0x8c, 0x4e, 0x62, 0x1d, 0x5d, 0xe9, 0x54, 0x22, 0x34, 0x52, 0xbb, 0x0b, 0x45,
	0x41, 0xfc, 0x11, 0x15, 0x92, 0x0a, 0x6a, 0x74, 0x85, 0xe9, 0x1f, 0x2b, 0x50, 0x76, 0x61, 0xb8,
	0x6d, 0xda, 0xe9, 0xd9, 0x97, 0x5b, 0x9e, 0x7d, 0x77, 0xa1, 0x3a, 0xa6, 0x64, 0x22, 0xc6, 0x43,
	0x87, 0xd9, 0x8e, 0x45, 0x04, 0xf7, 0xd5, 0x48, 0x2b, 0xe2, 0xb5, 0x10, 0x37, 0x63, 0x58, 0x32,
	0xcf, 0x39, 0x1d, 0x86, 0x43, 0xb9, 0xa0, 0x02, 0xca, 0x3b, 0xa7, 0xa6, 0x1a, 0xcb, 0x4d, 0x28,
	0xb9, 0xc4, 0x1a, 0xc6, 0xef, 0x75, 0x51, 0x39, 0x00, 0x97, 0x58, 0x31, 0x67, 0xee, 0xc0, 0x2a,
	0x99, 0x0a, 0x3e, 0x64, 0x74, 0xc4, 0x85, 0x43, 0x04, 0xad, 0x83, 0x8a, 0xa3, 0x22, 0xd1, 0x7e,
	0x0c, 0xa2, 0xbf, 0x28, 0xae, 0x94, 0xae, 0xbe, 0x21, 0xc5, 0x9c, 0xaf, 0x32, 0xb0, 0xda, 0xe6,
	0x4c, 0xf8, 0x7c, 0x32, 0xa1, 0xbe, 0xc9, 0x4e, 0x39, 0xda, 0x5b, 0xe2, 0x64, 0x23, 0x65, 0xba,
	0xac, 0x98, 0x26, 0xe6, 0xfd, 0x54, 0xbb, 0x94, 0x96, 0x78, 0xbc, 0xb0, 0xc1, 0x7c, 0x42, 0xa3,
	0x4e, 0xfa, 0x1f, 0x54, 0xad, 0x10, 0x7f, 0xaf, 0x36, 0x5a, 0x8b, 0x94, 0x93, 0x27, 0x73, 0x13,
	0x0a, 0xd3, 0x80, 0xfa, 0x8a, 0x2b, 0xba, 0x2a, 0x50, 0x22, 0xcb, 0x3d, 0x8f, 0x04, 0xc1, 0x4b,
	0xee, 0xc7, 0x8f, 0x50, 0x22, 0x1b, 0xb7, 0xa2, 0x3e, 0xa9, 0x40, 0x71, 0xb0, 0x8f, 0x9f, 0xf4,
	0x8f, 0xcd, 0x5e, 0xb7, 0xba, 0x62, 0xe0, 0x74, 0x0d, 0x64, 0x98, 0xb2, 0xfd, 0x53, 0x44, 0x54,
	0x6b, 0x74, 0x0f, 0x72, 0x16, 0x67, 0xa7, 0xce, 0x28, 0xa1, 0x7d, 0xf8, 0xf3, 0xb5, 0x13, 0xff,
	0x7c, 0xed, 0xb4, 0xd8, 0x0c, 0x47, 0x3a, 0xc6, 0x6f, 0x1a, 0xac, 0xca, 0xbf, 0xa0, 0x70, 0x5a,
	0xab, 0xc2, 0x5e, 0x96, 0xb5, 0x76, 0x8d, 0xac, 0xff, 0x03, 0x79, 0xf9, 0xd2, 0xf0, 0xa9, 0x48,
	0xea, 0x7c, 0x3e, 0x82, 0x4e, 0xf4, 0x7b, 0x78, 0xa0, 0x7f, 0xf7, 0x4b, 0x53, 0xc3, 0xb1, 0xfe,
	0x35, 0x5e, 0x19, 0xf4, 0x2f, 0x28, 0x7a, 0x8e, 0x47, 0x27, 0x0e, 0xa3, 0x41, 0x5d, 0xdf, 0xca,
	0x9e, 0xbb, 0xcf, 0xc1, 0xfe, 0x20, 0xda, 0x95, 0x39, 0xe1, 0x85, 0xae, 0xf1, 0x63, 0x46, 0x66,
	0x9c, 0xde, 0xbd, 0xb4, 0x8c, 0x75, 0xc8, 0xbf, 0xa0, 0x7e, 0xe0, 0x70, 0x16, 0xb5, 0x72, 0x2c,
	0x22, 0x03, 0xca, 0xc4, 0xb7, 0xc6, 0x8e, 0xa0, 0x96, 0x98, 0xfa, 0xf1, 0x8f, 0xc7, 0x12, 0x86,
	0x3e, 0x83, 0xf5, 0xb0, 0xc0, 0x51, 0xa2, 0x43, 0x62, 0xc9, 0x8f, 0x62, 0xc1, 0xea, 0xde, 0xfd,
	0x2b, 0x03, 0x95, 0x3c, 0x5c, 0x58, 0xb5, 0x94, 0x11, 0xae, 0x59, 0x17, 0x41, 0xe3, 0x6b, 0x0d,
	0x6a, 0x97, 0x28, 0xa3, 0x35, 0x28, 0x3d, 0xe9, 0x1f, 0x0d, 0xba, 0x6d, 0xf3, 0xa1, 0xd9, 0xed,
	0x54, 0x57, 0x10, 0x40, 0xee, 0x69, 0x17, 0x9b, 0x0f, 0x9f, 0x55, 0x35, 0x54, 0x83, 0xb5, 0x70,
	0x3d, 0x6c, 0xf5, 0x3b, 0xc3, 0xa3, 0xd6, 0xd3, 0x6e, 0x35, 0x83, 0x6e, 0xc1, 0xcd, 0x14, 0xd8,
	0x7e, 0xdc, 0xeb, 0x99, 0xc7, 0xd5, 0xac, 0xb4, 0x8b, 0xd6, 0x3a, 0xaa, 0xc3, 0x3a, 0xee, 0xb6,
	0x1f, 0xf7, 0xdb, 0xe6, 0x61, 0x37, 0xad, 0x75, 0xc3, 0x10, 0x50, 0x93, 0xf4, 0xe9, 0x91, 0x40,
	0x50, 0x3f, 0x18, 0x3b, 0xde, 0x91, 0x90, 0x5d, 0x8d, 0x40, 0x17, 0xd4, 0x77, 0x55, 0x45, 0x75,
	0xac, 0xd6, 0xe8, 0x1f, 0x50, 0xb1, 0x38, 0x63, 0x54, 0xc5, 0x29, 0x2f, 0x38, 0x7c, 0x20, 0xd4,
	0xcf, 0x73, 0x3b, 0xd9, 0x30, 0x3b, 0xb8, 0xbc, 0x50, 0x4b, 0x3d, 0x71, 0xd9, 0xc5, 0x13, 0x67,
	0x7c, 0x09, 0x79, 0x49, 0x58, 0xc7, 0xa2, 0xcb, 0x23, 0x51, 0x7b, 0xeb, 0x48, 0xfc, 0x18, 0xd6,
	0xdc, 0x24, 0x4e, 0xf9, 0x67, 0x16, 0x0f, 0x82, 0xc6, 0xd2, 0x7d, 0x5c, 0xc8, 0x06, 0x9f, 0x37,
	0x3b, 0xa8, 0xff, 0x30, 0x6f, 0x68, 0xaf, 0xe7, 0x0d, 0xed, 0xd7, 0x79, 0x43, 0x7b, 0xf5, 0xa6,
	0xb1, 0xf2, 0xfa, 0x4d, 0x63, 0xe5, 0xe7, 0x37, 0x8d, 0x95, 0x93, 0x9c, 0xe2, 0xf8, 0xdf, 0xff,
	0x08, 0x00, 0x00, 0xff, 0xff, 0x7b, 0x89, 0x55, 0x7b, 0x4b, 0x0d, 0x00, 0x00,
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StratumAgents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StratumAgents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StratumAgents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceID != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.DeviceID))
		i--
		dAtA[i] = 0x18
	}
	if m.GNMIEndpoint != nil {
		{
			size, err := m.GNMIEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.P4RTEndpoint != nil {
		{
			size, err := m.P4RTEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalAgents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalAgents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalAgents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NATAgentEndpoint != nil {
		{
			size, err := m.NATAgentEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.HostAgentEndpoint != nil {
		{
			size, err := m.HostAgentEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LinkAgentEndpoint != nil {
		{
			size, err := m.LinkAgentEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastChange != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.LastChange))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Speed) > 0 {
		i -= len(m.Speed)
		copy(dAtA[i:], m.Speed)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Speed)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastChange != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.LastChange))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IP != nil {
		{
			size, err := m.IP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MAC) > 0 {
		i -= len(m.MAC)
		copy(dAtA[i:], m.MAC)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.MAC)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P4RuntimeServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RuntimeServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RuntimeServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeviceID != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.DeviceID))
		i--
		dAtA[i] = 0x18
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GNMIServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GNMIServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GNMIServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Switch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelID) > 0 {
		i -= len(m.ModelID)
		copy(dAtA[i:], m.ModelID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManagementEndpoint != nil {
		{
			size, err := m.ManagementEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogicalLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DestinationIP != nil {
		{
			size, err := m.DestinationIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SourceIP != nil {
		{
			size, err := m.SourceIP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhyInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhyInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhyInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.AutoNegotiate {
		i--
		if m.AutoNegotiate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IfIndex != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.IfIndex))
		i--
		dAtA[i] = 0x40
	}
	if len(m.HealthIndicator) > 0 {
		i -= len(m.HealthIndicator)
		copy(dAtA[i:], m.HealthIndicator)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.HealthIndicator)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.TargetID) > 0 {
		i -= len(m.TargetID)
		copy(dAtA[i:], m.TargetID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.TargetID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ChannelNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.ChannelNumber))
		i--
		dAtA[i] = 0x20
	}
	if m.PortNumber != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.PortNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Speed) > 0 {
		i -= len(m.Speed)
		copy(dAtA[i:], m.Speed)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Speed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ControllerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControllerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControllerRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControllerRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P4RTServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RTServerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RTServerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pipelines) > 0 {
		for iNdEx := len(m.Pipelines) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pipelines[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFabric(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DeviceID != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.DeviceID))
		i--
		dAtA[i] = 0x18
	}
	if m.Timeout != nil {
		n17, err17 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.Timeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout):])
		if err17 != nil {
			return 0, err17
		}
		i -= n17
		i = encodeVarintFabric(dAtA, i, uint64(n17))
		i--
		dAtA[i] = 0x12
	}
	if m.ControlEndpoint != nil {
		{
			size, err := m.ControlEndpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P4PipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4PipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4PipelineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigurationAction != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.ConfigurationAction))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P4RTMastershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P4RTMastershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P4RTMastershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConnectionID) > 0 {
		i -= len(m.ConnectionID)
		copy(dAtA[i:], m.ConnectionID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.ConnectionID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Term != 0 {
		i = encodeVarintFabric(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mastershipstate != nil {
		{
			size, err := m.Mastershipstate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFabric(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TargetID) > 0 {
		i -= len(m.TargetID)
		copy(dAtA[i:], m.TargetID)
		i = encodeVarintFabric(dAtA, i, uint64(len(m.TargetID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFabric(dAtA []byte, offset int, v uint64) int {
	offset -= sovFabric(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovFabric(uint64(m.Port))
	}
	return n
}

func (m *StratumAgents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P4RTEndpoint != nil {
		l = m.P4RTEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.GNMIEndpoint != nil {
		l = m.GNMIEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.DeviceID != 0 {
		n += 1 + sovFabric(uint64(m.DeviceID))
	}
	return n
}

func (m *LocalAgents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LinkAgentEndpoint != nil {
		l = m.LinkAgentEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.HostAgentEndpoint != nil {
		l = m.HostAgentEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.NATAgentEndpoint != nil {
		l = m.NATAgentEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovFabric(uint64(m.Index))
	}
	if m.Number != 0 {
		n += 1 + sovFabric(uint64(m.Number))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.LastChange != 0 {
		n += 1 + sovFabric(uint64(m.LastChange))
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.LastChange != 0 {
		n += 1 + sovFabric(uint64(m.LastChange))
	}
	return n
}

func (m *NetworkInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MAC)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.IP != nil {
		l = m.IP.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *P4RuntimeServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.DeviceID != 0 {
		n += 1 + sovFabric(uint64(m.DeviceID))
	}
	return n
}

func (m *GNMIServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *NetworkLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ManagementEndpoint != nil {
		l = m.ManagementEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *IPAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *LogicalLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceIP != nil {
		l = m.SourceIP.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.DestinationIP != nil {
		l = m.DestinationIP.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *PhyInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.PortNumber != 0 {
		n += 1 + sovFabric(uint64(m.PortNumber))
	}
	if m.ChannelNumber != 0 {
		n += 1 + sovFabric(uint64(m.ChannelNumber))
	}
	l = len(m.TargetID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.HealthIndicator)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.IfIndex != 0 {
		n += 1 + sovFabric(uint64(m.IfIndex))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.AutoNegotiate {
		n += 2
	}
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *ControllerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFabric(uint64(m.Type))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *ControllerRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *P4RTServerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ControlEndpoint != nil {
		l = m.ControlEndpoint.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Timeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.Timeout)
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.DeviceID != 0 {
		n += 1 + sovFabric(uint64(m.DeviceID))
	}
	if len(m.Pipelines) > 0 {
		for _, e := range m.Pipelines {
			l = e.Size()
			n += 1 + l + sovFabric(uint64(l))
		}
	}
	return n
}

func (m *P4PipelineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.ConfigurationAction != 0 {
		n += 1 + sovFabric(uint64(m.ConfigurationAction))
	}
	return n
}

func (m *P4RTMastershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovFabric(uint64(m.Term))
	}
	l = len(m.ConnectionID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TargetID)
	if l > 0 {
		n += 1 + l + sovFabric(uint64(l))
	}
	if m.Mastershipstate != nil {
		l = m.Mastershipstate.Size()
		n += 1 + l + sovFabric(uint64(l))
	}
	return n
}

func sovFabric(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFabric(x uint64) (n int) {
	return sovFabric(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StratumAgents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StratumAgents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StratumAgents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P4RTEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P4RTEndpoint == nil {
				m.P4RTEndpoint = &Endpoint{}
			}
			if err := m.P4RTEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GNMIEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GNMIEndpoint == nil {
				m.GNMIEndpoint = &Endpoint{}
			}
			if err := m.GNMIEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			m.DeviceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalAgents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalAgents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalAgents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkAgentEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkAgentEndpoint == nil {
				m.LinkAgentEndpoint = &Endpoint{}
			}
			if err := m.LinkAgentEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAgentEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostAgentEndpoint == nil {
				m.HostAgentEndpoint = &Endpoint{}
			}
			if err := m.HostAgentEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATAgentEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NATAgentEndpoint == nil {
				m.NATAgentEndpoint = &Endpoint{}
			}
			if err := m.NATAgentEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChange", wireType)
			}
			m.LastChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChange |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChange", wireType)
			}
			m.LastChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChange |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IP == nil {
				m.IP = &IPAddress{}
			}
			if err := m.IP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RuntimeServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RuntimeServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RuntimeServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &Endpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			m.DeviceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GNMIServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: gNMIServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: gNMIServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &Endpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkLayer_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Switch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagementEndpoint == nil {
				m.ManagementEndpoint = &Endpoint{}
			}
			if err := m.ManagementEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IPAddress_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceIP == nil {
				m.SourceIP = &IPAddress{}
			}
			if err := m.SourceIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestinationIP == nil {
				m.DestinationIP = &IPAddress{}
			}
			if err := m.DestinationIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhyInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhyInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhyInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelNumber", wireType)
			}
			m.ChannelNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthIndicator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthIndicator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfIndex", wireType)
			}
			m.IfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IfIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoNegotiate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoNegotiate = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &IPAddress{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ControllerInfo_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &ControllerRole{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &types.Any{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RTServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RTServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RTServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControlEndpoint == nil {
				m.ControlEndpoint = &Endpoint{}
			}
			if err := m.ControlEndpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.Timeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			m.DeviceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipelines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pipelines = append(m.Pipelines, &P4PipelineInfo{})
			if err := m.Pipelines[len(m.Pipelines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4PipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4PipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4PipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationAction", wireType)
			}
			m.ConfigurationAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationAction |= P4PipelineInfo_ConfigurationAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P4RTMastershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P4RTMastershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P4RTMastershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mastershipstate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFabric
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFabric
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mastershipstate == nil {
				m.Mastershipstate = &P4RTMastershipState{}
			}
			if err := m.Mastershipstate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFabric(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFabric
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFabric(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFabric
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFabric
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFabric
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFabric
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFabric
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFabric        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFabric          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFabric = fmt.Errorf("proto: unexpected end of group")
)
