// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/config/v3/admin.proto

// Package admin defines the administrative gRPC interfaces.

package v3

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	gnmi "github.com/openconfig/gnmi/proto/gnmi"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReadOnlySubPath is an extension to the ReadOnlyPath to define the datatype of
// the subpath
type ReadOnlySubPath struct {
	// sub_path is the relative path of a child object e.g. /list2b/index
	SubPath string `protobuf:"bytes,1,opt,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
	// value_type is the datatype of the read only path
	ValueType   ValueType `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=onos.config.v3.ValueType" json:"value_type,omitempty"`
	TypeOpts    []uint64  `protobuf:"varint,3,rep,packed,name=type_opts,json=typeOpts,proto3" json:"type_opts,omitempty"`
	Description string    `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Units       string    `protobuf:"bytes,5,opt,name=units,proto3" json:"units,omitempty"`
	IsAKey      bool      `protobuf:"varint,6,opt,name=IsAKey,proto3" json:"IsAKey,omitempty"`
	AttrName    string    `protobuf:"bytes,7,opt,name=AttrName,proto3" json:"AttrName,omitempty"`
}

func (m *ReadOnlySubPath) Reset()         { *m = ReadOnlySubPath{} }
func (m *ReadOnlySubPath) String() string { return proto.CompactTextString(m) }
func (*ReadOnlySubPath) ProtoMessage()    {}
func (*ReadOnlySubPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{0}
}
func (m *ReadOnlySubPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadOnlySubPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadOnlySubPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadOnlySubPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadOnlySubPath.Merge(m, src)
}
func (m *ReadOnlySubPath) XXX_Size() int {
	return m.Size()
}
func (m *ReadOnlySubPath) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadOnlySubPath.DiscardUnknown(m)
}

var xxx_messageInfo_ReadOnlySubPath proto.InternalMessageInfo

func (m *ReadOnlySubPath) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *ReadOnlySubPath) GetValueType() ValueType {
	if m != nil {
		return m.ValueType
	}
	return ValueType_EMPTY
}

func (m *ReadOnlySubPath) GetTypeOpts() []uint64 {
	if m != nil {
		return m.TypeOpts
	}
	return nil
}

func (m *ReadOnlySubPath) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ReadOnlySubPath) GetUnits() string {
	if m != nil {
		return m.Units
	}
	return ""
}

func (m *ReadOnlySubPath) GetIsAKey() bool {
	if m != nil {
		return m.IsAKey
	}
	return false
}

func (m *ReadOnlySubPath) GetAttrName() string {
	if m != nil {
		return m.AttrName
	}
	return ""
}

// ReadOnlyPath extracted from the model plugin as the definition of a tree of read only items.
// In YANG models items are defined as ReadOnly with the `config false` keyword.
// This can be applied to single items (leafs) or collections (containers or lists).
// When this `config false` is applied to an object every item beneath it will
// also become readonly - here these are shown as subpaths.
// The complete read only path then will be a concatenation of both e.g.
// /cont1a/cont1b-state/list2b/index and the type is defined in the SubPath as UInt8.
type ReadOnlyPath struct {
	// path of the topmost `config false` object e.g. /cont1a/cont1b-state
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// ReadOnlySubPath is a set of children of the path including an entry for the
	// type of the topmost object with subpath `/`
	// An example is /list2b/index
	SubPath []*ReadOnlySubPath `protobuf:"bytes,2,rep,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
}

func (m *ReadOnlyPath) Reset()         { *m = ReadOnlyPath{} }
func (m *ReadOnlyPath) String() string { return proto.CompactTextString(m) }
func (*ReadOnlyPath) ProtoMessage()    {}
func (*ReadOnlyPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{1}
}
func (m *ReadOnlyPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadOnlyPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadOnlyPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadOnlyPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadOnlyPath.Merge(m, src)
}
func (m *ReadOnlyPath) XXX_Size() int {
	return m.Size()
}
func (m *ReadOnlyPath) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadOnlyPath.DiscardUnknown(m)
}

var xxx_messageInfo_ReadOnlyPath proto.InternalMessageInfo

func (m *ReadOnlyPath) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ReadOnlyPath) GetSubPath() []*ReadOnlySubPath {
	if m != nil {
		return m.SubPath
	}
	return nil
}

// ReadWritePath is extracted from the model plugin as the definition of a writeable attributes.
// In YANG models items are writable by default unless they are specified as `config false` or
// have an item with `config false` as a parent.
// Each configurable item has metadata with meanings taken from the YANG specification RFC 6020.
type ReadWritePath struct {
	// path is the full path to the attribute (leaf or leaf-list)
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// value_type is the data type of the attribute
	ValueType ValueType `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=onos.config.v3.ValueType" json:"value_type,omitempty"`
	// units is the unit of measurement e.g. dB, mV
	Units string `protobuf:"bytes,3,opt,name=units,proto3" json:"units,omitempty"`
	// description is an explaination of the meaning of the attribute
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// mandatory shows whether the attribute is optional (false) or required (true)
	Mandatory bool `protobuf:"varint,5,opt,name=mandatory,proto3" json:"mandatory,omitempty"`
	// default is a default value used with optional attributes. Replaced by 'defaults' below
	Default string `protobuf:"bytes,6,opt,name=default,proto3" json:"default,omitempty"` // Deprecated: Do not use.
	// range is definition of the range of values a value is allowed
	Range []string `protobuf:"bytes,7,rep,name=range,proto3" json:"range,omitempty"`
	// length is a defintion of the length restrictions for the attribute
	Length   []string `protobuf:"bytes,8,rep,name=length,proto3" json:"length,omitempty"`
	TypeOpts []uint64 `protobuf:"varint,9,rep,packed,name=type_opts,json=typeOpts,proto3" json:"type_opts,omitempty"`
	IsAKey   bool     `protobuf:"varint,10,opt,name=IsAKey,proto3" json:"IsAKey,omitempty"`
	AttrName string   `protobuf:"bytes,11,opt,name=AttrName,proto3" json:"AttrName,omitempty"`
	// defaults is a default value(s) used with optional attributes. For leaf-list can have repeated values
	// replaces the 'default' attribute above
	Defaults []string `protobuf:"bytes,12,rep,name=defaults,proto3" json:"defaults,omitempty"`
}

func (m *ReadWritePath) Reset()         { *m = ReadWritePath{} }
func (m *ReadWritePath) String() string { return proto.CompactTextString(m) }
func (*ReadWritePath) ProtoMessage()    {}
func (*ReadWritePath) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{2}
}
func (m *ReadWritePath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadWritePath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadWritePath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadWritePath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadWritePath.Merge(m, src)
}
func (m *ReadWritePath) XXX_Size() int {
	return m.Size()
}
func (m *ReadWritePath) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadWritePath.DiscardUnknown(m)
}

var xxx_messageInfo_ReadWritePath proto.InternalMessageInfo

func (m *ReadWritePath) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ReadWritePath) GetValueType() ValueType {
	if m != nil {
		return m.ValueType
	}
	return ValueType_EMPTY
}

func (m *ReadWritePath) GetUnits() string {
	if m != nil {
		return m.Units
	}
	return ""
}

func (m *ReadWritePath) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ReadWritePath) GetMandatory() bool {
	if m != nil {
		return m.Mandatory
	}
	return false
}

// Deprecated: Do not use.
func (m *ReadWritePath) GetDefault() string {
	if m != nil {
		return m.Default
	}
	return ""
}

func (m *ReadWritePath) GetRange() []string {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *ReadWritePath) GetLength() []string {
	if m != nil {
		return m.Length
	}
	return nil
}

func (m *ReadWritePath) GetTypeOpts() []uint64 {
	if m != nil {
		return m.TypeOpts
	}
	return nil
}

func (m *ReadWritePath) GetIsAKey() bool {
	if m != nil {
		return m.IsAKey
	}
	return false
}

func (m *ReadWritePath) GetAttrName() string {
	if m != nil {
		return m.AttrName
	}
	return ""
}

func (m *ReadWritePath) GetDefaults() []string {
	if m != nil {
		return m.Defaults
	}
	return nil
}

// Namespace is a mapping between a module name and its shorthand prefix
type Namespace struct {
	Module string `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{3}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Namespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

func (m *Namespace) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *Namespace) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// ModelInfo is general information about a model plugin.
type ModelInfo struct {
	// name is the name given to the model plugin - no spaces and title case.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version is the semantic version of the Plugin e.g. 1.0.0.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// model_data is a set of metadata about the YANG files that went in to
	// generating the model plugin. It includes name, version and organization for
	// each YANG file, similar to how they are represented in gNMI Capabilities.
	ModelData []*gnmi.ModelData `protobuf:"bytes,3,rep,name=model_data,json=modelData,proto3" json:"model_data,omitempty"`
	// module is no longer used
	Module string `protobuf:"bytes,4,opt,name=module,proto3" json:"module,omitempty"` // Deprecated: Do not use.
	// getStateMode is flag that defines how the "get state" operation works.
	//  0) means that no retrieval of state is attempted
	//  1) means that the synchronizer will make 2 requests to the device - one for
	//      Get with State and another for Get with Operational.
	//  2) means that the synchronizer will do a Get request comprising of each
	//      one of the ReadOnlyPaths and their sub paths. If there is a `list`
	//      in any one of these paths it will be sent down as is, expecting the
	//      devices implementation of gNMI will be able to expand wildcards.
	//  3) means that the synchronizer will do a Get request comprising of each
	//      one of the ReadOnlyPaths and their sub paths. If there is a `list`
	//      in any one of these paths, a separate call will be made first to find
	//      all the instances in the list and a Get including these expanded wildcards
	//      will be sent down to the device.
	GetStateMode uint32 `protobuf:"varint,5,opt,name=getStateMode,proto3" json:"getStateMode,omitempty"`
	// read_only_path is all of the read only paths for the model plugin.
	ReadOnlyPath []*ReadOnlyPath `protobuf:"bytes,7,rep,name=read_only_path,json=readOnlyPath,proto3" json:"read_only_path,omitempty"`
	// read_write_path is all of the read write paths for the model plugin.
	ReadWritePath      []*ReadWritePath `protobuf:"bytes,8,rep,name=read_write_path,json=readWritePath,proto3" json:"read_write_path,omitempty"`
	SupportedEncodings []gnmi.Encoding  `protobuf:"varint,9,rep,packed,name=supported_encodings,json=supportedEncodings,proto3,enum=gnmi.Encoding" json:"supported_encodings,omitempty"`
	// namespace_mappings is a set of all prefix to module name mapping in the model
	NamespaceMappings []*Namespace `protobuf:"bytes,10,rep,name=namespace_mappings,json=namespaceMappings,proto3" json:"namespace_mappings,omitempty"`
	// southboundUsePrefix indicates that the southbound should add prefixes in gNMI paths
	SouthboundUsePrefix bool `protobuf:"varint,11,opt,name=southboundUsePrefix,proto3" json:"southboundUsePrefix,omitempty"`
}

func (m *ModelInfo) Reset()         { *m = ModelInfo{} }
func (m *ModelInfo) String() string { return proto.CompactTextString(m) }
func (*ModelInfo) ProtoMessage()    {}
func (*ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{4}
}
func (m *ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelInfo.Merge(m, src)
}
func (m *ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ModelInfo proto.InternalMessageInfo

func (m *ModelInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ModelInfo) GetModelData() []*gnmi.ModelData {
	if m != nil {
		return m.ModelData
	}
	return nil
}

// Deprecated: Do not use.
func (m *ModelInfo) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *ModelInfo) GetGetStateMode() uint32 {
	if m != nil {
		return m.GetStateMode
	}
	return 0
}

func (m *ModelInfo) GetReadOnlyPath() []*ReadOnlyPath {
	if m != nil {
		return m.ReadOnlyPath
	}
	return nil
}

func (m *ModelInfo) GetReadWritePath() []*ReadWritePath {
	if m != nil {
		return m.ReadWritePath
	}
	return nil
}

func (m *ModelInfo) GetSupportedEncodings() []gnmi.Encoding {
	if m != nil {
		return m.SupportedEncodings
	}
	return nil
}

func (m *ModelInfo) GetNamespaceMappings() []*Namespace {
	if m != nil {
		return m.NamespaceMappings
	}
	return nil
}

func (m *ModelInfo) GetSouthboundUsePrefix() bool {
	if m != nil {
		return m.SouthboundUsePrefix
	}
	return false
}

type ModelPlugin struct {
	Id       string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Endpoint string     `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Info     *ModelInfo `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	Status   string     `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	Error    string     `protobuf:"bytes,11,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ModelPlugin) Reset()         { *m = ModelPlugin{} }
func (m *ModelPlugin) String() string { return proto.CompactTextString(m) }
func (*ModelPlugin) ProtoMessage()    {}
func (*ModelPlugin) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{5}
}
func (m *ModelPlugin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelPlugin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelPlugin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelPlugin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelPlugin.Merge(m, src)
}
func (m *ModelPlugin) XXX_Size() int {
	return m.Size()
}
func (m *ModelPlugin) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelPlugin.DiscardUnknown(m)
}

var xxx_messageInfo_ModelPlugin proto.InternalMessageInfo

func (m *ModelPlugin) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModelPlugin) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *ModelPlugin) GetInfo() *ModelInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ModelPlugin) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ModelPlugin) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// ListModelsRequest carries data for querying registered model plugins.
type ListModelsRequest struct {
	// verbose option causes all of the ReadWrite and ReadOnly paths to be included.
	Verbose bool `protobuf:"varint,1,opt,name=verbose,proto3" json:"verbose,omitempty"`
	// An optional filter on the name of the model plugins to list.
	ModelName string `protobuf:"bytes,2,opt,name=model_name,json=modelName,proto3" json:"model_name,omitempty"`
	// An optional filter on the version of the model plugins to list
	ModelVersion string `protobuf:"bytes,3,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
}

func (m *ListModelsRequest) Reset()         { *m = ListModelsRequest{} }
func (m *ListModelsRequest) String() string { return proto.CompactTextString(m) }
func (*ListModelsRequest) ProtoMessage()    {}
func (*ListModelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{6}
}
func (m *ListModelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListModelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListModelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListModelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListModelsRequest.Merge(m, src)
}
func (m *ListModelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListModelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListModelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListModelsRequest proto.InternalMessageInfo

func (m *ListModelsRequest) GetVerbose() bool {
	if m != nil {
		return m.Verbose
	}
	return false
}

func (m *ListModelsRequest) GetModelName() string {
	if m != nil {
		return m.ModelName
	}
	return ""
}

func (m *ListModelsRequest) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

// RollbackRequest carries the index of the configuration change transaction to rollback.
type RollbackRequest struct {
	TransactionID TransactionID `protobuf:"bytes,1,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id"`
}

func (m *RollbackRequest) Reset()         { *m = RollbackRequest{} }
func (m *RollbackRequest) String() string { return proto.CompactTextString(m) }
func (*RollbackRequest) ProtoMessage()    {}
func (*RollbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{7}
}
func (m *RollbackRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackRequest.Merge(m, src)
}
func (m *RollbackRequest) XXX_Size() int {
	return m.Size()
}
func (m *RollbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackRequest proto.InternalMessageInfo

func (m *RollbackRequest) GetTransactionID() TransactionID {
	if m != nil {
		return m.TransactionID
	}
	return TransactionID{}
}

// RollbackResponse carries the response of the rollback operation
type RollbackResponse struct {
}

func (m *RollbackResponse) Reset()         { *m = RollbackResponse{} }
func (m *RollbackResponse) String() string { return proto.CompactTextString(m) }
func (*RollbackResponse) ProtoMessage()    {}
func (*RollbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{8}
}
func (m *RollbackResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackResponse.Merge(m, src)
}
func (m *RollbackResponse) XXX_Size() int {
	return m.Size()
}
func (m *RollbackResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackResponse proto.InternalMessageInfo

// LeafSelectionQueryRequest carries request for the selection of leaf values
type LeafSelectionQueryRequest struct {
	// target is the name of the target (device) to perform the query on
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// type of model plugin to perform the query on
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// version of model plugin to perform the query on
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// selectionPath is a configuration path to a leaf in the format:
	// /a/b[key1=index][key2=index2]/c/d where d is a leaf node
	SelectionPath string `protobuf:"bytes,4,opt,name=selectionPath,proto3" json:"selectionPath,omitempty"`
	// changeContext is the set of changes (e.g. from the GUI form) that have to be superimposed
	// on the current configuration before the leaf selection can be made
	// All the changes in this request should match the target given above
	// optional
	ChangeContext *gnmi.SetRequest `protobuf:"bytes,5,opt,name=changeContext,proto3" json:"changeContext,omitempty"`
}

func (m *LeafSelectionQueryRequest) Reset()         { *m = LeafSelectionQueryRequest{} }
func (m *LeafSelectionQueryRequest) String() string { return proto.CompactTextString(m) }
func (*LeafSelectionQueryRequest) ProtoMessage()    {}
func (*LeafSelectionQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{9}
}
func (m *LeafSelectionQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafSelectionQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeafSelectionQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeafSelectionQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafSelectionQueryRequest.Merge(m, src)
}
func (m *LeafSelectionQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeafSelectionQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafSelectionQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeafSelectionQueryRequest proto.InternalMessageInfo

func (m *LeafSelectionQueryRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *LeafSelectionQueryRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LeafSelectionQueryRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LeafSelectionQueryRequest) GetSelectionPath() string {
	if m != nil {
		return m.SelectionPath
	}
	return ""
}

func (m *LeafSelectionQueryRequest) GetChangeContext() *gnmi.SetRequest {
	if m != nil {
		return m.ChangeContext
	}
	return nil
}

// LeafSelectionQueryResponse carries response for the model information query
type LeafSelectionQueryResponse struct {
	// selection is an array of string values
	Selection []string `protobuf:"bytes,1,rep,name=selection,proto3" json:"selection,omitempty"`
}

func (m *LeafSelectionQueryResponse) Reset()         { *m = LeafSelectionQueryResponse{} }
func (m *LeafSelectionQueryResponse) String() string { return proto.CompactTextString(m) }
func (*LeafSelectionQueryResponse) ProtoMessage()    {}
func (*LeafSelectionQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{10}
}
func (m *LeafSelectionQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafSelectionQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeafSelectionQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeafSelectionQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafSelectionQueryResponse.Merge(m, src)
}
func (m *LeafSelectionQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeafSelectionQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafSelectionQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeafSelectionQueryResponse proto.InternalMessageInfo

func (m *LeafSelectionQueryResponse) GetSelection() []string {
	if m != nil {
		return m.Selection
	}
	return nil
}

// ModelInfoRequest carries request for the model information
type ModelInfoRequest struct {
}

func (m *ModelInfoRequest) Reset()         { *m = ModelInfoRequest{} }
func (m *ModelInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ModelInfoRequest) ProtoMessage()    {}
func (*ModelInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{11}
}
func (m *ModelInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelInfoRequest.Merge(m, src)
}
func (m *ModelInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModelInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModelInfoRequest proto.InternalMessageInfo

// ModelInfoResponse carries response for the model information query
type ModelInfoResponse struct {
	ModelInfo *ModelInfo `protobuf:"bytes,1,opt,name=modelInfo,proto3" json:"modelInfo,omitempty"`
}

func (m *ModelInfoResponse) Reset()         { *m = ModelInfoResponse{} }
func (m *ModelInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ModelInfoResponse) ProtoMessage()    {}
func (*ModelInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{12}
}
func (m *ModelInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelInfoResponse.Merge(m, src)
}
func (m *ModelInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ModelInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ModelInfoResponse proto.InternalMessageInfo

func (m *ModelInfoResponse) GetModelInfo() *ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

// ValidateConfigRequest carries configuration data to be validated as a JSON blob
//
// Deprecated: Do not use.
type ValidateConfigRequest struct {
	Json []byte `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
}

func (m *ValidateConfigRequest) Reset()         { *m = ValidateConfigRequest{} }
func (m *ValidateConfigRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateConfigRequest) ProtoMessage()    {}
func (*ValidateConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{13}
}
func (m *ValidateConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateConfigRequest.Merge(m, src)
}
func (m *ValidateConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateConfigRequest proto.InternalMessageInfo

func (m *ValidateConfigRequest) GetJson() []byte {
	if m != nil {
		return m.Json
	}
	return nil
}

// ValidateConfigRequestChunk carries configuration data to be validated as a JSON blob
// Recommended maximum size is 100kB
type ValidateConfigRequestChunk struct {
	Json []byte `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
}

func (m *ValidateConfigRequestChunk) Reset()         { *m = ValidateConfigRequestChunk{} }
func (m *ValidateConfigRequestChunk) String() string { return proto.CompactTextString(m) }
func (*ValidateConfigRequestChunk) ProtoMessage()    {}
func (*ValidateConfigRequestChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{14}
}
func (m *ValidateConfigRequestChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateConfigRequestChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateConfigRequestChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateConfigRequestChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateConfigRequestChunk.Merge(m, src)
}
func (m *ValidateConfigRequestChunk) XXX_Size() int {
	return m.Size()
}
func (m *ValidateConfigRequestChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateConfigRequestChunk.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateConfigRequestChunk proto.InternalMessageInfo

func (m *ValidateConfigRequestChunk) GetJson() []byte {
	if m != nil {
		return m.Json
	}
	return nil
}

// ValidateConfigRequest carries configuration data to be validated as a JSON blob
type ValidateConfigChunkRequest struct {
	Json []byte `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
}

func (m *ValidateConfigChunkRequest) Reset()         { *m = ValidateConfigChunkRequest{} }
func (m *ValidateConfigChunkRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateConfigChunkRequest) ProtoMessage()    {}
func (*ValidateConfigChunkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{15}
}
func (m *ValidateConfigChunkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateConfigChunkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateConfigChunkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateConfigChunkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateConfigChunkRequest.Merge(m, src)
}
func (m *ValidateConfigChunkRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateConfigChunkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateConfigChunkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateConfigChunkRequest proto.InternalMessageInfo

func (m *ValidateConfigChunkRequest) GetJson() []byte {
	if m != nil {
		return m.Json
	}
	return nil
}

// ValidateConfigResponse carries the result of the validation
type ValidateConfigResponse struct {
	Valid   bool   `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ValidateConfigResponse) Reset()         { *m = ValidateConfigResponse{} }
func (m *ValidateConfigResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateConfigResponse) ProtoMessage()    {}
func (*ValidateConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{16}
}
func (m *ValidateConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateConfigResponse.Merge(m, src)
}
func (m *ValidateConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidateConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateConfigResponse proto.InternalMessageInfo

func (m *ValidateConfigResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *ValidateConfigResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// PathValuesRequest carries configuration change as a JSON blob
type PathValuesRequest struct {
	PathPrefix string `protobuf:"bytes,1,opt,name=pathPrefix,proto3" json:"pathPrefix,omitempty"`
	Json       []byte `protobuf:"bytes,2,opt,name=json,proto3" json:"json,omitempty"`
}

func (m *PathValuesRequest) Reset()         { *m = PathValuesRequest{} }
func (m *PathValuesRequest) String() string { return proto.CompactTextString(m) }
func (*PathValuesRequest) ProtoMessage()    {}
func (*PathValuesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{17}
}
func (m *PathValuesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathValuesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathValuesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathValuesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathValuesRequest.Merge(m, src)
}
func (m *PathValuesRequest) XXX_Size() int {
	return m.Size()
}
func (m *PathValuesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PathValuesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PathValuesRequest proto.InternalMessageInfo

func (m *PathValuesRequest) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *PathValuesRequest) GetJson() []byte {
	if m != nil {
		return m.Json
	}
	return nil
}

// PathValuesResponse carries a list of typed path values
type PathValuesResponse struct {
	PathValues []*PathValue `protobuf:"bytes,1,rep,name=pathValues,proto3" json:"pathValues,omitempty"`
}

func (m *PathValuesResponse) Reset()         { *m = PathValuesResponse{} }
func (m *PathValuesResponse) String() string { return proto.CompactTextString(m) }
func (*PathValuesResponse) ProtoMessage()    {}
func (*PathValuesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{18}
}
func (m *PathValuesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathValuesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathValuesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathValuesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathValuesResponse.Merge(m, src)
}
func (m *PathValuesResponse) XXX_Size() int {
	return m.Size()
}
func (m *PathValuesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PathValuesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PathValuesResponse proto.InternalMessageInfo

func (m *PathValuesResponse) GetPathValues() []*PathValue {
	if m != nil {
		return m.PathValues
	}
	return nil
}

// ValueSelectionRequest carries the necessary parts to form a selection context
//
// Deprecated: Do not use.
type ValueSelectionRequest struct {
	// selectionPath is a configuration path to a leaf in the format:
	// /a/b[key1=index][key2=index2]/c/d where d is a leaf node
	SelectionPath string `protobuf:"bytes,1,opt,name=selectionPath,proto3" json:"selectionPath,omitempty"`
	// configJson is a JSON tree view of the complete Configuration for a Target
	ConfigJson []byte `protobuf:"bytes,2,opt,name=configJson,proto3" json:"configJson,omitempty"`
}

func (m *ValueSelectionRequest) Reset()         { *m = ValueSelectionRequest{} }
func (m *ValueSelectionRequest) String() string { return proto.CompactTextString(m) }
func (*ValueSelectionRequest) ProtoMessage()    {}
func (*ValueSelectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{19}
}
func (m *ValueSelectionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueSelectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueSelectionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueSelectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueSelectionRequest.Merge(m, src)
}
func (m *ValueSelectionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValueSelectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueSelectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValueSelectionRequest proto.InternalMessageInfo

func (m *ValueSelectionRequest) GetSelectionPath() string {
	if m != nil {
		return m.SelectionPath
	}
	return ""
}

func (m *ValueSelectionRequest) GetConfigJson() []byte {
	if m != nil {
		return m.ConfigJson
	}
	return nil
}

// ValueSelectionRequestChunk carries the necessary parts to form a selection context
// Recommended maximum size is 100kB
type ValueSelectionRequestChunk struct {
	// selectionPath is a configuration path to a leaf in the format:
	// /a/b[key1=index][key2=index2]/c/d where d is a leaf node
	SelectionPath string `protobuf:"bytes,1,opt,name=selectionPath,proto3" json:"selectionPath,omitempty"`
	// configJson is a JSON tree view of the complete Configuration for a Target
	ConfigJson []byte `protobuf:"bytes,2,opt,name=configJson,proto3" json:"configJson,omitempty"`
}

func (m *ValueSelectionRequestChunk) Reset()         { *m = ValueSelectionRequestChunk{} }
func (m *ValueSelectionRequestChunk) String() string { return proto.CompactTextString(m) }
func (*ValueSelectionRequestChunk) ProtoMessage()    {}
func (*ValueSelectionRequestChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{20}
}
func (m *ValueSelectionRequestChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueSelectionRequestChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueSelectionRequestChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueSelectionRequestChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueSelectionRequestChunk.Merge(m, src)
}
func (m *ValueSelectionRequestChunk) XXX_Size() int {
	return m.Size()
}
func (m *ValueSelectionRequestChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueSelectionRequestChunk.DiscardUnknown(m)
}

var xxx_messageInfo_ValueSelectionRequestChunk proto.InternalMessageInfo

func (m *ValueSelectionRequestChunk) GetSelectionPath() string {
	if m != nil {
		return m.SelectionPath
	}
	return ""
}

func (m *ValueSelectionRequestChunk) GetConfigJson() []byte {
	if m != nil {
		return m.ConfigJson
	}
	return nil
}

// ValueSelectionResponse returns the result of applying the selection rules to the selection context
type ValueSelectionResponse struct {
	// selection is an array of string values
	Selection []string `protobuf:"bytes,1,rep,name=selection,proto3" json:"selection,omitempty"`
}

func (m *ValueSelectionResponse) Reset()         { *m = ValueSelectionResponse{} }
func (m *ValueSelectionResponse) String() string { return proto.CompactTextString(m) }
func (*ValueSelectionResponse) ProtoMessage()    {}
func (*ValueSelectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{21}
}
func (m *ValueSelectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueSelectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueSelectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueSelectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueSelectionResponse.Merge(m, src)
}
func (m *ValueSelectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValueSelectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueSelectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValueSelectionResponse proto.InternalMessageInfo

func (m *ValueSelectionResponse) GetSelection() []string {
	if m != nil {
		return m.Selection
	}
	return nil
}

type GetTransactionRequest struct {
	ID TransactionID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *GetTransactionRequest) Reset()         { *m = GetTransactionRequest{} }
func (m *GetTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransactionRequest) ProtoMessage()    {}
func (*GetTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{22}
}
func (m *GetTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionRequest.Merge(m, src)
}
func (m *GetTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionRequest proto.InternalMessageInfo

func (m *GetTransactionRequest) GetID() TransactionID {
	if m != nil {
		return m.ID
	}
	return TransactionID{}
}

type GetTransactionResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (m *GetTransactionResponse) Reset()         { *m = GetTransactionResponse{} }
func (m *GetTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransactionResponse) ProtoMessage()    {}
func (*GetTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{23}
}
func (m *GetTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionResponse.Merge(m, src)
}
func (m *GetTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionResponse proto.InternalMessageInfo

func (m *GetTransactionResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type ListTransactionsRequest struct {
}

func (m *ListTransactionsRequest) Reset()         { *m = ListTransactionsRequest{} }
func (m *ListTransactionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListTransactionsRequest) ProtoMessage()    {}
func (*ListTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{24}
}
func (m *ListTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTransactionsRequest.Merge(m, src)
}
func (m *ListTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTransactionsRequest proto.InternalMessageInfo

type ListTransactionsResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (m *ListTransactionsResponse) Reset()         { *m = ListTransactionsResponse{} }
func (m *ListTransactionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListTransactionsResponse) ProtoMessage()    {}
func (*ListTransactionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{25}
}
func (m *ListTransactionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTransactionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTransactionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTransactionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTransactionsResponse.Merge(m, src)
}
func (m *ListTransactionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListTransactionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTransactionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTransactionsResponse proto.InternalMessageInfo

func (m *ListTransactionsResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type WatchTransactionsRequest struct {
	TransactionID TransactionID `protobuf:"bytes,1,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id"`
	Noreplay      bool          `protobuf:"varint,2,opt,name=noreplay,proto3" json:"noreplay,omitempty"`
}

func (m *WatchTransactionsRequest) Reset()         { *m = WatchTransactionsRequest{} }
func (m *WatchTransactionsRequest) String() string { return proto.CompactTextString(m) }
func (*WatchTransactionsRequest) ProtoMessage()    {}
func (*WatchTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{26}
}
func (m *WatchTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchTransactionsRequest.Merge(m, src)
}
func (m *WatchTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchTransactionsRequest proto.InternalMessageInfo

func (m *WatchTransactionsRequest) GetTransactionID() TransactionID {
	if m != nil {
		return m.TransactionID
	}
	return TransactionID{}
}

func (m *WatchTransactionsRequest) GetNoreplay() bool {
	if m != nil {
		return m.Noreplay
	}
	return false
}

type WatchTransactionsResponse struct {
	TransactionEvent `protobuf:"bytes,1,opt,name=event,proto3,embedded=event" json:"event"`
}

func (m *WatchTransactionsResponse) Reset()         { *m = WatchTransactionsResponse{} }
func (m *WatchTransactionsResponse) String() string { return proto.CompactTextString(m) }
func (*WatchTransactionsResponse) ProtoMessage()    {}
func (*WatchTransactionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{27}
}
func (m *WatchTransactionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchTransactionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchTransactionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchTransactionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchTransactionsResponse.Merge(m, src)
}
func (m *WatchTransactionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchTransactionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchTransactionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchTransactionsResponse proto.InternalMessageInfo

type GetConfigurationRequest struct {
	ConfigurationID ConfigurationID `protobuf:"bytes,1,opt,name=configuration_id,json=configurationId,proto3" json:"configuration_id"`
}

func (m *GetConfigurationRequest) Reset()         { *m = GetConfigurationRequest{} }
func (m *GetConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*GetConfigurationRequest) ProtoMessage()    {}
func (*GetConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{28}
}
func (m *GetConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigurationRequest.Merge(m, src)
}
func (m *GetConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigurationRequest proto.InternalMessageInfo

func (m *GetConfigurationRequest) GetConfigurationID() ConfigurationID {
	if m != nil {
		return m.ConfigurationID
	}
	return ConfigurationID{}
}

type GetConfigurationResponse struct {
	Configuration *Configuration `protobuf:"bytes,1,opt,name=configuration,proto3" json:"configuration,omitempty"`
}

func (m *GetConfigurationResponse) Reset()         { *m = GetConfigurationResponse{} }
func (m *GetConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*GetConfigurationResponse) ProtoMessage()    {}
func (*GetConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{29}
}
func (m *GetConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigurationResponse.Merge(m, src)
}
func (m *GetConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigurationResponse proto.InternalMessageInfo

func (m *GetConfigurationResponse) GetConfiguration() *Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type ListConfigurationsRequest struct {
}

func (m *ListConfigurationsRequest) Reset()         { *m = ListConfigurationsRequest{} }
func (m *ListConfigurationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListConfigurationsRequest) ProtoMessage()    {}
func (*ListConfigurationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{30}
}
func (m *ListConfigurationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListConfigurationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListConfigurationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListConfigurationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListConfigurationsRequest.Merge(m, src)
}
func (m *ListConfigurationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListConfigurationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListConfigurationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListConfigurationsRequest proto.InternalMessageInfo

type ListConfigurationsResponse struct {
	Configuration *Configuration `protobuf:"bytes,1,opt,name=configuration,proto3" json:"configuration,omitempty"`
}

func (m *ListConfigurationsResponse) Reset()         { *m = ListConfigurationsResponse{} }
func (m *ListConfigurationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListConfigurationsResponse) ProtoMessage()    {}
func (*ListConfigurationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{31}
}
func (m *ListConfigurationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListConfigurationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListConfigurationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListConfigurationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListConfigurationsResponse.Merge(m, src)
}
func (m *ListConfigurationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListConfigurationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListConfigurationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListConfigurationsResponse proto.InternalMessageInfo

func (m *ListConfigurationsResponse) GetConfiguration() *Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

type WatchConfigurationsRequest struct {
	ConfigurationID ConfigurationID `protobuf:"bytes,1,opt,name=configuration_id,json=configurationId,proto3" json:"configuration_id"`
	Noreplay        bool            `protobuf:"varint,2,opt,name=noreplay,proto3" json:"noreplay,omitempty"`
}

func (m *WatchConfigurationsRequest) Reset()         { *m = WatchConfigurationsRequest{} }
func (m *WatchConfigurationsRequest) String() string { return proto.CompactTextString(m) }
func (*WatchConfigurationsRequest) ProtoMessage()    {}
func (*WatchConfigurationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{32}
}
func (m *WatchConfigurationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchConfigurationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchConfigurationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchConfigurationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchConfigurationsRequest.Merge(m, src)
}
func (m *WatchConfigurationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchConfigurationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchConfigurationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchConfigurationsRequest proto.InternalMessageInfo

func (m *WatchConfigurationsRequest) GetConfigurationID() ConfigurationID {
	if m != nil {
		return m.ConfigurationID
	}
	return ConfigurationID{}
}

func (m *WatchConfigurationsRequest) GetNoreplay() bool {
	if m != nil {
		return m.Noreplay
	}
	return false
}

type WatchConfigurationsResponse struct {
	ConfigurationEvent `protobuf:"bytes,1,opt,name=event,proto3,embedded=event" json:"event"`
}

func (m *WatchConfigurationsResponse) Reset()         { *m = WatchConfigurationsResponse{} }
func (m *WatchConfigurationsResponse) String() string { return proto.CompactTextString(m) }
func (*WatchConfigurationsResponse) ProtoMessage()    {}
func (*WatchConfigurationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_be63bb8c470e9e63, []int{33}
}
func (m *WatchConfigurationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchConfigurationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchConfigurationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchConfigurationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchConfigurationsResponse.Merge(m, src)
}
func (m *WatchConfigurationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchConfigurationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchConfigurationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchConfigurationsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ReadOnlySubPath)(nil), "onos.config.v3.ReadOnlySubPath")
	proto.RegisterType((*ReadOnlyPath)(nil), "onos.config.v3.ReadOnlyPath")
	proto.RegisterType((*ReadWritePath)(nil), "onos.config.v3.ReadWritePath")
	proto.RegisterType((*Namespace)(nil), "onos.config.v3.Namespace")
	proto.RegisterType((*ModelInfo)(nil), "onos.config.v3.ModelInfo")
	proto.RegisterType((*ModelPlugin)(nil), "onos.config.v3.ModelPlugin")
	proto.RegisterType((*ListModelsRequest)(nil), "onos.config.v3.ListModelsRequest")
	proto.RegisterType((*RollbackRequest)(nil), "onos.config.v3.RollbackRequest")
	proto.RegisterType((*RollbackResponse)(nil), "onos.config.v3.RollbackResponse")
	proto.RegisterType((*LeafSelectionQueryRequest)(nil), "onos.config.v3.LeafSelectionQueryRequest")
	proto.RegisterType((*LeafSelectionQueryResponse)(nil), "onos.config.v3.LeafSelectionQueryResponse")
	proto.RegisterType((*ModelInfoRequest)(nil), "onos.config.v3.ModelInfoRequest")
	proto.RegisterType((*ModelInfoResponse)(nil), "onos.config.v3.ModelInfoResponse")
	proto.RegisterType((*ValidateConfigRequest)(nil), "onos.config.v3.ValidateConfigRequest")
	proto.RegisterType((*ValidateConfigRequestChunk)(nil), "onos.config.v3.ValidateConfigRequestChunk")
	proto.RegisterType((*ValidateConfigChunkRequest)(nil), "onos.config.v3.ValidateConfigChunkRequest")
	proto.RegisterType((*ValidateConfigResponse)(nil), "onos.config.v3.ValidateConfigResponse")
	proto.RegisterType((*PathValuesRequest)(nil), "onos.config.v3.PathValuesRequest")
	proto.RegisterType((*PathValuesResponse)(nil), "onos.config.v3.PathValuesResponse")
	proto.RegisterType((*ValueSelectionRequest)(nil), "onos.config.v3.ValueSelectionRequest")
	proto.RegisterType((*ValueSelectionRequestChunk)(nil), "onos.config.v3.ValueSelectionRequestChunk")
	proto.RegisterType((*ValueSelectionResponse)(nil), "onos.config.v3.ValueSelectionResponse")
	proto.RegisterType((*GetTransactionRequest)(nil), "onos.config.v3.GetTransactionRequest")
	proto.RegisterType((*GetTransactionResponse)(nil), "onos.config.v3.GetTransactionResponse")
	proto.RegisterType((*ListTransactionsRequest)(nil), "onos.config.v3.ListTransactionsRequest")
	proto.RegisterType((*ListTransactionsResponse)(nil), "onos.config.v3.ListTransactionsResponse")
	proto.RegisterType((*WatchTransactionsRequest)(nil), "onos.config.v3.WatchTransactionsRequest")
	proto.RegisterType((*WatchTransactionsResponse)(nil), "onos.config.v3.WatchTransactionsResponse")
	proto.RegisterType((*GetConfigurationRequest)(nil), "onos.config.v3.GetConfigurationRequest")
	proto.RegisterType((*GetConfigurationResponse)(nil), "onos.config.v3.GetConfigurationResponse")
	proto.RegisterType((*ListConfigurationsRequest)(nil), "onos.config.v3.ListConfigurationsRequest")
	proto.RegisterType((*ListConfigurationsResponse)(nil), "onos.config.v3.ListConfigurationsResponse")
	proto.RegisterType((*WatchConfigurationsRequest)(nil), "onos.config.v3.WatchConfigurationsRequest")
	proto.RegisterType((*WatchConfigurationsResponse)(nil), "onos.config.v3.WatchConfigurationsResponse")
}

func init() { proto.RegisterFile("onos/config/v3/admin.proto", fileDescriptor_be63bb8c470e9e63) }

var fileDescriptor_be63bb8c470e9e63 = []byte{
	// 1749 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcb, 0x6f, 0x1b, 0x5d,
	0x15, 0xcf, 0xd8, 0x79, 0xd8, 0xc7, 0xb1, 0x93, 0xdc, 0xa4, 0xe9, 0x64, 0xd2, 0xcf, 0xf1, 0x37,
	0xbc, 0xfc, 0x15, 0xe1, 0x44, 0xae, 0x54, 0x68, 0x11, 0x82, 0x26, 0xa9, 0xd2, 0x40, 0x4b, 0xcb,
	0xa4, 0xa4, 0x45, 0x08, 0xac, 0x6b, 0xcf, 0xcd, 0x78, 0xa8, 0x3d, 0x33, 0x9d, 0xb9, 0x63, 0xea,
	0x0d, 0x6b, 0x96, 0x48, 0x48, 0xec, 0xf8, 0x33, 0x58, 0xb3, 0xed, 0x32, 0x4b, 0x56, 0x15, 0x4a,
	0x59, 0x22, 0xa1, 0xfe, 0x07, 0xe8, 0x3e, 0x66, 0x3c, 0xe3, 0x19, 0x3b, 0x11, 0x2a, 0xdf, 0x26,
	0x9a, 0x7b, 0xee, 0x79, 0x9f, 0xdf, 0x3d, 0xe7, 0x38, 0xa0, 0xb9, 0x8e, 0x1b, 0xec, 0xf7, 0x5c,
	0xe7, 0xc2, 0xb6, 0xf6, 0x47, 0xf7, 0xf6, 0xb1, 0x39, 0xb4, 0x9d, 0x96, 0xe7, 0xbb, 0xd4, 0x45,
	0x35, 0x76, 0xd7, 0x12, 0x77, 0xad, 0xd1, 0x3d, 0x6d, 0xcb, 0x72, 0x2d, 0x97, 0x5f, 0xed, 0xb3,
	0x2f, 0xc1, 0xa5, 0x1d, 0x58, 0x36, 0xed, 0x87, 0xdd, 0x56, 0xcf, 0x1d, 0xee, 0xbb, 0x1e, 0x71,
	0xa4, 0x2e, 0xcb, 0x19, 0xda, 0xfb, 0x92, 0x99, 0x7d, 0xb2, 0x3f, 0x52, 0x62, 0xda, 0xe6, 0x08,
	0x0f, 0x42, 0x22, 0xef, 0x1a, 0x53, 0x77, 0xd4, 0xc7, 0x4e, 0x80, 0x7b, 0xd4, 0x76, 0xa5, 0x57,
	0x9a, 0x3e, 0xc5, 0x21, 0xbe, 0x42, 0x1f, 0x4f, 0x78, 0xf4, 0xff, 0x28, 0xb0, 0x66, 0x10, 0x6c,
	0x3e, 0x77, 0x06, 0xe3, 0xb3, 0xb0, 0xfb, 0x02, 0xd3, 0x3e, 0xda, 0x81, 0x52, 0x10, 0x76, 0x3b,
	0x1e, 0xa6, 0x7d, 0x55, 0x69, 0x28, 0xcd, 0xb2, 0xb1, 0x12, 0xc8, 0xab, 0x1f, 0x00, 0x70, 0x1f,
	0x3a, 0x74, 0xec, 0x11, 0xb5, 0xd0, 0x50, 0x9a, 0xb5, 0xf6, 0x4e, 0x2b, 0x1d, 0x7d, 0xeb, 0x9c,
	0x71, 0xbc, 0x1c, 0x7b, 0xc4, 0x28, 0x8f, 0xa2, 0x4f, 0xb4, 0x0b, 0x65, 0x26, 0xd3, 0x71, 0x3d,
	0x1a, 0xa8, 0xc5, 0x46, 0xb1, 0xb9, 0x68, 0x94, 0x18, 0xe1, 0xb9, 0x47, 0x03, 0xd4, 0x80, 0x8a,
	0x49, 0x82, 0x9e, 0x6f, 0x7b, 0xcc, 0x35, 0x75, 0x91, 0x1b, 0x4d, 0x92, 0xd0, 0x16, 0x2c, 0x85,
	0x8e, 0x4d, 0x03, 0x75, 0x89, 0xdf, 0x89, 0x03, 0xda, 0x86, 0xe5, 0xd3, 0xe0, 0xd1, 0xcf, 0xc8,
	0x58, 0x5d, 0x6e, 0x28, 0xcd, 0x92, 0x21, 0x4f, 0x48, 0x83, 0xd2, 0x23, 0x4a, 0xfd, 0x9f, 0xe3,
	0x21, 0x51, 0x57, 0xb8, 0x40, 0x7c, 0xd6, 0x7f, 0x0b, 0xab, 0x51, 0xc0, 0x3c, 0x24, 0x04, 0x8b,
	0x89, 0x48, 0xf9, 0x37, 0x7a, 0x98, 0xc8, 0x40, 0xa1, 0x51, 0x6c, 0x56, 0xda, 0x7b, 0xd3, 0x41,
	0x4e, 0x25, 0x2d, 0x4e, 0x91, 0xfe, 0xef, 0x02, 0x54, 0xd9, 0xe5, 0x2b, 0xdf, 0xa6, 0x64, 0xa6,
	0x85, 0xff, 0x3d, 0x91, 0x71, 0x26, 0x8a, 0xc9, 0x4c, 0x5c, 0x9f, 0xc1, 0x3b, 0x50, 0x1e, 0x62,
	0xc7, 0xc4, 0xd4, 0xf5, 0xc7, 0x3c, 0x8b, 0x25, 0x63, 0x42, 0x40, 0x77, 0x60, 0xc5, 0x24, 0x17,
	0x38, 0x1c, 0x50, 0x9e, 0xca, 0xf2, 0x61, 0x41, 0x55, 0x8c, 0x88, 0xc4, 0x6c, 0xfa, 0xd8, 0xb1,
	0x58, 0x32, 0x8b, 0xcc, 0x26, 0x3f, 0xb0, 0xec, 0x0f, 0x88, 0x63, 0xd1, 0xbe, 0x5a, 0xe2, 0x64,
	0x79, 0x4a, 0x97, 0xba, 0x3c, 0x55, 0xea, 0x49, 0xc9, 0x60, 0x66, 0xc9, 0x2a, 0xe9, 0x92, 0xb1,
	0x3b, 0xe9, 0x49, 0xa0, 0xae, 0x72, 0x53, 0xf1, 0x59, 0xff, 0x21, 0x94, 0x19, 0x4f, 0xe0, 0xe1,
	0x1e, 0xf7, 0x68, 0xe8, 0x9a, 0xe1, 0x80, 0xc8, 0x5c, 0xcb, 0x13, 0xa3, 0x7b, 0x3e, 0xb9, 0xb0,
	0xdf, 0xf1, 0x4c, 0x97, 0x0d, 0x79, 0xd2, 0x3f, 0x15, 0xa1, 0xfc, 0xcc, 0x35, 0xc9, 0xe0, 0xd4,
	0xb9, 0x70, 0x59, 0x9d, 0x1c, 0x66, 0x5e, 0xd6, 0x89, 0x7d, 0x23, 0x15, 0x56, 0x46, 0xc4, 0x0f,
	0x58, 0x4e, 0x85, 0x68, 0x74, 0x44, 0x2d, 0x80, 0x21, 0x13, 0xed, 0x98, 0x98, 0x62, 0x8e, 0xe8,
	0x4a, 0x7b, 0xad, 0xc5, 0x1f, 0x2f, 0x57, 0x79, 0x8c, 0x29, 0x36, 0xca, 0xc3, 0xe8, 0x13, 0x69,
	0xb1, 0x6f, 0x8b, 0x71, 0x82, 0x23, 0xff, 0x74, 0x58, 0xb5, 0x08, 0x3d, 0xa3, 0x98, 0x12, 0x26,
	0xcb, 0xcb, 0x53, 0x35, 0x52, 0x34, 0x74, 0x08, 0x35, 0x9f, 0x60, 0xb3, 0xe3, 0x3a, 0x83, 0xb1,
	0x40, 0xe6, 0x0a, 0xb7, 0x79, 0x67, 0x16, 0x32, 0x39, 0x2c, 0x57, 0xfd, 0x24, 0xd6, 0x1f, 0xc3,
	0x1a, 0xd7, 0xf1, 0x7b, 0x86, 0x4d, 0xa1, 0xa4, 0xc4, 0x95, 0x7c, 0x91, 0xa7, 0x24, 0x46, 0xb0,
	0x51, 0xf5, 0x53, 0x80, 0xfe, 0x31, 0x6c, 0x06, 0xa1, 0xe7, 0xb9, 0x3e, 0x25, 0x66, 0x87, 0xf5,
	0x31, 0xd3, 0x76, 0x2c, 0x51, 0xea, 0x5a, 0xbb, 0x26, 0x72, 0xf0, 0x58, 0x92, 0x0d, 0x14, 0xb3,
	0x46, 0xa4, 0x00, 0x3d, 0x01, 0xe4, 0x44, 0x45, 0xeb, 0x0c, 0xb1, 0xe7, 0x71, 0x79, 0xe0, 0xae,
	0x64, 0x5e, 0x41, 0x5c, 0x5e, 0x63, 0x23, 0x16, 0x7a, 0x26, 0x65, 0xd0, 0x01, 0x6c, 0x06, 0x6e,
	0x48, 0xfb, 0x5d, 0x37, 0x74, 0xcc, 0x5f, 0x06, 0xe4, 0x85, 0x28, 0x73, 0x85, 0x63, 0x2b, 0xef,
	0x4a, 0xff, 0x8b, 0x02, 0x15, 0x5e, 0xa0, 0x17, 0x83, 0xd0, 0xb2, 0x1d, 0x54, 0x83, 0x82, 0x6d,
	0xca, 0x9a, 0x17, 0x6c, 0x93, 0x81, 0x8d, 0x38, 0xa6, 0xe7, 0xda, 0x0e, 0x95, 0x25, 0x8f, 0xcf,
	0xe8, 0x7b, 0xb0, 0x68, 0x3b, 0x17, 0x2e, 0x7f, 0x7a, 0x39, 0x9e, 0xc6, 0x50, 0x32, 0x38, 0x1b,
	0x83, 0x5d, 0x40, 0x31, 0x0d, 0x03, 0x8e, 0xf5, 0xb2, 0x21, 0x4f, 0xec, 0x39, 0x11, 0xdf, 0x77,
	0x7d, 0x09, 0x74, 0x71, 0xd0, 0xdf, 0xc2, 0xc6, 0x53, 0x3b, 0xa0, 0x5c, 0x49, 0x60, 0x90, 0xb7,
	0x21, 0x09, 0xa8, 0xc4, 0x5f, 0xd7, 0x0d, 0x04, 0x2c, 0x4b, 0x46, 0x74, 0x44, 0x5f, 0x44, 0xf8,
	0xe3, 0x98, 0x15, 0x9e, 0x0a, 0xb8, 0xf1, 0x37, 0xf3, 0x0d, 0xa8, 0x8a, 0xeb, 0x08, 0xbe, 0xa2,
	0x5d, 0xac, 0x72, 0xe2, 0xb9, 0xa0, 0xe9, 0x0e, 0xac, 0x19, 0xee, 0x60, 0xd0, 0xc5, 0xbd, 0x37,
	0x91, 0xc1, 0x5f, 0x43, 0x2d, 0x31, 0x49, 0x3a, 0x32, 0x35, 0x39, 0x08, 0x79, 0x39, 0xe1, 0x3a,
	0x3d, 0x3e, 0xbc, 0xf5, 0xfe, 0xc3, 0xde, 0xc2, 0xd5, 0x87, 0xbd, 0x6a, 0x8a, 0x6c, 0x54, 0x13,
	0xba, 0x4e, 0x4d, 0x1d, 0xc1, 0xfa, 0xc4, 0x5e, 0xe0, 0xb9, 0x4e, 0x40, 0xf4, 0xbf, 0x2b, 0xb0,
	0xf3, 0x94, 0xe0, 0x8b, 0x33, 0x32, 0x20, 0x9c, 0xef, 0x17, 0x21, 0xf1, 0xc7, 0x91, 0x3b, 0xdb,
	0xb0, 0x4c, 0xb1, 0x6f, 0x11, 0x1a, 0xbd, 0x68, 0x71, 0x62, 0x6f, 0x35, 0xee, 0x9c, 0x65, 0x83,
	0x7f, 0x27, 0xdf, 0x6a, 0x31, 0xfd, 0x56, 0xbf, 0x09, 0xd5, 0x20, 0x52, 0xcf, 0x10, 0x2c, 0xfb,
	0x63, 0x9a, 0x88, 0xee, 0x43, 0xb5, 0xd7, 0x67, 0x9d, 0xed, 0xc8, 0x75, 0x28, 0x79, 0x47, 0xf9,
	0x33, 0xac, 0xb4, 0xd7, 0x05, 0xa0, 0xcf, 0x08, 0x95, 0x4e, 0x19, 0x69, 0x36, 0xfd, 0x21, 0x68,
	0x79, 0x01, 0x88, 0xf8, 0x58, 0xdf, 0x8d, 0xcd, 0xa8, 0x0a, 0xef, 0x5e, 0x13, 0x02, 0xcb, 0xc8,
	0x04, 0x35, 0x42, 0xbd, 0xfe, 0x14, 0x36, 0x12, 0x34, 0xa9, 0xe6, 0xfb, 0x20, 0x8a, 0xcb, 0x88,
	0xb2, 0x24, 0x73, 0xf0, 0x37, 0xe1, 0xd5, 0xf7, 0xe1, 0xd6, 0x39, 0x1e, 0xd8, 0x26, 0xa6, 0xcc,
	0xe1, 0x0b, 0xdb, 0x8a, 0x52, 0x8b, 0x60, 0xf1, 0x77, 0x01, 0xf7, 0x49, 0x69, 0xae, 0x1a, 0xfc,
	0xfb, 0x61, 0x41, 0x55, 0xf4, 0x03, 0xd0, 0x72, 0x05, 0x8e, 0xfa, 0xa1, 0xf3, 0x26, 0x4f, 0x2a,
	0x2b, 0xc1, 0x59, 0xe7, 0xd8, 0xd1, 0x9f, 0xc0, 0xf6, 0xb4, 0x0d, 0x19, 0xe7, 0x16, 0x2c, 0x8d,
	0xd8, 0x8d, 0x84, 0xbb, 0x38, 0xb0, 0xd2, 0x0e, 0x49, 0x10, 0x60, 0x2b, 0xaa, 0x78, 0x74, 0xd4,
	0x4f, 0x60, 0x83, 0x15, 0x8f, 0x8f, 0xca, 0xf8, 0xd5, 0xd4, 0x01, 0x58, 0x73, 0x93, 0xcd, 0x40,
	0x20, 0x27, 0x41, 0x89, 0x5d, 0x2a, 0x24, 0x5c, 0x7a, 0x0e, 0x28, 0xa9, 0x48, 0xba, 0xf3, 0x40,
	0x68, 0x12, 0x54, 0x5e, 0xbe, 0x9c, 0xbc, 0xc7, 0x72, 0x46, 0x82, 0x59, 0xc7, 0x3c, 0xf1, 0x21,
	0x89, 0x71, 0x11, 0x79, 0x97, 0x41, 0xa3, 0x92, 0x87, 0xc6, 0x3a, 0x80, 0xb0, 0xf0, 0xd3, 0x89,
	0xa7, 0x09, 0x0a, 0x2f, 0x55, 0x97, 0x27, 0x3e, 0x6b, 0x42, 0x94, 0xea, 0xb3, 0xd8, 0xd1, 0xef,
	0xf3, 0x52, 0xa5, 0x6c, 0xdc, 0x08, 0xd9, 0x06, 0xdc, 0x3a, 0x21, 0x34, 0xd1, 0x0e, 0xa2, 0xf0,
	0x1f, 0xc4, 0x0d, 0xf7, 0xda, 0xae, 0x02, 0xb2, 0xab, 0x14, 0x4e, 0x8f, 0x59, 0x6f, 0xd6, 0x5f,
	0xc1, 0xf6, 0xb4, 0x4e, 0xe9, 0xcb, 0x8f, 0xa0, 0x92, 0x68, 0x35, 0x52, 0xfb, 0xee, 0x1c, 0xed,
	0x46, 0x92, 0x5f, 0xdf, 0x81, 0xdb, 0xac, 0xf7, 0x26, 0xee, 0x23, 0x2c, 0xe9, 0xbf, 0x02, 0x35,
	0x7b, 0xf5, 0x79, 0xac, 0xfe, 0x59, 0x01, 0xf5, 0x15, 0xa6, 0xbd, 0x7e, 0x8e, 0xdd, 0xff, 0x6b,
	0x23, 0x66, 0x43, 0xce, 0x71, 0x7d, 0xe2, 0x0d, 0xf0, 0x98, 0x97, 0xbc, 0x64, 0xc4, 0x67, 0xfd,
	0x37, 0xb0, 0x93, 0xe3, 0x94, 0x8c, 0xf8, 0x27, 0xb0, 0x44, 0x46, 0xc4, 0xa1, 0xd2, 0x99, 0xc6,
	0x1c, 0x67, 0x1e, 0x33, 0xbe, 0xc3, 0x12, 0xf3, 0xe7, 0xf2, 0xc3, 0x9e, 0x62, 0x08, 0x41, 0xfd,
	0x0f, 0x70, 0xfb, 0x84, 0xd0, 0xa3, 0xe4, 0x6f, 0x91, 0x28, 0xe4, 0x1e, 0xac, 0xa7, 0x7e, 0xa3,
	0x4c, 0x82, 0xce, 0xac, 0xdf, 0x29, 0xf9, 0xd3, 0xe3, 0xc3, 0xdb, 0x32, 0xec, 0xb5, 0xa9, 0x0b,
	0x63, 0x2d, 0xa5, 0xf1, 0xd4, 0xd4, 0x3b, 0xa0, 0x66, 0xed, 0xcb, 0xe8, 0x8e, 0xa0, 0x9a, 0x62,
	0x9f, 0x95, 0xf2, 0xb4, 0x74, 0x5a, 0x46, 0xdf, 0x85, 0x1d, 0x06, 0x98, 0x14, 0x4f, 0x8c, 0x26,
	0x0c, 0x5a, 0xde, 0xe5, 0xe7, 0xb4, 0xff, 0x57, 0x05, 0x34, 0x5e, 0xc0, 0x5c, 0x0f, 0xbe, 0x96,
	0x24, 0xcf, 0xc5, 0x17, 0x86, 0xdd, 0x5c, 0xf7, 0x64, 0x0e, 0x0e, 0xd3, 0x08, 0xd3, 0xe7, 0x3a,
	0x95, 0x8f, 0xb1, 0xf6, 0xdf, 0x0a, 0x80, 0x04, 0xdf, 0x23, 0xf6, 0x2b, 0xfd, 0x8c, 0xf8, 0x23,
	0xbb, 0x47, 0xd0, 0x6b, 0xd8, 0x62, 0xc9, 0x37, 0x88, 0x65, 0x07, 0x94, 0xf8, 0xc4, 0x14, 0xbb,
	0x16, 0xfa, 0x72, 0xda, 0x46, 0x66, 0x0f, 0xd3, 0x76, 0x73, 0x67, 0xad, 0x58, 0x21, 0x0f, 0x14,
	0xf4, 0x1a, 0x36, 0xa3, 0xc5, 0x26, 0xf1, 0x02, 0x50, 0xf6, 0x57, 0x63, 0x7a, 0xdb, 0xd2, 0x1a,
	0xb3, 0x19, 0x64, 0x3a, 0xde, 0x00, 0xca, 0x2e, 0x17, 0xe8, 0xab, 0x8c, 0xc7, 0xb3, 0x36, 0x28,
	0xed, 0xee, 0x4d, 0x58, 0x85, 0xb1, 0xf6, 0xa7, 0x45, 0x40, 0x89, 0xc0, 0xa2, 0xbc, 0x9d, 0xc1,
	0xea, 0x09, 0xa1, 0x93, 0x1f, 0x4a, 0x8d, 0xd9, 0x8b, 0x87, 0x34, 0xfa, 0xe5, 0x1c, 0x0e, 0x19,
	0x98, 0x09, 0xb5, 0xf4, 0x0a, 0x80, 0xbe, 0x95, 0xf3, 0xfb, 0x37, 0xbb, 0x86, 0x68, 0xdf, 0xbe,
	0x8e, 0x4d, 0x2e, 0x96, 0xc5, 0x3f, 0x16, 0x14, 0x34, 0x9c, 0xde, 0x7e, 0xf8, 0x68, 0x24, 0x26,
	0xba, 0x7b, 0x23, 0x63, 0x9c, 0xfb, 0xa6, 0x16, 0x9b, 0x0a, 0x3a, 0x87, 0xea, 0x09, 0xa1, 0x93,
	0x3d, 0x22, 0x0b, 0xad, 0xcc, 0xb2, 0xa2, 0xe9, 0xf3, 0x58, 0x64, 0xb2, 0x2c, 0xd8, 0x38, 0x21,
	0x34, 0x3d, 0x87, 0x73, 0xf3, 0x95, 0xdd, 0x05, 0x72, 0xbd, 0xcf, 0x19, 0xe7, 0x22, 0x5f, 0x1e,
	0xef, 0x8e, 0x69, 0x8e, 0x79, 0x29, 0x9b, 0xb1, 0x7b, 0xdc, 0xd4, 0x68, 0x53, 0x69, 0x5f, 0x16,
	0x00, 0x25, 0xde, 0x4c, 0x84, 0x39, 0x0c, 0xb5, 0xf4, 0xa8, 0xcf, 0x86, 0x9b, 0xbb, 0x5e, 0x64,
	0x2d, 0xe7, 0x6f, 0x0c, 0xfa, 0x02, 0xb2, 0x61, 0x7d, 0x7a, 0xb2, 0xa3, 0xef, 0xe4, 0xb5, 0x82,
	0x9c, 0xf1, 0xac, 0x35, 0xaf, 0x67, 0x8c, 0x0c, 0x1d, 0x28, 0x68, 0x00, 0x1b, 0x99, 0x99, 0x8a,
	0x32, 0x2a, 0x66, 0xed, 0x02, 0xda, 0x57, 0x37, 0xe0, 0x9c, 0x58, 0x6b, 0xff, 0xab, 0x00, 0x5b,
	0xa9, 0x36, 0x19, 0x25, 0xd5, 0x82, 0xf5, 0xe9, 0xd9, 0x97, 0x8d, 0x78, 0xc6, 0x74, 0xce, 0x46,
	0x3c, 0x6b, 0x8c, 0xea, 0x0b, 0xc8, 0x05, 0x94, 0x1d, 0x73, 0x39, 0x5d, 0x6b, 0xd6, 0x9c, 0xcc,
	0xe9, 0x5a, 0x33, 0xa7, 0x26, 0x4f, 0xb0, 0x0f, 0x9b, 0x39, 0x43, 0x25, 0x0b, 0xd9, 0xd9, 0x83,
	0x51, 0xfb, 0xee, 0x8d, 0x78, 0x27, 0x36, 0x0f, 0xd5, 0xf7, 0x57, 0x75, 0xe5, 0xf2, 0xaa, 0xae,
	0xfc, 0xf3, 0xaa, 0xae, 0xfc, 0xe9, 0x63, 0x7d, 0xe1, 0xf2, 0x63, 0x7d, 0xe1, 0x1f, 0x1f, 0xeb,
	0x0b, 0xdd, 0x65, 0xfe, 0xcf, 0xd5, 0x7b, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x7e, 0xe8, 0x4c,
	0x60, 0x34, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ConfigAdminServiceClient is the client API for ConfigAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConfigAdminServiceClient interface {
	// ListRegisteredModels returns a stream of registered models.
	ListRegisteredModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (ConfigAdminService_ListRegisteredModelsClient, error)
	// RollbackTransaction rolls back the specified configuration change transaction.
	RollbackTransaction(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error)
	// LeafSelectionQuery selects values allowable for leaf.
	// It supports the ROC GUI by supplying a list of valid leaf values based off an
	// XPath query defined in a 'leaf-selection' YANG extension
	// Calls on GetValueSelection RPC on Model Plugin
	LeafSelectionQuery(ctx context.Context, in *LeafSelectionQueryRequest, opts ...grpc.CallOption) (*LeafSelectionQueryResponse, error)
}

type configAdminServiceClient struct {
	cc *grpc.ClientConn
}

func NewConfigAdminServiceClient(cc *grpc.ClientConn) ConfigAdminServiceClient {
	return &configAdminServiceClient{cc}
}

func (c *configAdminServiceClient) ListRegisteredModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (ConfigAdminService_ListRegisteredModelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ConfigAdminService_serviceDesc.Streams[0], "/onos.config.v3.ConfigAdminService/ListRegisteredModels", opts...)
	if err != nil {
		return nil, err
	}
	x := &configAdminServiceListRegisteredModelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConfigAdminService_ListRegisteredModelsClient interface {
	Recv() (*ModelPlugin, error)
	grpc.ClientStream
}

type configAdminServiceListRegisteredModelsClient struct {
	grpc.ClientStream
}

func (x *configAdminServiceListRegisteredModelsClient) Recv() (*ModelPlugin, error) {
	m := new(ModelPlugin)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *configAdminServiceClient) RollbackTransaction(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error) {
	out := new(RollbackResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ConfigAdminService/RollbackTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configAdminServiceClient) LeafSelectionQuery(ctx context.Context, in *LeafSelectionQueryRequest, opts ...grpc.CallOption) (*LeafSelectionQueryResponse, error) {
	out := new(LeafSelectionQueryResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ConfigAdminService/LeafSelectionQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigAdminServiceServer is the server API for ConfigAdminService service.
type ConfigAdminServiceServer interface {
	// ListRegisteredModels returns a stream of registered models.
	ListRegisteredModels(*ListModelsRequest, ConfigAdminService_ListRegisteredModelsServer) error
	// RollbackTransaction rolls back the specified configuration change transaction.
	RollbackTransaction(context.Context, *RollbackRequest) (*RollbackResponse, error)
	// LeafSelectionQuery selects values allowable for leaf.
	// It supports the ROC GUI by supplying a list of valid leaf values based off an
	// XPath query defined in a 'leaf-selection' YANG extension
	// Calls on GetValueSelection RPC on Model Plugin
	LeafSelectionQuery(context.Context, *LeafSelectionQueryRequest) (*LeafSelectionQueryResponse, error)
}

// UnimplementedConfigAdminServiceServer can be embedded to have forward compatible implementations.
type UnimplementedConfigAdminServiceServer struct {
}

func (*UnimplementedConfigAdminServiceServer) ListRegisteredModels(req *ListModelsRequest, srv ConfigAdminService_ListRegisteredModelsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListRegisteredModels not implemented")
}
func (*UnimplementedConfigAdminServiceServer) RollbackTransaction(ctx context.Context, req *RollbackRequest) (*RollbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackTransaction not implemented")
}
func (*UnimplementedConfigAdminServiceServer) LeafSelectionQuery(ctx context.Context, req *LeafSelectionQueryRequest) (*LeafSelectionQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeafSelectionQuery not implemented")
}

func RegisterConfigAdminServiceServer(s *grpc.Server, srv ConfigAdminServiceServer) {
	s.RegisterService(&_ConfigAdminService_serviceDesc, srv)
}

func _ConfigAdminService_ListRegisteredModels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListModelsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConfigAdminServiceServer).ListRegisteredModels(m, &configAdminServiceListRegisteredModelsServer{stream})
}

type ConfigAdminService_ListRegisteredModelsServer interface {
	Send(*ModelPlugin) error
	grpc.ServerStream
}

type configAdminServiceListRegisteredModelsServer struct {
	grpc.ServerStream
}

func (x *configAdminServiceListRegisteredModelsServer) Send(m *ModelPlugin) error {
	return x.ServerStream.SendMsg(m)
}

func _ConfigAdminService_RollbackTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigAdminServiceServer).RollbackTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ConfigAdminService/RollbackTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigAdminServiceServer).RollbackTransaction(ctx, req.(*RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigAdminService_LeafSelectionQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeafSelectionQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigAdminServiceServer).LeafSelectionQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ConfigAdminService/LeafSelectionQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigAdminServiceServer).LeafSelectionQuery(ctx, req.(*LeafSelectionQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigAdminService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.config.v3.ConfigAdminService",
	HandlerType: (*ConfigAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RollbackTransaction",
			Handler:    _ConfigAdminService_RollbackTransaction_Handler,
		},
		{
			MethodName: "LeafSelectionQuery",
			Handler:    _ConfigAdminService_LeafSelectionQuery_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListRegisteredModels",
			Handler:       _ConfigAdminService_ListRegisteredModels_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/config/v3/admin.proto",
}

// ModelPluginServiceClient is the client API for ModelPluginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ModelPluginServiceClient interface {
	// GetModelInfo provides information about the model
	GetModelInfo(ctx context.Context, in *ModelInfoRequest, opts ...grpc.CallOption) (*ModelInfoResponse, error)
	// ValidateConfig validates the provided configuration data against the model
	ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error)
	// ValidateConfigChunked validates the provided configuration data against the model
	ValidateConfigChunked(ctx context.Context, opts ...grpc.CallOption) (ModelPluginService_ValidateConfigChunkedClient, error)
	// GetPathValues produces list of typed path value entries from the specified configuration change JSON tree
	GetPathValues(ctx context.Context, in *PathValuesRequest, opts ...grpc.CallOption) (*PathValuesResponse, error)
	// GetValueSelection gets a list of valid options for a leaf by applying selection rules in YANG.
	// Replaced by GetValueSelectionChunked
	GetValueSelection(ctx context.Context, in *ValueSelectionRequest, opts ...grpc.CallOption) (*ValueSelectionResponse, error)
	// GetValueSelectionChunked gets a list of valid options for a leaf by applying selection rules in YANG.
	// The selection rules should be defined as an XPath expression, as an argument
	// to a `leaf-selection` extension in the YANG model
	// (Used to support the ROC GUI)
	GetValueSelectionChunked(ctx context.Context, opts ...grpc.CallOption) (ModelPluginService_GetValueSelectionChunkedClient, error)
}

type modelPluginServiceClient struct {
	cc *grpc.ClientConn
}

func NewModelPluginServiceClient(cc *grpc.ClientConn) ModelPluginServiceClient {
	return &modelPluginServiceClient{cc}
}

func (c *modelPluginServiceClient) GetModelInfo(ctx context.Context, in *ModelInfoRequest, opts ...grpc.CallOption) (*ModelInfoResponse, error) {
	out := new(ModelInfoResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ModelPluginService/GetModelInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *modelPluginServiceClient) ValidateConfig(ctx context.Context, in *ValidateConfigRequest, opts ...grpc.CallOption) (*ValidateConfigResponse, error) {
	out := new(ValidateConfigResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ModelPluginService/ValidateConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPluginServiceClient) ValidateConfigChunked(ctx context.Context, opts ...grpc.CallOption) (ModelPluginService_ValidateConfigChunkedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ModelPluginService_serviceDesc.Streams[0], "/onos.config.v3.ModelPluginService/ValidateConfigChunked", opts...)
	if err != nil {
		return nil, err
	}
	x := &modelPluginServiceValidateConfigChunkedClient{stream}
	return x, nil
}

type ModelPluginService_ValidateConfigChunkedClient interface {
	Send(*ValidateConfigRequestChunk) error
	CloseAndRecv() (*ValidateConfigResponse, error)
	grpc.ClientStream
}

type modelPluginServiceValidateConfigChunkedClient struct {
	grpc.ClientStream
}

func (x *modelPluginServiceValidateConfigChunkedClient) Send(m *ValidateConfigRequestChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *modelPluginServiceValidateConfigChunkedClient) CloseAndRecv() (*ValidateConfigResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ValidateConfigResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *modelPluginServiceClient) GetPathValues(ctx context.Context, in *PathValuesRequest, opts ...grpc.CallOption) (*PathValuesResponse, error) {
	out := new(PathValuesResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ModelPluginService/GetPathValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *modelPluginServiceClient) GetValueSelection(ctx context.Context, in *ValueSelectionRequest, opts ...grpc.CallOption) (*ValueSelectionResponse, error) {
	out := new(ValueSelectionResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ModelPluginService/GetValueSelection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelPluginServiceClient) GetValueSelectionChunked(ctx context.Context, opts ...grpc.CallOption) (ModelPluginService_GetValueSelectionChunkedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ModelPluginService_serviceDesc.Streams[1], "/onos.config.v3.ModelPluginService/GetValueSelectionChunked", opts...)
	if err != nil {
		return nil, err
	}
	x := &modelPluginServiceGetValueSelectionChunkedClient{stream}
	return x, nil
}

type ModelPluginService_GetValueSelectionChunkedClient interface {
	Send(*ValueSelectionRequestChunk) error
	CloseAndRecv() (*ValueSelectionResponse, error)
	grpc.ClientStream
}

type modelPluginServiceGetValueSelectionChunkedClient struct {
	grpc.ClientStream
}

func (x *modelPluginServiceGetValueSelectionChunkedClient) Send(m *ValueSelectionRequestChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *modelPluginServiceGetValueSelectionChunkedClient) CloseAndRecv() (*ValueSelectionResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ValueSelectionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ModelPluginServiceServer is the server API for ModelPluginService service.
type ModelPluginServiceServer interface {
	// GetModelInfo provides information about the model
	GetModelInfo(context.Context, *ModelInfoRequest) (*ModelInfoResponse, error)
	// ValidateConfig validates the provided configuration data against the model
	ValidateConfig(context.Context, *ValidateConfigRequest) (*ValidateConfigResponse, error)
	// ValidateConfigChunked validates the provided configuration data against the model
	ValidateConfigChunked(ModelPluginService_ValidateConfigChunkedServer) error
	// GetPathValues produces list of typed path value entries from the specified configuration change JSON tree
	GetPathValues(context.Context, *PathValuesRequest) (*PathValuesResponse, error)
	// GetValueSelection gets a list of valid options for a leaf by applying selection rules in YANG.
	// Replaced by GetValueSelectionChunked
	GetValueSelection(context.Context, *ValueSelectionRequest) (*ValueSelectionResponse, error)
	// GetValueSelectionChunked gets a list of valid options for a leaf by applying selection rules in YANG.
	// The selection rules should be defined as an XPath expression, as an argument
	// to a `leaf-selection` extension in the YANG model
	// (Used to support the ROC GUI)
	GetValueSelectionChunked(ModelPluginService_GetValueSelectionChunkedServer) error
}

// UnimplementedModelPluginServiceServer can be embedded to have forward compatible implementations.
type UnimplementedModelPluginServiceServer struct {
}

func (*UnimplementedModelPluginServiceServer) GetModelInfo(ctx context.Context, req *ModelInfoRequest) (*ModelInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelInfo not implemented")
}
func (*UnimplementedModelPluginServiceServer) ValidateConfig(ctx context.Context, req *ValidateConfigRequest) (*ValidateConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateConfig not implemented")
}
func (*UnimplementedModelPluginServiceServer) ValidateConfigChunked(srv ModelPluginService_ValidateConfigChunkedServer) error {
	return status.Errorf(codes.Unimplemented, "method ValidateConfigChunked not implemented")
}
func (*UnimplementedModelPluginServiceServer) GetPathValues(ctx context.Context, req *PathValuesRequest) (*PathValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPathValues not implemented")
}
func (*UnimplementedModelPluginServiceServer) GetValueSelection(ctx context.Context, req *ValueSelectionRequest) (*ValueSelectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValueSelection not implemented")
}
func (*UnimplementedModelPluginServiceServer) GetValueSelectionChunked(srv ModelPluginService_GetValueSelectionChunkedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetValueSelectionChunked not implemented")
}

func RegisterModelPluginServiceServer(s *grpc.Server, srv ModelPluginServiceServer) {
	s.RegisterService(&_ModelPluginService_serviceDesc, srv)
}

func _ModelPluginService_GetModelInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModelInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPluginServiceServer).GetModelInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ModelPluginService/GetModelInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPluginServiceServer).GetModelInfo(ctx, req.(*ModelInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPluginService_ValidateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPluginServiceServer).ValidateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ModelPluginService/ValidateConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPluginServiceServer).ValidateConfig(ctx, req.(*ValidateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPluginService_ValidateConfigChunked_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ModelPluginServiceServer).ValidateConfigChunked(&modelPluginServiceValidateConfigChunkedServer{stream})
}

type ModelPluginService_ValidateConfigChunkedServer interface {
	SendAndClose(*ValidateConfigResponse) error
	Recv() (*ValidateConfigRequestChunk, error)
	grpc.ServerStream
}

type modelPluginServiceValidateConfigChunkedServer struct {
	grpc.ServerStream
}

func (x *modelPluginServiceValidateConfigChunkedServer) SendAndClose(m *ValidateConfigResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *modelPluginServiceValidateConfigChunkedServer) Recv() (*ValidateConfigRequestChunk, error) {
	m := new(ValidateConfigRequestChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ModelPluginService_GetPathValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPluginServiceServer).GetPathValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ModelPluginService/GetPathValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPluginServiceServer).GetPathValues(ctx, req.(*PathValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPluginService_GetValueSelection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValueSelectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelPluginServiceServer).GetValueSelection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ModelPluginService/GetValueSelection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelPluginServiceServer).GetValueSelection(ctx, req.(*ValueSelectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModelPluginService_GetValueSelectionChunked_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ModelPluginServiceServer).GetValueSelectionChunked(&modelPluginServiceGetValueSelectionChunkedServer{stream})
}

type ModelPluginService_GetValueSelectionChunkedServer interface {
	SendAndClose(*ValueSelectionResponse) error
	Recv() (*ValueSelectionRequestChunk, error)
	grpc.ServerStream
}

type modelPluginServiceGetValueSelectionChunkedServer struct {
	grpc.ServerStream
}

func (x *modelPluginServiceGetValueSelectionChunkedServer) SendAndClose(m *ValueSelectionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *modelPluginServiceGetValueSelectionChunkedServer) Recv() (*ValueSelectionRequestChunk, error) {
	m := new(ValueSelectionRequestChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ModelPluginService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.config.v3.ModelPluginService",
	HandlerType: (*ModelPluginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetModelInfo",
			Handler:    _ModelPluginService_GetModelInfo_Handler,
		},
		{
			MethodName: "ValidateConfig",
			Handler:    _ModelPluginService_ValidateConfig_Handler,
		},
		{
			MethodName: "GetPathValues",
			Handler:    _ModelPluginService_GetPathValues_Handler,
		},
		{
			MethodName: "GetValueSelection",
			Handler:    _ModelPluginService_GetValueSelection_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ValidateConfigChunked",
			Handler:       _ModelPluginService_ValidateConfigChunked_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetValueSelectionChunked",
			Handler:       _ModelPluginService_GetValueSelectionChunked_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "onos/config/v3/admin.proto",
}

// TransactionServiceClient is the client API for TransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TransactionServiceClient interface {
	// Get transaction by its ID or index
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// List returns all configuration transactions
	ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (TransactionService_ListTransactionsClient, error)
	// Watch returns a stream of configuration transaction change notifications
	WatchTransactions(ctx context.Context, in *WatchTransactionsRequest, opts ...grpc.CallOption) (TransactionService_WatchTransactionsClient, error)
}

type transactionServiceClient struct {
	cc *grpc.ClientConn
}

func NewTransactionServiceClient(cc *grpc.ClientConn) TransactionServiceClient {
	return &transactionServiceClient{cc}
}

func (c *transactionServiceClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.TransactionService/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (TransactionService_ListTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TransactionService_serviceDesc.Streams[0], "/onos.config.v3.TransactionService/ListTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServiceListTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionService_ListTransactionsClient interface {
	Recv() (*ListTransactionsResponse, error)
	grpc.ClientStream
}

type transactionServiceListTransactionsClient struct {
	grpc.ClientStream
}

func (x *transactionServiceListTransactionsClient) Recv() (*ListTransactionsResponse, error) {
	m := new(ListTransactionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *transactionServiceClient) WatchTransactions(ctx context.Context, in *WatchTransactionsRequest, opts ...grpc.CallOption) (TransactionService_WatchTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TransactionService_serviceDesc.Streams[1], "/onos.config.v3.TransactionService/WatchTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServiceWatchTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionService_WatchTransactionsClient interface {
	Recv() (*WatchTransactionsResponse, error)
	grpc.ClientStream
}

type transactionServiceWatchTransactionsClient struct {
	grpc.ClientStream
}

func (x *transactionServiceWatchTransactionsClient) Recv() (*WatchTransactionsResponse, error) {
	m := new(WatchTransactionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TransactionServiceServer is the server API for TransactionService service.
type TransactionServiceServer interface {
	// Get transaction by its ID or index
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	// List returns all configuration transactions
	ListTransactions(*ListTransactionsRequest, TransactionService_ListTransactionsServer) error
	// Watch returns a stream of configuration transaction change notifications
	WatchTransactions(*WatchTransactionsRequest, TransactionService_WatchTransactionsServer) error
}

// UnimplementedTransactionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedTransactionServiceServer struct {
}

func (*UnimplementedTransactionServiceServer) GetTransaction(ctx context.Context, req *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (*UnimplementedTransactionServiceServer) ListTransactions(req *ListTransactionsRequest, srv TransactionService_ListTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTransactions not implemented")
}
func (*UnimplementedTransactionServiceServer) WatchTransactions(req *WatchTransactionsRequest, srv TransactionService_WatchTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchTransactions not implemented")
}

func RegisterTransactionServiceServer(s *grpc.Server, srv TransactionServiceServer) {
	s.RegisterService(&_TransactionService_serviceDesc, srv)
}

func _TransactionService_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.TransactionService/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_ListTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransactionServiceServer).ListTransactions(m, &transactionServiceListTransactionsServer{stream})
}

type TransactionService_ListTransactionsServer interface {
	Send(*ListTransactionsResponse) error
	grpc.ServerStream
}

type transactionServiceListTransactionsServer struct {
	grpc.ServerStream
}

func (x *transactionServiceListTransactionsServer) Send(m *ListTransactionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _TransactionService_WatchTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransactionServiceServer).WatchTransactions(m, &transactionServiceWatchTransactionsServer{stream})
}

type TransactionService_WatchTransactionsServer interface {
	Send(*WatchTransactionsResponse) error
	grpc.ServerStream
}

type transactionServiceWatchTransactionsServer struct {
	grpc.ServerStream
}

func (x *transactionServiceWatchTransactionsServer) Send(m *WatchTransactionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _TransactionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.config.v3.TransactionService",
	HandlerType: (*TransactionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransaction",
			Handler:    _TransactionService_GetTransaction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListTransactions",
			Handler:       _TransactionService_ListTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchTransactions",
			Handler:       _TransactionService_WatchTransactions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/config/v3/admin.proto",
}

// ConfigurationServiceClient is the client API for ConfigurationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConfigurationServiceClient interface {
	// Get configuration by its target ID
	GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...grpc.CallOption) (*GetConfigurationResponse, error)
	// List returns all target configurations
	ListConfigurations(ctx context.Context, in *ListConfigurationsRequest, opts ...grpc.CallOption) (ConfigurationService_ListConfigurationsClient, error)
	// Watch returns a stream of configuration change notifications
	WatchConfigurations(ctx context.Context, in *WatchConfigurationsRequest, opts ...grpc.CallOption) (ConfigurationService_WatchConfigurationsClient, error)
}

type configurationServiceClient struct {
	cc *grpc.ClientConn
}

func NewConfigurationServiceClient(cc *grpc.ClientConn) ConfigurationServiceClient {
	return &configurationServiceClient{cc}
}

func (c *configurationServiceClient) GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...grpc.CallOption) (*GetConfigurationResponse, error) {
	out := new(GetConfigurationResponse)
	err := c.cc.Invoke(ctx, "/onos.config.v3.ConfigurationService/GetConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configurationServiceClient) ListConfigurations(ctx context.Context, in *ListConfigurationsRequest, opts ...grpc.CallOption) (ConfigurationService_ListConfigurationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ConfigurationService_serviceDesc.Streams[0], "/onos.config.v3.ConfigurationService/ListConfigurations", opts...)
	if err != nil {
		return nil, err
	}
	x := &configurationServiceListConfigurationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConfigurationService_ListConfigurationsClient interface {
	Recv() (*ListConfigurationsResponse, error)
	grpc.ClientStream
}

type configurationServiceListConfigurationsClient struct {
	grpc.ClientStream
}

func (x *configurationServiceListConfigurationsClient) Recv() (*ListConfigurationsResponse, error) {
	m := new(ListConfigurationsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *configurationServiceClient) WatchConfigurations(ctx context.Context, in *WatchConfigurationsRequest, opts ...grpc.CallOption) (ConfigurationService_WatchConfigurationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ConfigurationService_serviceDesc.Streams[1], "/onos.config.v3.ConfigurationService/WatchConfigurations", opts...)
	if err != nil {
		return nil, err
	}
	x := &configurationServiceWatchConfigurationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConfigurationService_WatchConfigurationsClient interface {
	Recv() (*WatchConfigurationsResponse, error)
	grpc.ClientStream
}

type configurationServiceWatchConfigurationsClient struct {
	grpc.ClientStream
}

func (x *configurationServiceWatchConfigurationsClient) Recv() (*WatchConfigurationsResponse, error) {
	m := new(WatchConfigurationsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConfigurationServiceServer is the server API for ConfigurationService service.
type ConfigurationServiceServer interface {
	// Get configuration by its target ID
	GetConfiguration(context.Context, *GetConfigurationRequest) (*GetConfigurationResponse, error)
	// List returns all target configurations
	ListConfigurations(*ListConfigurationsRequest, ConfigurationService_ListConfigurationsServer) error
	// Watch returns a stream of configuration change notifications
	WatchConfigurations(*WatchConfigurationsRequest, ConfigurationService_WatchConfigurationsServer) error
}

// UnimplementedConfigurationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedConfigurationServiceServer struct {
}

func (*UnimplementedConfigurationServiceServer) GetConfiguration(ctx context.Context, req *GetConfigurationRequest) (*GetConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfiguration not implemented")
}
func (*UnimplementedConfigurationServiceServer) ListConfigurations(req *ListConfigurationsRequest, srv ConfigurationService_ListConfigurationsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListConfigurations not implemented")
}
func (*UnimplementedConfigurationServiceServer) WatchConfigurations(req *WatchConfigurationsRequest, srv ConfigurationService_WatchConfigurationsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchConfigurations not implemented")
}

func RegisterConfigurationServiceServer(s *grpc.Server, srv ConfigurationServiceServer) {
	s.RegisterService(&_ConfigurationService_serviceDesc, srv)
}

func _ConfigurationService_GetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigurationServiceServer).GetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.config.v3.ConfigurationService/GetConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigurationServiceServer).GetConfiguration(ctx, req.(*GetConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigurationService_ListConfigurations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListConfigurationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConfigurationServiceServer).ListConfigurations(m, &configurationServiceListConfigurationsServer{stream})
}

type ConfigurationService_ListConfigurationsServer interface {
	Send(*ListConfigurationsResponse) error
	grpc.ServerStream
}

type configurationServiceListConfigurationsServer struct {
	grpc.ServerStream
}

func (x *configurationServiceListConfigurationsServer) Send(m *ListConfigurationsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ConfigurationService_WatchConfigurations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchConfigurationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConfigurationServiceServer).WatchConfigurations(m, &configurationServiceWatchConfigurationsServer{stream})
}

type ConfigurationService_WatchConfigurationsServer interface {
	Send(*WatchConfigurationsResponse) error
	grpc.ServerStream
}

type configurationServiceWatchConfigurationsServer struct {
	grpc.ServerStream
}

func (x *configurationServiceWatchConfigurationsServer) Send(m *WatchConfigurationsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ConfigurationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.config.v3.ConfigurationService",
	HandlerType: (*ConfigurationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfiguration",
			Handler:    _ConfigurationService_GetConfiguration_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListConfigurations",
			Handler:       _ConfigurationService_ListConfigurations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchConfigurations",
			Handler:       _ConfigurationService_WatchConfigurations_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/config/v3/admin.proto",
}

func (m *ReadOnlySubPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadOnlySubPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadOnlySubPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttrName) > 0 {
		i -= len(m.AttrName)
		copy(dAtA[i:], m.AttrName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.AttrName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsAKey {
		i--
		if m.IsAKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Units) > 0 {
		i -= len(m.Units)
		copy(dAtA[i:], m.Units)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Units)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TypeOpts) > 0 {
		dAtA2 := make([]byte, len(m.TypeOpts)*10)
		var j1 int
		for _, num := range m.TypeOpts {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintAdmin(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.ValueType != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SubPath) > 0 {
		i -= len(m.SubPath)
		copy(dAtA[i:], m.SubPath)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SubPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadOnlyPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadOnlyPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadOnlyPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubPath) > 0 {
		for iNdEx := len(m.SubPath) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubPath[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadWritePath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadWritePath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadWritePath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Defaults) > 0 {
		for iNdEx := len(m.Defaults) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Defaults[iNdEx])
			copy(dAtA[i:], m.Defaults[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Defaults[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AttrName) > 0 {
		i -= len(m.AttrName)
		copy(dAtA[i:], m.AttrName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.AttrName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IsAKey {
		i--
		if m.IsAKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.TypeOpts) > 0 {
		dAtA4 := make([]byte, len(m.TypeOpts)*10)
		var j3 int
		for _, num := range m.TypeOpts {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintAdmin(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Length) > 0 {
		for iNdEx := len(m.Length) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Length[iNdEx])
			copy(dAtA[i:], m.Length[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Length[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Range) > 0 {
		for iNdEx := len(m.Range) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Range[iNdEx])
			copy(dAtA[i:], m.Range[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Range[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Default) > 0 {
		i -= len(m.Default)
		copy(dAtA[i:], m.Default)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Default)))
		i--
		dAtA[i] = 0x32
	}
	if m.Mandatory {
		i--
		if m.Mandatory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Units) > 0 {
		i -= len(m.Units)
		copy(dAtA[i:], m.Units)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Units)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ValueType != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ValueType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SouthboundUsePrefix {
		i--
		if m.SouthboundUsePrefix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.NamespaceMappings) > 0 {
		for iNdEx := len(m.NamespaceMappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NamespaceMappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.SupportedEncodings) > 0 {
		dAtA6 := make([]byte, len(m.SupportedEncodings)*10)
		var j5 int
		for _, num := range m.SupportedEncodings {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintAdmin(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ReadWritePath) > 0 {
		for iNdEx := len(m.ReadWritePath) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReadWritePath[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ReadOnlyPath) > 0 {
		for iNdEx := len(m.ReadOnlyPath) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReadOnlyPath[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.GetStateMode != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.GetStateMode))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModelData) > 0 {
		for iNdEx := len(m.ModelData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ModelData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelPlugin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelPlugin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelPlugin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x52
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListModelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListModelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListModelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelName) > 0 {
		i -= len(m.ModelName)
		copy(dAtA[i:], m.ModelName)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ModelName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Verbose {
		i--
		if m.Verbose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RollbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RollbackRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TransactionID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RollbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RollbackResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LeafSelectionQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafSelectionQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafSelectionQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChangeContext != nil {
		{
			size, err := m.ChangeContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SelectionPath) > 0 {
		i -= len(m.SelectionPath)
		copy(dAtA[i:], m.SelectionPath)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SelectionPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeafSelectionQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafSelectionQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafSelectionQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Selection) > 0 {
		for iNdEx := len(m.Selection) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Selection[iNdEx])
			copy(dAtA[i:], m.Selection[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Selection[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ModelInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateConfigRequestChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateConfigRequestChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateConfigRequestChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateConfigChunkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateConfigChunkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateConfigChunkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PathValuesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathValuesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathValuesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PathPrefix) > 0 {
		i -= len(m.PathPrefix)
		copy(dAtA[i:], m.PathPrefix)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.PathPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathValuesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathValuesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathValuesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PathValues) > 0 {
		for iNdEx := len(m.PathValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PathValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueSelectionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueSelectionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueSelectionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SelectionPath) > 0 {
		i -= len(m.SelectionPath)
		copy(dAtA[i:], m.SelectionPath)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SelectionPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueSelectionRequestChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueSelectionRequestChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueSelectionRequestChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConfigJson) > 0 {
		i -= len(m.ConfigJson)
		copy(dAtA[i:], m.ConfigJson)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.ConfigJson)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SelectionPath) > 0 {
		i -= len(m.SelectionPath)
		copy(dAtA[i:], m.SelectionPath)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.SelectionPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueSelectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueSelectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueSelectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Selection) > 0 {
		for iNdEx := len(m.Selection) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Selection[iNdEx])
			copy(dAtA[i:], m.Selection[iNdEx])
			i = encodeVarintAdmin(dAtA, i, uint64(len(m.Selection[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		{
			size, err := m.Transaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTransactionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListTransactionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTransactionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Transaction != nil {
		{
			size, err := m.Transaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatchTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchTransactionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Noreplay {
		i--
		if m.Noreplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.TransactionID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WatchTransactionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchTransactionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TransactionEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ConfigurationID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListConfigurationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListConfigurationsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListConfigurationsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListConfigurationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListConfigurationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListConfigurationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatchConfigurationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchConfigurationsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchConfigurationsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Noreplay {
		i--
		if m.Noreplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ConfigurationID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WatchConfigurationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchConfigurationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchConfigurationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ConfigurationEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintAdmin(dAtA []byte, offset int, v uint64) int {
	offset -= sovAdmin(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReadOnlySubPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovAdmin(uint64(m.ValueType))
	}
	if len(m.TypeOpts) > 0 {
		l = 0
		for _, e := range m.TypeOpts {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Units)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.IsAKey {
		n += 2
	}
	l = len(m.AttrName)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ReadOnlyPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.SubPath) > 0 {
		for _, e := range m.SubPath {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *ReadWritePath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.ValueType != 0 {
		n += 1 + sovAdmin(uint64(m.ValueType))
	}
	l = len(m.Units)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Mandatory {
		n += 2
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Range) > 0 {
		for _, s := range m.Range {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Length) > 0 {
		for _, s := range m.Length {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.TypeOpts) > 0 {
		l = 0
		for _, e := range m.TypeOpts {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if m.IsAKey {
		n += 2
	}
	l = len(m.AttrName)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Defaults) > 0 {
		for _, s := range m.Defaults {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.ModelData) > 0 {
		for _, e := range m.ModelData {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.GetStateMode != 0 {
		n += 1 + sovAdmin(uint64(m.GetStateMode))
	}
	if len(m.ReadOnlyPath) > 0 {
		for _, e := range m.ReadOnlyPath {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.ReadWritePath) > 0 {
		for _, e := range m.ReadWritePath {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.SupportedEncodings) > 0 {
		l = 0
		for _, e := range m.SupportedEncodings {
			l += sovAdmin(uint64(e))
		}
		n += 1 + sovAdmin(uint64(l)) + l
	}
	if len(m.NamespaceMappings) > 0 {
		for _, e := range m.NamespaceMappings {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.SouthboundUsePrefix {
		n += 2
	}
	return n
}

func (m *ModelPlugin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListModelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Verbose {
		n += 2
	}
	l = len(m.ModelName)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *RollbackRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TransactionID.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *RollbackResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LeafSelectionQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.SelectionPath)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.ChangeContext != nil {
		l = m.ChangeContext.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *LeafSelectionQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Selection) > 0 {
		for _, s := range m.Selection {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *ModelInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ModelInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ValidateConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ValidateConfigRequestChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ValidateConfigChunkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ValidateConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Valid {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *PathValuesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathPrefix)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *PathValuesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PathValues) > 0 {
		for _, e := range m.PathValues {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *ValueSelectionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SelectionPath)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ValueSelectionRequestChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SelectionPath)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.ConfigJson)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ValueSelectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Selection) > 0 {
		for _, s := range m.Selection {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *GetTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *GetTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *WatchTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TransactionID.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if m.Noreplay {
		n += 2
	}
	return n
}

func (m *WatchTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TransactionEvent.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *GetConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ConfigurationID.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *GetConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListConfigurationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListConfigurationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *WatchConfigurationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ConfigurationID.Size()
	n += 1 + l + sovAdmin(uint64(l))
	if m.Noreplay {
		n += 2
	}
	return n
}

func (m *WatchConfigurationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ConfigurationEvent.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func sovAdmin(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAdmin(x uint64) (n int) {
	return sovAdmin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReadOnlySubPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadOnlySubPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadOnlySubPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= ValueType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TypeOpts = append(m.TypeOpts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TypeOpts) == 0 {
					m.TypeOpts = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TypeOpts = append(m.TypeOpts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeOpts", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAKey = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadOnlyPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadOnlyPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadOnlyPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = append(m.SubPath, &ReadOnlySubPath{})
			if err := m.SubPath[len(m.SubPath)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadWritePath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadWritePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadWritePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			m.ValueType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueType |= ValueType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mandatory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mandatory = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Range = append(m.Range, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Length = append(m.Length, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TypeOpts = append(m.TypeOpts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TypeOpts) == 0 {
					m.TypeOpts = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TypeOpts = append(m.TypeOpts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeOpts", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAKey = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defaults", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defaults = append(m.Defaults, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelData = append(m.ModelData, &gnmi.ModelData{})
			if err := m.ModelData[len(m.ModelData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStateMode", wireType)
			}
			m.GetStateMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetStateMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadOnlyPath = append(m.ReadOnlyPath, &ReadOnlyPath{})
			if err := m.ReadOnlyPath[len(m.ReadOnlyPath)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadWritePath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadWritePath = append(m.ReadWritePath, &ReadWritePath{})
			if err := m.ReadWritePath[len(m.ReadWritePath)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v gnmi.Encoding
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= gnmi.Encoding(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedEncodings = append(m.SupportedEncodings, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdmin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAdmin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SupportedEncodings) == 0 {
					m.SupportedEncodings = make([]gnmi.Encoding, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v gnmi.Encoding
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= gnmi.Encoding(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedEncodings = append(m.SupportedEncodings, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedEncodings", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceMappings = append(m.NamespaceMappings, &Namespace{})
			if err := m.NamespaceMappings[len(m.NamespaceMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SouthboundUsePrefix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SouthboundUsePrefix = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelPlugin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelPlugin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelPlugin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ModelInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListModelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListModelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListModelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verbose = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TransactionID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafSelectionQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafSelectionQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafSelectionQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectionPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectionPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeContext == nil {
				m.ChangeContext = &gnmi.SetRequest{}
			}
			if err := m.ChangeContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafSelectionQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafSelectionQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafSelectionQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selection = append(m.Selection, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = append(m.Json[:0], dAtA[iNdEx:postIndex]...)
			if m.Json == nil {
				m.Json = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateConfigRequestChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateConfigRequestChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateConfigRequestChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = append(m.Json[:0], dAtA[iNdEx:postIndex]...)
			if m.Json == nil {
				m.Json = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateConfigChunkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateConfigChunkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateConfigChunkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = append(m.Json[:0], dAtA[iNdEx:postIndex]...)
			if m.Json == nil {
				m.Json = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathValuesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathValuesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathValuesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = append(m.Json[:0], dAtA[iNdEx:postIndex]...)
			if m.Json == nil {
				m.Json = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathValuesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathValuesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathValuesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathValues = append(m.PathValues, &PathValue{})
			if err := m.PathValues[len(m.PathValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueSelectionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueSelectionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueSelectionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectionPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectionPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = append(m.ConfigJson[:0], dAtA[iNdEx:postIndex]...)
			if m.ConfigJson == nil {
				m.ConfigJson = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueSelectionRequestChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueSelectionRequestChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueSelectionRequestChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectionPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectionPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigJson = append(m.ConfigJson[:0], dAtA[iNdEx:postIndex]...)
			if m.ConfigJson == nil {
				m.ConfigJson = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueSelectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueSelectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueSelectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selection = append(m.Selection, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTransactionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTransactionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTransactionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TransactionID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noreplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Noreplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchTransactionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchTransactionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchTransactionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TransactionEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfigurationID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &Configuration{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListConfigurationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListConfigurationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListConfigurationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListConfigurationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListConfigurationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListConfigurationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &Configuration{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchConfigurationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchConfigurationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchConfigurationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfigurationID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noreplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Noreplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchConfigurationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchConfigurationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchConfigurationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfigurationEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdmin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdmin
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAdmin
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAdmin
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAdmin        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdmin          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAdmin = fmt.Errorf("proto: unexpected end of group")
)
