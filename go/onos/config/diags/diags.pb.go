// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/config/diags/diags.proto

package diags

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	admin "onos/config/admin"
	device "onos/config/change/device"
	network "onos/config/change/network"
	onos_config_change_network "onos/config/change/network"
	onos_config_device "onos/config/device"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Change (Network or Device) event type
type Type int32

const (
	// NONE indicates this response does not represent a modification of the Change
	Type_NONE Type = 0
	// ADDED is an event which occurs when a Change is added to the topology
	Type_ADDED Type = 1
	// UPDATED is an event which occurs when a Change is updated
	Type_UPDATED Type = 2
	// REMOVED is an event which occurs when a Change is removed from the configuration
	Type_REMOVED Type = 3
)

var Type_name = map[int32]string{
	0: "NONE",
	1: "ADDED",
	2: "UPDATED",
	3: "REMOVED",
}

var Type_value = map[string]int32{
	"NONE":    0,
	"ADDED":   1,
	"UPDATED": 2,
	"REMOVED": 3,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{0}
}

// OpStateRequest is a message for specifying GetOpState query parameters.
type OpStateRequest struct {
	// The request is always in the context of a Device ID. If the device does
	// not exist or is disconnected an error will be returned.
	DeviceId string `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	// subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and REMOVE) that occur
	// after all paths for the device have been streamed to the client
	Subscribe bool `protobuf:"varint,2,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
}

func (m *OpStateRequest) Reset()         { *m = OpStateRequest{} }
func (m *OpStateRequest) String() string { return proto.CompactTextString(m) }
func (*OpStateRequest) ProtoMessage()    {}
func (*OpStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{0}
}
func (m *OpStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpStateRequest.Merge(m, src)
}
func (m *OpStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *OpStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpStateRequest proto.InternalMessageInfo

func (m *OpStateRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *OpStateRequest) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

type OpStateResponse struct {
	// type is the type of the event
	Type admin.Type `protobuf:"varint,1,opt,name=type,proto3,enum=onos.config.admin.Type" json:"type,omitempty"`
	// device is the device on which the event occurred
	Pathvalue *device.PathValue `protobuf:"bytes,2,opt,name=pathvalue,proto3" json:"pathvalue,omitempty"`
}

func (m *OpStateResponse) Reset()         { *m = OpStateResponse{} }
func (m *OpStateResponse) String() string { return proto.CompactTextString(m) }
func (*OpStateResponse) ProtoMessage()    {}
func (*OpStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{1}
}
func (m *OpStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpStateResponse.Merge(m, src)
}
func (m *OpStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *OpStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OpStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OpStateResponse proto.InternalMessageInfo

func (m *OpStateResponse) GetType() admin.Type {
	if m != nil {
		return m.Type
	}
	return admin.Type_NONE
}

func (m *OpStateResponse) GetPathvalue() *device.PathValue {
	if m != nil {
		return m.Pathvalue
	}
	return nil
}

// ListNetworkChangeRequest requests a stream of changes and updates to them
// By default, the request requests a stream of all changes that are present in the topology when
// the request is received by the service. However, if `subscribe` is `true`, the stream will remain
// open after all changes have been sent and events that occur following the last changes will be
// streamed to the client until the stream is closed.
// If "withoutReplay" is true then only changes that happen after the call will be returned
type ListNetworkChangeRequest struct {
	// subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and REMOVE) that occur
	// after all devices have been streamed to the client
	Subscribe bool `protobuf:"varint,1,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
	// option to specify a specific network change - if blank or '*' then select all
	// Can support `*` (match many chars) or '?' (match one char) as wildcard
	ChangeID onos_config_change_network.ID `protobuf:"bytes,2,opt,name=changeid,proto3,casttype=onos/config/change/network.ID" json:"changeid,omitempty"`
	// option to request only changes that happen after the call
	WithoutReplay bool `protobuf:"varint,3,opt,name=withoutReplay,proto3" json:"withoutReplay,omitempty"`
}

func (m *ListNetworkChangeRequest) Reset()         { *m = ListNetworkChangeRequest{} }
func (m *ListNetworkChangeRequest) String() string { return proto.CompactTextString(m) }
func (*ListNetworkChangeRequest) ProtoMessage()    {}
func (*ListNetworkChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{2}
}
func (m *ListNetworkChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNetworkChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNetworkChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNetworkChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNetworkChangeRequest.Merge(m, src)
}
func (m *ListNetworkChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNetworkChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNetworkChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNetworkChangeRequest proto.InternalMessageInfo

func (m *ListNetworkChangeRequest) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

func (m *ListNetworkChangeRequest) GetChangeID() onos_config_change_network.ID {
	if m != nil {
		return m.ChangeID
	}
	return ""
}

func (m *ListNetworkChangeRequest) GetWithoutReplay() bool {
	if m != nil {
		return m.WithoutReplay
	}
	return false
}

// ListNetworkChangeResponse carries a single network change event
type ListNetworkChangeResponse struct {
	// change is the network change on which the event occurred
	Change *network.NetworkChange `protobuf:"bytes,1,opt,name=change,proto3" json:"change,omitempty"`
	// type is a qualification of the type of change being made
	Type Type `protobuf:"varint,2,opt,name=type,proto3,enum=onos.config.diags.Type" json:"type,omitempty"`
}

func (m *ListNetworkChangeResponse) Reset()         { *m = ListNetworkChangeResponse{} }
func (m *ListNetworkChangeResponse) String() string { return proto.CompactTextString(m) }
func (*ListNetworkChangeResponse) ProtoMessage()    {}
func (*ListNetworkChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{3}
}
func (m *ListNetworkChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNetworkChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNetworkChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNetworkChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNetworkChangeResponse.Merge(m, src)
}
func (m *ListNetworkChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListNetworkChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNetworkChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListNetworkChangeResponse proto.InternalMessageInfo

func (m *ListNetworkChangeResponse) GetChange() *network.NetworkChange {
	if m != nil {
		return m.Change
	}
	return nil
}

func (m *ListNetworkChangeResponse) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NONE
}

// ListDeviceChangeRequest requests a stream of changes and updates to them
// By default, the request requests a stream of all changes that are present in the topology when
// the request is received by the service. However, if `subscribe` is `true`, the stream will remain
// open after all changes have been sent and events that occur following the last changes will be
// streamed to the client until the stream is closed.
// If "withoutReplay" is true then only changes that happen after the call will be returned
type ListDeviceChangeRequest struct {
	// subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and REMOVE) that occur
	// after all devices have been streamed to the client
	Subscribe bool `protobuf:"varint,1,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
	// option to specify a specific device change - if blank or '*' then select all
	// Can support `*` (match many chars) or '?' (match one char) as wildcard
	DeviceID onos_config_device.ID `protobuf:"bytes,2,opt,name=device_id,json=deviceId,proto3,casttype=onos/config/device.ID" json:"device_id,omitempty"`
	// device_version is an optional device version
	DeviceVersion onos_config_device.Version `protobuf:"bytes,3,opt,name=device_version,json=deviceVersion,proto3,casttype=onos/config/device.Version" json:"device_version,omitempty"`
	// option to request only changes that happen after the call
	WithoutReplay bool `protobuf:"varint,4,opt,name=withoutReplay,proto3" json:"withoutReplay,omitempty"`
}

func (m *ListDeviceChangeRequest) Reset()         { *m = ListDeviceChangeRequest{} }
func (m *ListDeviceChangeRequest) String() string { return proto.CompactTextString(m) }
func (*ListDeviceChangeRequest) ProtoMessage()    {}
func (*ListDeviceChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{4}
}
func (m *ListDeviceChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDeviceChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDeviceChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDeviceChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDeviceChangeRequest.Merge(m, src)
}
func (m *ListDeviceChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDeviceChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDeviceChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDeviceChangeRequest proto.InternalMessageInfo

func (m *ListDeviceChangeRequest) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

func (m *ListDeviceChangeRequest) GetDeviceID() onos_config_device.ID {
	if m != nil {
		return m.DeviceID
	}
	return ""
}

func (m *ListDeviceChangeRequest) GetDeviceVersion() onos_config_device.Version {
	if m != nil {
		return m.DeviceVersion
	}
	return ""
}

func (m *ListDeviceChangeRequest) GetWithoutReplay() bool {
	if m != nil {
		return m.WithoutReplay
	}
	return false
}

// ListDeviceChangeResponse carries a single network change event
type ListDeviceChangeResponse struct {
	// change is the device change on which the event occurred
	Change *device.DeviceChange `protobuf:"bytes,1,opt,name=change,proto3" json:"change,omitempty"`
	// type is a qualification of the type of change being made
	Type Type `protobuf:"varint,2,opt,name=type,proto3,enum=onos.config.diags.Type" json:"type,omitempty"`
}

func (m *ListDeviceChangeResponse) Reset()         { *m = ListDeviceChangeResponse{} }
func (m *ListDeviceChangeResponse) String() string { return proto.CompactTextString(m) }
func (*ListDeviceChangeResponse) ProtoMessage()    {}
func (*ListDeviceChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33a12a4c5a708a34, []int{5}
}
func (m *ListDeviceChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDeviceChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDeviceChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDeviceChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDeviceChangeResponse.Merge(m, src)
}
func (m *ListDeviceChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListDeviceChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDeviceChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDeviceChangeResponse proto.InternalMessageInfo

func (m *ListDeviceChangeResponse) GetChange() *device.DeviceChange {
	if m != nil {
		return m.Change
	}
	return nil
}

func (m *ListDeviceChangeResponse) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NONE
}

func init() {
	proto.RegisterEnum("onos.config.diags.Type", Type_name, Type_value)
	proto.RegisterType((*OpStateRequest)(nil), "onos.config.diags.OpStateRequest")
	proto.RegisterType((*OpStateResponse)(nil), "onos.config.diags.OpStateResponse")
	proto.RegisterType((*ListNetworkChangeRequest)(nil), "onos.config.diags.ListNetworkChangeRequest")
	proto.RegisterType((*ListNetworkChangeResponse)(nil), "onos.config.diags.ListNetworkChangeResponse")
	proto.RegisterType((*ListDeviceChangeRequest)(nil), "onos.config.diags.ListDeviceChangeRequest")
	proto.RegisterType((*ListDeviceChangeResponse)(nil), "onos.config.diags.ListDeviceChangeResponse")
}

func init() { proto.RegisterFile("onos/config/diags/diags.proto", fileDescriptor_33a12a4c5a708a34) }

var fileDescriptor_33a12a4c5a708a34 = []byte{
	// 623 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x41, 0x73, 0xd2, 0x40,
	0x14, 0xc7, 0xd9, 0x16, 0x2b, 0x79, 0x08, 0xd2, 0x1d, 0x9d, 0x62, 0xc6, 0x86, 0x9a, 0x69, 0xb5,
	0x16, 0x0d, 0x1d, 0x1c, 0xcf, 0x0e, 0x98, 0x8c, 0x83, 0xa3, 0xd0, 0x49, 0x5b, 0xae, 0x4e, 0x80,
	0x15, 0x32, 0xd6, 0x24, 0xb2, 0x0b, 0x1d, 0xae, 0x9e, 0x9c, 0xf1, 0xe2, 0xd7, 0xf0, 0x9b, 0x78,
	0xec, 0xd1, 0x13, 0xe3, 0xc0, 0xc5, 0x4f, 0xe0, 0xa1, 0x27, 0x27, 0xbb, 0x69, 0x20, 0x34, 0x74,
	0xaa, 0x97, 0x4c, 0x76, 0xdf, 0x7b, 0xff, 0xff, 0xdb, 0x5f, 0x5e, 0x16, 0x36, 0x5d, 0xc7, 0xa5,
	0xa5, 0xb6, 0xeb, 0xbc, 0xb7, 0xbb, 0xa5, 0x8e, 0x6d, 0x75, 0xa9, 0x78, 0x6a, 0x5e, 0xdf, 0x65,
	0x2e, 0x5e, 0xf7, 0xc3, 0x9a, 0x08, 0x6b, 0x3c, 0x20, 0xdf, 0xe9, 0xba, 0x5d, 0x97, 0x47, 0x4b,
	0xfe, 0x9b, 0x48, 0x94, 0x23, 0x3a, 0x56, 0xe7, 0xa3, 0xed, 0x88, 0x67, 0x10, 0xde, 0x99, 0x0f,
	0xb7, 0x7b, 0x96, 0xd3, 0x25, 0xa5, 0x0e, 0x19, 0xda, 0x6d, 0x52, 0x62, 0x23, 0x8f, 0x04, 0x76,
	0xf2, 0xc3, 0x98, 0x34, 0x87, 0xb0, 0x53, 0xb7, 0xff, 0x61, 0x3e, 0x4f, 0x7d, 0x0d, 0xd9, 0x86,
	0x77, 0xc8, 0x2c, 0x46, 0x4c, 0xf2, 0x69, 0x40, 0x28, 0xc3, 0x32, 0xa4, 0x84, 0x5e, 0xad, 0x93,
	0x47, 0x5b, 0x68, 0x57, 0x32, 0xc3, 0x35, 0xbe, 0x0f, 0x12, 0x1d, 0xb4, 0x68, 0xbb, 0x6f, 0xb7,
	0x48, 0x7e, 0x65, 0x0b, 0xed, 0xa6, 0xcc, 0xd9, 0x86, 0xfa, 0x19, 0xc1, 0xed, 0x50, 0x8c, 0x7a,
	0xae, 0x43, 0x09, 0x2e, 0x42, 0xd2, 0xb7, 0xe3, 0x4a, 0xd9, 0xf2, 0x86, 0x36, 0x4f, 0x41, 0x1c,
	0xeb, 0x68, 0xe4, 0x11, 0x93, 0x27, 0xe1, 0x2a, 0x48, 0x9e, 0xc5, 0x7a, 0x43, 0xeb, 0x64, 0x20,
	0xe4, 0xd3, 0xe5, 0xed, 0x48, 0x85, 0x38, 0x88, 0x26, 0xfa, 0xd1, 0x0e, 0x2c, 0xd6, 0x6b, 0xfa,
	0xb9, 0xe6, 0xac, 0x4c, 0xfd, 0x8e, 0x20, 0xff, 0xc6, 0xa6, 0xac, 0x2e, 0x0e, 0xfb, 0x92, 0x57,
	0x5c, 0x9c, 0x2d, 0xd2, 0x3f, 0x5a, 0xe8, 0x1f, 0xd7, 0x20, 0x25, 0x0c, 0xec, 0x0e, 0x77, 0x97,
	0xaa, 0x4f, 0x27, 0xe3, 0x42, 0x4a, 0x48, 0xd4, 0xf4, 0xf3, 0x71, 0x61, 0x73, 0x39, 0x55, 0xad,
	0xa6, 0x9b, 0x61, 0x39, 0xde, 0x86, 0xcc, 0xa9, 0xcd, 0x7a, 0xee, 0x80, 0x99, 0xc4, 0x3b, 0xb1,
	0x46, 0xf9, 0x55, 0x6e, 0x16, 0xdd, 0x54, 0xbf, 0x22, 0xb8, 0x17, 0xd3, 0x6b, 0x80, 0xae, 0x02,
	0x6b, 0x42, 0x8f, 0x77, 0x9a, 0x2e, 0x3f, 0x8e, 0x43, 0x71, 0xe1, 0x1e, 0x95, 0x08, 0x0a, 0x43,
	0xfa, 0x2b, 0x31, 0xf4, 0xc5, 0x70, 0xce, 0xe8, 0xab, 0xbf, 0x11, 0x6c, 0xf8, 0xdd, 0xe8, 0x9c,
	0xee, 0xbf, 0x80, 0xab, 0x82, 0x24, 0x3e, 0xc9, 0xbb, 0x90, 0xdc, 0x8e, 0x4f, 0x4e, 0x28, 0x71,
	0x72, 0x77, 0x23, 0x7f, 0x87, 0xf8, 0x7e, 0x3e, 0xb1, 0x70, 0xb4, 0x0c, 0xc8, 0x06, 0x1a, 0x43,
	0xd2, 0xa7, 0xb6, 0xeb, 0x70, 0x64, 0x52, 0x55, 0x39, 0x1f, 0x17, 0xe4, 0x98, 0xe2, 0xa6, 0xc8,
	0x32, 0x33, 0x62, 0x1d, 0x2c, 0x2f, 0x83, 0x4f, 0xc6, 0x81, 0xff, 0x12, 0x0c, 0x49, 0xf4, 0xa8,
	0x01, 0xf7, 0x17, 0x0b, 0xdc, 0x1f, 0x5d, 0x31, 0x82, 0x11, 0x81, 0xff, 0xa1, 0xbe, 0xf7, 0x1c,
	0x92, 0xfe, 0x0a, 0xa7, 0x20, 0x59, 0x6f, 0xd4, 0x8d, 0x5c, 0x02, 0x4b, 0x70, 0xa3, 0xa2, 0xeb,
	0x86, 0x9e, 0x43, 0x38, 0x0d, 0x37, 0x8f, 0x0f, 0xf4, 0xca, 0x91, 0xa1, 0xe7, 0x56, 0xfc, 0x85,
	0x69, 0xbc, 0x6d, 0x34, 0x0d, 0x3d, 0xb7, 0x5a, 0xfe, 0x83, 0x20, 0x23, 0x6c, 0x0f, 0x49, 0xdf,
	0xef, 0x01, 0x53, 0xc0, 0x97, 0x66, 0x89, 0xe2, 0x62, 0x8c, 0xfb, 0xb2, 0xdf, 0x43, 0x7e, 0x72,
	0xbd, 0x64, 0xc1, 0x49, 0x4d, 0xec, 0x23, 0xec, 0xc1, 0xfa, 0x22, 0x47, 0x8a, 0xf7, 0x96, 0xc8,
	0xc4, 0x0c, 0x96, 0x5c, 0xbc, 0x56, 0xee, 0xcc, 0xb1, 0x4c, 0xe0, 0x56, 0x70, 0xc7, 0xe8, 0x7e,
	0x32, 0x3e, 0x06, 0x78, 0x45, 0x58, 0xb0, 0x85, 0x1f, 0xc4, 0xc8, 0x45, 0xef, 0x37, 0x59, 0xbd,
	0x2a, 0x45, 0x18, 0xed, 0xa3, 0x6a, 0xfe, 0xc7, 0x44, 0x41, 0x67, 0x13, 0x05, 0xfd, 0x9a, 0x28,
	0xe8, 0xdb, 0x54, 0x49, 0x9c, 0x4d, 0x95, 0xc4, 0xcf, 0xa9, 0x92, 0x68, 0xad, 0xf1, 0x8b, 0xf3,
	0xd9, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x89, 0x92, 0x3a, 0xf0, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChangeServiceClient is the client API for ChangeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChangeServiceClient interface {
	// List gets a stream of network change add/update/remove events for network
	// changes matching changeid
	ListNetworkChanges(ctx context.Context, in *ListNetworkChangeRequest, opts ...grpc.CallOption) (ChangeService_ListNetworkChangesClient, error)
	// List gets a stream of device change add/update/remove events for device
	// changes matching changeid
	ListDeviceChanges(ctx context.Context, in *ListDeviceChangeRequest, opts ...grpc.CallOption) (ChangeService_ListDeviceChangesClient, error)
}

type changeServiceClient struct {
	cc *grpc.ClientConn
}

func NewChangeServiceClient(cc *grpc.ClientConn) ChangeServiceClient {
	return &changeServiceClient{cc}
}

func (c *changeServiceClient) ListNetworkChanges(ctx context.Context, in *ListNetworkChangeRequest, opts ...grpc.CallOption) (ChangeService_ListNetworkChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ChangeService_serviceDesc.Streams[0], "/onos.config.diags.ChangeService/ListNetworkChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &changeServiceListNetworkChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChangeService_ListNetworkChangesClient interface {
	Recv() (*ListNetworkChangeResponse, error)
	grpc.ClientStream
}

type changeServiceListNetworkChangesClient struct {
	grpc.ClientStream
}

func (x *changeServiceListNetworkChangesClient) Recv() (*ListNetworkChangeResponse, error) {
	m := new(ListNetworkChangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *changeServiceClient) ListDeviceChanges(ctx context.Context, in *ListDeviceChangeRequest, opts ...grpc.CallOption) (ChangeService_ListDeviceChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ChangeService_serviceDesc.Streams[1], "/onos.config.diags.ChangeService/ListDeviceChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &changeServiceListDeviceChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChangeService_ListDeviceChangesClient interface {
	Recv() (*ListDeviceChangeResponse, error)
	grpc.ClientStream
}

type changeServiceListDeviceChangesClient struct {
	grpc.ClientStream
}

func (x *changeServiceListDeviceChangesClient) Recv() (*ListDeviceChangeResponse, error) {
	m := new(ListDeviceChangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ChangeServiceServer is the server API for ChangeService service.
type ChangeServiceServer interface {
	// List gets a stream of network change add/update/remove events for network
	// changes matching changeid
	ListNetworkChanges(*ListNetworkChangeRequest, ChangeService_ListNetworkChangesServer) error
	// List gets a stream of device change add/update/remove events for device
	// changes matching changeid
	ListDeviceChanges(*ListDeviceChangeRequest, ChangeService_ListDeviceChangesServer) error
}

// UnimplementedChangeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedChangeServiceServer struct {
}

func (*UnimplementedChangeServiceServer) ListNetworkChanges(req *ListNetworkChangeRequest, srv ChangeService_ListNetworkChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListNetworkChanges not implemented")
}
func (*UnimplementedChangeServiceServer) ListDeviceChanges(req *ListDeviceChangeRequest, srv ChangeService_ListDeviceChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListDeviceChanges not implemented")
}

func RegisterChangeServiceServer(s *grpc.Server, srv ChangeServiceServer) {
	s.RegisterService(&_ChangeService_serviceDesc, srv)
}

func _ChangeService_ListNetworkChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListNetworkChangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChangeServiceServer).ListNetworkChanges(m, &changeServiceListNetworkChangesServer{stream})
}

type ChangeService_ListNetworkChangesServer interface {
	Send(*ListNetworkChangeResponse) error
	grpc.ServerStream
}

type changeServiceListNetworkChangesServer struct {
	grpc.ServerStream
}

func (x *changeServiceListNetworkChangesServer) Send(m *ListNetworkChangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ChangeService_ListDeviceChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDeviceChangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChangeServiceServer).ListDeviceChanges(m, &changeServiceListDeviceChangesServer{stream})
}

type ChangeService_ListDeviceChangesServer interface {
	Send(*ListDeviceChangeResponse) error
	grpc.ServerStream
}

type changeServiceListDeviceChangesServer struct {
	grpc.ServerStream
}

func (x *changeServiceListDeviceChangesServer) Send(m *ListDeviceChangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ChangeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.config.diags.ChangeService",
	HandlerType: (*ChangeServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListNetworkChanges",
			Handler:       _ChangeService_ListNetworkChanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListDeviceChanges",
			Handler:       _ChangeService_ListDeviceChanges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/config/diags/diags.proto",
}

// OpStateDiagsClient is the client API for OpStateDiags service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OpStateDiagsClient interface {
	// GetOpState returns a stream of submitted OperationalStateCache aimed at individual devices.
	// If subscribe is true keep on streaming after the initial set are finished
	GetOpState(ctx context.Context, in *OpStateRequest, opts ...grpc.CallOption) (OpStateDiags_GetOpStateClient, error)
}

type opStateDiagsClient struct {
	cc *grpc.ClientConn
}

func NewOpStateDiagsClient(cc *grpc.ClientConn) OpStateDiagsClient {
	return &opStateDiagsClient{cc}
}

func (c *opStateDiagsClient) GetOpState(ctx context.Context, in *OpStateRequest, opts ...grpc.CallOption) (OpStateDiags_GetOpStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OpStateDiags_serviceDesc.Streams[0], "/onos.config.diags.OpStateDiags/GetOpState", opts...)
	if err != nil {
		return nil, err
	}
	x := &opStateDiagsGetOpStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OpStateDiags_GetOpStateClient interface {
	Recv() (*OpStateResponse, error)
	grpc.ClientStream
}

type opStateDiagsGetOpStateClient struct {
	grpc.ClientStream
}

func (x *opStateDiagsGetOpStateClient) Recv() (*OpStateResponse, error) {
	m := new(OpStateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OpStateDiagsServer is the server API for OpStateDiags service.
type OpStateDiagsServer interface {
	// GetOpState returns a stream of submitted OperationalStateCache aimed at individual devices.
	// If subscribe is true keep on streaming after the initial set are finished
	GetOpState(*OpStateRequest, OpStateDiags_GetOpStateServer) error
}

// UnimplementedOpStateDiagsServer can be embedded to have forward compatible implementations.
type UnimplementedOpStateDiagsServer struct {
}

func (*UnimplementedOpStateDiagsServer) GetOpState(req *OpStateRequest, srv OpStateDiags_GetOpStateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetOpState not implemented")
}

func RegisterOpStateDiagsServer(s *grpc.Server, srv OpStateDiagsServer) {
	s.RegisterService(&_OpStateDiags_serviceDesc, srv)
}

func _OpStateDiags_GetOpState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpStateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OpStateDiagsServer).GetOpState(m, &opStateDiagsGetOpStateServer{stream})
}

type OpStateDiags_GetOpStateServer interface {
	Send(*OpStateResponse) error
	grpc.ServerStream
}

type opStateDiagsGetOpStateServer struct {
	grpc.ServerStream
}

func (x *opStateDiagsGetOpStateServer) Send(m *OpStateResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _OpStateDiags_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.config.diags.OpStateDiags",
	HandlerType: (*OpStateDiagsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetOpState",
			Handler:       _OpStateDiags_GetOpState_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/config/diags/diags.proto",
}

func (m *OpStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subscribe {
		i--
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintDiags(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pathvalue != nil {
		{
			size, err := m.Pathvalue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDiags(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintDiags(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListNetworkChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNetworkChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNetworkChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithoutReplay {
		i--
		if m.WithoutReplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChangeID) > 0 {
		i -= len(m.ChangeID)
		copy(dAtA[i:], m.ChangeID)
		i = encodeVarintDiags(dAtA, i, uint64(len(m.ChangeID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Subscribe {
		i--
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListNetworkChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNetworkChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNetworkChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintDiags(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDiags(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListDeviceChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDeviceChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDeviceChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithoutReplay {
		i--
		if m.WithoutReplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeviceVersion) > 0 {
		i -= len(m.DeviceVersion)
		copy(dAtA[i:], m.DeviceVersion)
		i = encodeVarintDiags(dAtA, i, uint64(len(m.DeviceVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceID) > 0 {
		i -= len(m.DeviceID)
		copy(dAtA[i:], m.DeviceID)
		i = encodeVarintDiags(dAtA, i, uint64(len(m.DeviceID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Subscribe {
		i--
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDeviceChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDeviceChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDeviceChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintDiags(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDiags(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDiags(dAtA []byte, offset int, v uint64) int {
	offset -= sovDiags(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OpStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovDiags(uint64(l))
	}
	if m.Subscribe {
		n += 2
	}
	return n
}

func (m *OpStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDiags(uint64(m.Type))
	}
	if m.Pathvalue != nil {
		l = m.Pathvalue.Size()
		n += 1 + l + sovDiags(uint64(l))
	}
	return n
}

func (m *ListNetworkChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscribe {
		n += 2
	}
	l = len(m.ChangeID)
	if l > 0 {
		n += 1 + l + sovDiags(uint64(l))
	}
	if m.WithoutReplay {
		n += 2
	}
	return n
}

func (m *ListNetworkChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovDiags(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDiags(uint64(m.Type))
	}
	return n
}

func (m *ListDeviceChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscribe {
		n += 2
	}
	l = len(m.DeviceID)
	if l > 0 {
		n += 1 + l + sovDiags(uint64(l))
	}
	l = len(m.DeviceVersion)
	if l > 0 {
		n += 1 + l + sovDiags(uint64(l))
	}
	if m.WithoutReplay {
		n += 2
	}
	return n
}

func (m *ListDeviceChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovDiags(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDiags(uint64(m.Type))
	}
	return n
}

func sovDiags(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDiags(x uint64) (n int) {
	return sovDiags(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OpStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDiags(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= admin.Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pathvalue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pathvalue == nil {
				m.Pathvalue = &device.PathValue{}
			}
			if err := m.Pathvalue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiags(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNetworkChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNetworkChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNetworkChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeID = onos_config_change_network.ID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutReplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDiags(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNetworkChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNetworkChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNetworkChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &network.NetworkChange{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiags(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDeviceChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDeviceChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDeviceChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceID = onos_config_device.ID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceVersion = onos_config_device.Version(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithoutReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithoutReplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDiags(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDeviceChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDeviceChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDeviceChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiags
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiags
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &device.DeviceChange{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiags(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiags
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDiags(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDiags
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiags
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDiags
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDiags
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDiags
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDiags        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDiags          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDiags = fmt.Errorf("proto: unexpected end of group")
)
