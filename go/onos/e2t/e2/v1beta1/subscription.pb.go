// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/e2t/e2/v1beta1/subscription.proto

// Package onos.e2t.e2.v1beta1 defines the interior gRPC interfaces for xApps to interact with E2T.

package v1beta1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ActionType int32

const (
	ActionType_ACTION_TYPE_REPORT ActionType = 0
	ActionType_ACTION_TYPE_INSERT ActionType = 1
	ActionType_ACTION_TYPE_POLICY ActionType = 2
)

var ActionType_name = map[int32]string{
	0: "ACTION_TYPE_REPORT",
	1: "ACTION_TYPE_INSERT",
	2: "ACTION_TYPE_POLICY",
}

var ActionType_value = map[string]int32{
	"ACTION_TYPE_REPORT": 0,
	"ACTION_TYPE_INSERT": 1,
	"ACTION_TYPE_POLICY": 2,
}

func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}

func (ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{0}
}

type SubsequentActionType int32

const (
	SubsequentActionType_SUBSEQUENT_ACTION_TYPE_CONTINUE SubsequentActionType = 0
	SubsequentActionType_SUBSEQUENT_ACTION_TYPE_WAIT     SubsequentActionType = 1
)

var SubsequentActionType_name = map[int32]string{
	0: "SUBSEQUENT_ACTION_TYPE_CONTINUE",
	1: "SUBSEQUENT_ACTION_TYPE_WAIT",
}

var SubsequentActionType_value = map[string]int32{
	"SUBSEQUENT_ACTION_TYPE_CONTINUE": 0,
	"SUBSEQUENT_ACTION_TYPE_WAIT":     1,
}

func (x SubsequentActionType) String() string {
	return proto.EnumName(SubsequentActionType_name, int32(x))
}

func (SubsequentActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{1}
}

type TimeToWait int32

const (
	TimeToWait_TIME_TO_WAIT_ZERO   TimeToWait = 0
	TimeToWait_TIME_TO_WAIT_W1MS   TimeToWait = 1
	TimeToWait_TIME_TO_WAIT_W2MS   TimeToWait = 2
	TimeToWait_TIME_TO_WAIT_W5MS   TimeToWait = 3
	TimeToWait_TIME_TO_WAIT_W10MS  TimeToWait = 4
	TimeToWait_TIME_TO_WAIT_W20MS  TimeToWait = 5
	TimeToWait_TIME_TO_WAIT_W30MS  TimeToWait = 6
	TimeToWait_TIME_TO_WAIT_W40MS  TimeToWait = 7
	TimeToWait_TIME_TO_WAIT_W50MS  TimeToWait = 8
	TimeToWait_TIME_TO_WAIT_W100MS TimeToWait = 9
	TimeToWait_TIME_TO_WAIT_W200MS TimeToWait = 10
	TimeToWait_TIME_TO_WAIT_W500MS TimeToWait = 11
	TimeToWait_TIME_TO_WAIT_W1S    TimeToWait = 12
	TimeToWait_TIME_TO_WAIT_W2S    TimeToWait = 13
	TimeToWait_TIME_TO_WAIT_W5S    TimeToWait = 14
	TimeToWait_TIME_TO_WAIT_W10S   TimeToWait = 15
	TimeToWait_TIME_TO_WAIT_W20S   TimeToWait = 16
	TimeToWait_TIME_TO_WAIT_W60S   TimeToWait = 17
)

var TimeToWait_name = map[int32]string{
	0:  "TIME_TO_WAIT_ZERO",
	1:  "TIME_TO_WAIT_W1MS",
	2:  "TIME_TO_WAIT_W2MS",
	3:  "TIME_TO_WAIT_W5MS",
	4:  "TIME_TO_WAIT_W10MS",
	5:  "TIME_TO_WAIT_W20MS",
	6:  "TIME_TO_WAIT_W30MS",
	7:  "TIME_TO_WAIT_W40MS",
	8:  "TIME_TO_WAIT_W50MS",
	9:  "TIME_TO_WAIT_W100MS",
	10: "TIME_TO_WAIT_W200MS",
	11: "TIME_TO_WAIT_W500MS",
	12: "TIME_TO_WAIT_W1S",
	13: "TIME_TO_WAIT_W2S",
	14: "TIME_TO_WAIT_W5S",
	15: "TIME_TO_WAIT_W10S",
	16: "TIME_TO_WAIT_W20S",
	17: "TIME_TO_WAIT_W60S",
}

var TimeToWait_value = map[string]int32{
	"TIME_TO_WAIT_ZERO":   0,
	"TIME_TO_WAIT_W1MS":   1,
	"TIME_TO_WAIT_W2MS":   2,
	"TIME_TO_WAIT_W5MS":   3,
	"TIME_TO_WAIT_W10MS":  4,
	"TIME_TO_WAIT_W20MS":  5,
	"TIME_TO_WAIT_W30MS":  6,
	"TIME_TO_WAIT_W40MS":  7,
	"TIME_TO_WAIT_W50MS":  8,
	"TIME_TO_WAIT_W100MS": 9,
	"TIME_TO_WAIT_W200MS": 10,
	"TIME_TO_WAIT_W500MS": 11,
	"TIME_TO_WAIT_W1S":    12,
	"TIME_TO_WAIT_W2S":    13,
	"TIME_TO_WAIT_W5S":    14,
	"TIME_TO_WAIT_W10S":   15,
	"TIME_TO_WAIT_W20S":   16,
	"TIME_TO_WAIT_W60S":   17,
}

func (x TimeToWait) String() string {
	return proto.EnumName(TimeToWait_name, int32(x))
}

func (TimeToWait) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{2}
}

type ChannelEventType int32

const (
	ChannelEventType_CHANNEL_EVENT_UNKNOWN ChannelEventType = 0
	ChannelEventType_CHANNEL_CREATED       ChannelEventType = 1
	ChannelEventType_CHANNEL_UPDATED       ChannelEventType = 2
	ChannelEventType_CHANNEL_DELETED       ChannelEventType = 3
	ChannelEventType_CHANNEL_REPLAYED      ChannelEventType = 4
)

var ChannelEventType_name = map[int32]string{
	0: "CHANNEL_EVENT_UNKNOWN",
	1: "CHANNEL_CREATED",
	2: "CHANNEL_UPDATED",
	3: "CHANNEL_DELETED",
	4: "CHANNEL_REPLAYED",
}

var ChannelEventType_value = map[string]int32{
	"CHANNEL_EVENT_UNKNOWN": 0,
	"CHANNEL_CREATED":       1,
	"CHANNEL_UPDATED":       2,
	"CHANNEL_DELETED":       3,
	"CHANNEL_REPLAYED":      4,
}

func (x ChannelEventType) String() string {
	return proto.EnumName(ChannelEventType_name, int32(x))
}

func (ChannelEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{3}
}

type SubscriptionEventType int32

const (
	SubscriptionEventType_SUBSCRIPTION_EVENT_UNKNOWN SubscriptionEventType = 0
	SubscriptionEventType_SUBSCRIPTION_CREATED       SubscriptionEventType = 1
	SubscriptionEventType_SUBSCRIPTION_UPDATED       SubscriptionEventType = 2
	SubscriptionEventType_SUBSCRIPTION_DELETED       SubscriptionEventType = 3
	SubscriptionEventType_SUBSCRIPTION_REPLAYED      SubscriptionEventType = 4
)

var SubscriptionEventType_name = map[int32]string{
	0: "SUBSCRIPTION_EVENT_UNKNOWN",
	1: "SUBSCRIPTION_CREATED",
	2: "SUBSCRIPTION_UPDATED",
	3: "SUBSCRIPTION_DELETED",
	4: "SUBSCRIPTION_REPLAYED",
}

var SubscriptionEventType_value = map[string]int32{
	"SUBSCRIPTION_EVENT_UNKNOWN": 0,
	"SUBSCRIPTION_CREATED":       1,
	"SUBSCRIPTION_UPDATED":       2,
	"SUBSCRIPTION_DELETED":       3,
	"SUBSCRIPTION_REPLAYED":      4,
}

func (x SubscriptionEventType) String() string {
	return proto.EnumName(SubscriptionEventType_name, int32(x))
}

func (SubscriptionEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{4}
}

type ChannelPhase int32

const (
	ChannelPhase_CHANNEL_CLOSED ChannelPhase = 0
	ChannelPhase_CHANNEL_OPEN   ChannelPhase = 1
)

var ChannelPhase_name = map[int32]string{
	0: "CHANNEL_CLOSED",
	1: "CHANNEL_OPEN",
}

var ChannelPhase_value = map[string]int32{
	"CHANNEL_CLOSED": 0,
	"CHANNEL_OPEN":   1,
}

func (x ChannelPhase) String() string {
	return proto.EnumName(ChannelPhase_name, int32(x))
}

func (ChannelPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{5}
}

type ChannelState int32

const (
	// CHANNEL_PENDING indicates the channel phase is pending
	ChannelState_CHANNEL_PENDING ChannelState = 0
	// CHANNEL_COMPLETE indicates the channel phase is complete
	ChannelState_CHANNEL_COMPLETE ChannelState = 1
	// CHANNEL_FAILED indicates the channel phase failed
	ChannelState_CHANNEL_FAILED ChannelState = 2
)

var ChannelState_name = map[int32]string{
	0: "CHANNEL_PENDING",
	1: "CHANNEL_COMPLETE",
	2: "CHANNEL_FAILED",
}

var ChannelState_value = map[string]int32{
	"CHANNEL_PENDING":  0,
	"CHANNEL_COMPLETE": 1,
	"CHANNEL_FAILED":   2,
}

func (x ChannelState) String() string {
	return proto.EnumName(ChannelState_name, int32(x))
}

func (ChannelState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{6}
}

type SubscriptionPhase int32

const (
	SubscriptionPhase_SUBSCRIPTION_CLOSED SubscriptionPhase = 0
	SubscriptionPhase_SUBSCRIPTION_OPEN   SubscriptionPhase = 1
)

var SubscriptionPhase_name = map[int32]string{
	0: "SUBSCRIPTION_CLOSED",
	1: "SUBSCRIPTION_OPEN",
}

var SubscriptionPhase_value = map[string]int32{
	"SUBSCRIPTION_CLOSED": 0,
	"SUBSCRIPTION_OPEN":   1,
}

func (x SubscriptionPhase) String() string {
	return proto.EnumName(SubscriptionPhase_name, int32(x))
}

func (SubscriptionPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{7}
}

type SubscriptionState int32

const (
	// SUBSCRIPTION_PENDING indicates the subscription phase is pending
	SubscriptionState_SUBSCRIPTION_PENDING SubscriptionState = 0
	// SUBSCRIPTION_COMPLETE indicates the subscription phase is complete
	SubscriptionState_SUBSCRIPTION_COMPLETE SubscriptionState = 1
	// SUBSCRIPTION_FAILED indicates the subscription phase failed
	SubscriptionState_SUBSCRIPTION_FAILED SubscriptionState = 2
)

var SubscriptionState_name = map[int32]string{
	0: "SUBSCRIPTION_PENDING",
	1: "SUBSCRIPTION_COMPLETE",
	2: "SUBSCRIPTION_FAILED",
}

var SubscriptionState_value = map[string]int32{
	"SUBSCRIPTION_PENDING":  0,
	"SUBSCRIPTION_COMPLETE": 1,
	"SUBSCRIPTION_FAILED":   2,
}

func (x SubscriptionState) String() string {
	return proto.EnumName(SubscriptionState_name, int32(x))
}

func (SubscriptionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{8}
}

type SubscribeRequest struct {
	Headers            RequestHeaders   `protobuf:"bytes,1,opt,name=headers,proto3" json:"headers"`
	TransactionID      TransactionID    `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3,casttype=TransactionID" json:"transaction_id,omitempty"`
	Subscription       SubscriptionSpec `protobuf:"bytes,3,opt,name=subscription,proto3" json:"subscription"`
	TransactionTimeout *time.Duration   `protobuf:"bytes,4,opt,name=transaction_timeout,json=transactionTimeout,proto3,stdduration" json:"transaction_timeout,omitempty"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{0}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

func (m *SubscribeRequest) GetHeaders() RequestHeaders {
	if m != nil {
		return m.Headers
	}
	return RequestHeaders{}
}

func (m *SubscribeRequest) GetTransactionID() TransactionID {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

func (m *SubscribeRequest) GetSubscription() SubscriptionSpec {
	if m != nil {
		return m.Subscription
	}
	return SubscriptionSpec{}
}

func (m *SubscribeRequest) GetTransactionTimeout() *time.Duration {
	if m != nil {
		return m.TransactionTimeout
	}
	return nil
}

type SubscribeResponse struct {
	Headers ResponseHeaders `protobuf:"bytes,1,opt,name=headers,proto3" json:"headers"`
	// Types that are valid to be assigned to Message:
	//	*SubscribeResponse_Ack
	//	*SubscribeResponse_Indication
	Message isSubscribeResponse_Message `protobuf_oneof:"message"`
}

func (m *SubscribeResponse) Reset()         { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()    {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{1}
}
func (m *SubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeResponse.Merge(m, src)
}
func (m *SubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeResponse proto.InternalMessageInfo

type isSubscribeResponse_Message interface {
	isSubscribeResponse_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SubscribeResponse_Ack struct {
	Ack *Acknowledgement `protobuf:"bytes,2,opt,name=ack,proto3,oneof" json:"ack,omitempty"`
}
type SubscribeResponse_Indication struct {
	Indication *Indication `protobuf:"bytes,3,opt,name=indication,proto3,oneof" json:"indication,omitempty"`
}

func (*SubscribeResponse_Ack) isSubscribeResponse_Message()        {}
func (*SubscribeResponse_Indication) isSubscribeResponse_Message() {}

func (m *SubscribeResponse) GetMessage() isSubscribeResponse_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *SubscribeResponse) GetHeaders() ResponseHeaders {
	if m != nil {
		return m.Headers
	}
	return ResponseHeaders{}
}

func (m *SubscribeResponse) GetAck() *Acknowledgement {
	if x, ok := m.GetMessage().(*SubscribeResponse_Ack); ok {
		return x.Ack
	}
	return nil
}

func (m *SubscribeResponse) GetIndication() *Indication {
	if x, ok := m.GetMessage().(*SubscribeResponse_Indication); ok {
		return x.Indication
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SubscribeResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SubscribeResponse_Ack)(nil),
		(*SubscribeResponse_Indication)(nil),
	}
}

type UnsubscribeRequest struct {
	Headers       RequestHeaders `protobuf:"bytes,1,opt,name=headers,proto3" json:"headers"`
	TransactionID TransactionID  `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3,casttype=TransactionID" json:"transaction_id,omitempty"`
}

func (m *UnsubscribeRequest) Reset()         { *m = UnsubscribeRequest{} }
func (m *UnsubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeRequest) ProtoMessage()    {}
func (*UnsubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{2}
}
func (m *UnsubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeRequest.Merge(m, src)
}
func (m *UnsubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeRequest proto.InternalMessageInfo

func (m *UnsubscribeRequest) GetHeaders() RequestHeaders {
	if m != nil {
		return m.Headers
	}
	return RequestHeaders{}
}

func (m *UnsubscribeRequest) GetTransactionID() TransactionID {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

type UnsubscribeResponse struct {
	Headers ResponseHeaders `protobuf:"bytes,1,opt,name=headers,proto3" json:"headers"`
}

func (m *UnsubscribeResponse) Reset()         { *m = UnsubscribeResponse{} }
func (m *UnsubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*UnsubscribeResponse) ProtoMessage()    {}
func (*UnsubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{3}
}
func (m *UnsubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsubscribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeResponse.Merge(m, src)
}
func (m *UnsubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeResponse proto.InternalMessageInfo

func (m *UnsubscribeResponse) GetHeaders() ResponseHeaders {
	if m != nil {
		return m.Headers
	}
	return ResponseHeaders{}
}

type SubscriptionSpec struct {
	EventTrigger EventTrigger `protobuf:"bytes,1,opt,name=event_trigger,json=eventTrigger,proto3" json:"event_trigger"`
	Actions      []Action     `protobuf:"bytes,2,rep,name=actions,proto3" json:"actions"`
}

func (m *SubscriptionSpec) Reset()         { *m = SubscriptionSpec{} }
func (m *SubscriptionSpec) String() string { return proto.CompactTextString(m) }
func (*SubscriptionSpec) ProtoMessage()    {}
func (*SubscriptionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{4}
}
func (m *SubscriptionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionSpec.Merge(m, src)
}
func (m *SubscriptionSpec) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionSpec proto.InternalMessageInfo

func (m *SubscriptionSpec) GetEventTrigger() EventTrigger {
	if m != nil {
		return m.EventTrigger
	}
	return EventTrigger{}
}

func (m *SubscriptionSpec) GetActions() []Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type EventTrigger struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *EventTrigger) Reset()         { *m = EventTrigger{} }
func (m *EventTrigger) String() string { return proto.CompactTextString(m) }
func (*EventTrigger) ProtoMessage()    {}
func (*EventTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{5}
}
func (m *EventTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTrigger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTrigger.Merge(m, src)
}
func (m *EventTrigger) XXX_Size() int {
	return m.Size()
}
func (m *EventTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_EventTrigger proto.InternalMessageInfo

func (m *EventTrigger) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type Action struct {
	ID               int32             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type             ActionType        `protobuf:"varint,2,opt,name=type,proto3,enum=onos.e2t.e2.v1beta1.ActionType" json:"type,omitempty"`
	Payload          []byte            `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	SubsequentAction *SubsequentAction `protobuf:"bytes,4,opt,name=subsequent_action,json=subsequentAction,proto3" json:"subsequent_action,omitempty"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{6}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Action) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ACTION_TYPE_REPORT
}

func (m *Action) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Action) GetSubsequentAction() *SubsequentAction {
	if m != nil {
		return m.SubsequentAction
	}
	return nil
}

type SubsequentAction struct {
	Type       SubsequentActionType `protobuf:"varint,1,opt,name=type,proto3,enum=onos.e2t.e2.v1beta1.SubsequentActionType" json:"type,omitempty"`
	TimeToWait TimeToWait           `protobuf:"varint,2,opt,name=time_to_wait,json=timeToWait,proto3,enum=onos.e2t.e2.v1beta1.TimeToWait" json:"time_to_wait,omitempty"`
}

func (m *SubsequentAction) Reset()         { *m = SubsequentAction{} }
func (m *SubsequentAction) String() string { return proto.CompactTextString(m) }
func (*SubsequentAction) ProtoMessage()    {}
func (*SubsequentAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{7}
}
func (m *SubsequentAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubsequentAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubsequentAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubsequentAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsequentAction.Merge(m, src)
}
func (m *SubsequentAction) XXX_Size() int {
	return m.Size()
}
func (m *SubsequentAction) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsequentAction.DiscardUnknown(m)
}

var xxx_messageInfo_SubsequentAction proto.InternalMessageInfo

func (m *SubsequentAction) GetType() SubsequentActionType {
	if m != nil {
		return m.Type
	}
	return SubsequentActionType_SUBSEQUENT_ACTION_TYPE_CONTINUE
}

func (m *SubsequentAction) GetTimeToWait() TimeToWait {
	if m != nil {
		return m.TimeToWait
	}
	return TimeToWait_TIME_TO_WAIT_ZERO
}

type Acknowledgement struct {
	ChannelID ChannelID `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3,casttype=ChannelID" json:"channel_id,omitempty"`
}

func (m *Acknowledgement) Reset()         { *m = Acknowledgement{} }
func (m *Acknowledgement) String() string { return proto.CompactTextString(m) }
func (*Acknowledgement) ProtoMessage()    {}
func (*Acknowledgement) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{8}
}
func (m *Acknowledgement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Acknowledgement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Acknowledgement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Acknowledgement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Acknowledgement.Merge(m, src)
}
func (m *Acknowledgement) XXX_Size() int {
	return m.Size()
}
func (m *Acknowledgement) XXX_DiscardUnknown() {
	xxx_messageInfo_Acknowledgement.DiscardUnknown(m)
}

var xxx_messageInfo_Acknowledgement proto.InternalMessageInfo

func (m *Acknowledgement) GetChannelID() ChannelID {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

type Indication struct {
	Header  []byte `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Indication) Reset()         { *m = Indication{} }
func (m *Indication) String() string { return proto.CompactTextString(m) }
func (*Indication) ProtoMessage()    {}
func (*Indication) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{9}
}
func (m *Indication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Indication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Indication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Indication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Indication.Merge(m, src)
}
func (m *Indication) XXX_Size() int {
	return m.Size()
}
func (m *Indication) XXX_DiscardUnknown() {
	xxx_messageInfo_Indication.DiscardUnknown(m)
}

var xxx_messageInfo_Indication proto.InternalMessageInfo

func (m *Indication) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Indication) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type GetChannelRequest struct {
	ChannelID ChannelID `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3,casttype=ChannelID" json:"channel_id,omitempty"`
}

func (m *GetChannelRequest) Reset()         { *m = GetChannelRequest{} }
func (m *GetChannelRequest) String() string { return proto.CompactTextString(m) }
func (*GetChannelRequest) ProtoMessage()    {}
func (*GetChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{10}
}
func (m *GetChannelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetChannelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetChannelRequest.Merge(m, src)
}
func (m *GetChannelRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetChannelRequest proto.InternalMessageInfo

func (m *GetChannelRequest) GetChannelID() ChannelID {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

type GetChannelResponse struct {
	Channel Channel `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel"`
}

func (m *GetChannelResponse) Reset()         { *m = GetChannelResponse{} }
func (m *GetChannelResponse) String() string { return proto.CompactTextString(m) }
func (*GetChannelResponse) ProtoMessage()    {}
func (*GetChannelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{11}
}
func (m *GetChannelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetChannelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetChannelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetChannelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetChannelResponse.Merge(m, src)
}
func (m *GetChannelResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetChannelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetChannelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetChannelResponse proto.InternalMessageInfo

func (m *GetChannelResponse) GetChannel() Channel {
	if m != nil {
		return m.Channel
	}
	return Channel{}
}

type ListChannelsRequest struct {
}

func (m *ListChannelsRequest) Reset()         { *m = ListChannelsRequest{} }
func (m *ListChannelsRequest) String() string { return proto.CompactTextString(m) }
func (*ListChannelsRequest) ProtoMessage()    {}
func (*ListChannelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{12}
}
func (m *ListChannelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListChannelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListChannelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListChannelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListChannelsRequest.Merge(m, src)
}
func (m *ListChannelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListChannelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListChannelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListChannelsRequest proto.InternalMessageInfo

type ListChannelsResponse struct {
	Channels []Channel `protobuf:"bytes,1,rep,name=channels,proto3" json:"channels"`
}

func (m *ListChannelsResponse) Reset()         { *m = ListChannelsResponse{} }
func (m *ListChannelsResponse) String() string { return proto.CompactTextString(m) }
func (*ListChannelsResponse) ProtoMessage()    {}
func (*ListChannelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{13}
}
func (m *ListChannelsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListChannelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListChannelsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListChannelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListChannelsResponse.Merge(m, src)
}
func (m *ListChannelsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListChannelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListChannelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListChannelsResponse proto.InternalMessageInfo

func (m *ListChannelsResponse) GetChannels() []Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type WatchChannelsRequest struct {
	NoReplay bool `protobuf:"varint,1,opt,name=no_replay,json=noReplay,proto3" json:"no_replay,omitempty"`
}

func (m *WatchChannelsRequest) Reset()         { *m = WatchChannelsRequest{} }
func (m *WatchChannelsRequest) String() string { return proto.CompactTextString(m) }
func (*WatchChannelsRequest) ProtoMessage()    {}
func (*WatchChannelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{14}
}
func (m *WatchChannelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchChannelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchChannelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchChannelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchChannelsRequest.Merge(m, src)
}
func (m *WatchChannelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchChannelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchChannelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchChannelsRequest proto.InternalMessageInfo

func (m *WatchChannelsRequest) GetNoReplay() bool {
	if m != nil {
		return m.NoReplay
	}
	return false
}

type WatchChannelsResponse struct {
	Event ChannelEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event"`
}

func (m *WatchChannelsResponse) Reset()         { *m = WatchChannelsResponse{} }
func (m *WatchChannelsResponse) String() string { return proto.CompactTextString(m) }
func (*WatchChannelsResponse) ProtoMessage()    {}
func (*WatchChannelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{15}
}
func (m *WatchChannelsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchChannelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchChannelsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchChannelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchChannelsResponse.Merge(m, src)
}
func (m *WatchChannelsResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchChannelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchChannelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchChannelsResponse proto.InternalMessageInfo

func (m *WatchChannelsResponse) GetEvent() ChannelEvent {
	if m != nil {
		return m.Event
	}
	return ChannelEvent{}
}

type ChannelEvent struct {
	Type    ChannelEventType `protobuf:"varint,1,opt,name=type,proto3,enum=onos.e2t.e2.v1beta1.ChannelEventType" json:"type,omitempty"`
	Channel Channel          `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel"`
}

func (m *ChannelEvent) Reset()         { *m = ChannelEvent{} }
func (m *ChannelEvent) String() string { return proto.CompactTextString(m) }
func (*ChannelEvent) ProtoMessage()    {}
func (*ChannelEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{16}
}
func (m *ChannelEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelEvent.Merge(m, src)
}
func (m *ChannelEvent) XXX_Size() int {
	return m.Size()
}
func (m *ChannelEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelEvent proto.InternalMessageInfo

func (m *ChannelEvent) GetType() ChannelEventType {
	if m != nil {
		return m.Type
	}
	return ChannelEventType_CHANNEL_EVENT_UNKNOWN
}

func (m *ChannelEvent) GetChannel() Channel {
	if m != nil {
		return m.Channel
	}
	return Channel{}
}

type GetSubscriptionRequest struct {
	SubscriptionID SubscriptionID `protobuf:"bytes,1,opt,name=subscription_id,json=subscriptionId,proto3,casttype=SubscriptionID" json:"subscription_id,omitempty"`
}

func (m *GetSubscriptionRequest) Reset()         { *m = GetSubscriptionRequest{} }
func (m *GetSubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionRequest) ProtoMessage()    {}
func (*GetSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{17}
}
func (m *GetSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionRequest.Merge(m, src)
}
func (m *GetSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionRequest proto.InternalMessageInfo

func (m *GetSubscriptionRequest) GetSubscriptionID() SubscriptionID {
	if m != nil {
		return m.SubscriptionID
	}
	return ""
}

type GetSubscriptionResponse struct {
	Subscription Subscription `protobuf:"bytes,1,opt,name=subscription,proto3" json:"subscription"`
}

func (m *GetSubscriptionResponse) Reset()         { *m = GetSubscriptionResponse{} }
func (m *GetSubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionResponse) ProtoMessage()    {}
func (*GetSubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{18}
}
func (m *GetSubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionResponse.Merge(m, src)
}
func (m *GetSubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionResponse proto.InternalMessageInfo

func (m *GetSubscriptionResponse) GetSubscription() Subscription {
	if m != nil {
		return m.Subscription
	}
	return Subscription{}
}

type ListSubscriptionsRequest struct {
}

func (m *ListSubscriptionsRequest) Reset()         { *m = ListSubscriptionsRequest{} }
func (m *ListSubscriptionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSubscriptionsRequest) ProtoMessage()    {}
func (*ListSubscriptionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{19}
}
func (m *ListSubscriptionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSubscriptionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSubscriptionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSubscriptionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSubscriptionsRequest.Merge(m, src)
}
func (m *ListSubscriptionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListSubscriptionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSubscriptionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSubscriptionsRequest proto.InternalMessageInfo

type ListSubscriptionsResponse struct {
	Subscriptions []Subscription `protobuf:"bytes,1,rep,name=subscriptions,proto3" json:"subscriptions"`
}

func (m *ListSubscriptionsResponse) Reset()         { *m = ListSubscriptionsResponse{} }
func (m *ListSubscriptionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSubscriptionsResponse) ProtoMessage()    {}
func (*ListSubscriptionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{20}
}
func (m *ListSubscriptionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSubscriptionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSubscriptionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSubscriptionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSubscriptionsResponse.Merge(m, src)
}
func (m *ListSubscriptionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSubscriptionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSubscriptionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSubscriptionsResponse proto.InternalMessageInfo

func (m *ListSubscriptionsResponse) GetSubscriptions() []Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

type WatchSubscriptionsRequest struct {
	NoReplay bool `protobuf:"varint,1,opt,name=no_replay,json=noReplay,proto3" json:"no_replay,omitempty"`
}

func (m *WatchSubscriptionsRequest) Reset()         { *m = WatchSubscriptionsRequest{} }
func (m *WatchSubscriptionsRequest) String() string { return proto.CompactTextString(m) }
func (*WatchSubscriptionsRequest) ProtoMessage()    {}
func (*WatchSubscriptionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{21}
}
func (m *WatchSubscriptionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchSubscriptionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchSubscriptionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchSubscriptionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchSubscriptionsRequest.Merge(m, src)
}
func (m *WatchSubscriptionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchSubscriptionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchSubscriptionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchSubscriptionsRequest proto.InternalMessageInfo

func (m *WatchSubscriptionsRequest) GetNoReplay() bool {
	if m != nil {
		return m.NoReplay
	}
	return false
}

type WatchSubscriptionsResponse struct {
	Event SubscriptionEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event"`
}

func (m *WatchSubscriptionsResponse) Reset()         { *m = WatchSubscriptionsResponse{} }
func (m *WatchSubscriptionsResponse) String() string { return proto.CompactTextString(m) }
func (*WatchSubscriptionsResponse) ProtoMessage()    {}
func (*WatchSubscriptionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{22}
}
func (m *WatchSubscriptionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchSubscriptionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchSubscriptionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchSubscriptionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchSubscriptionsResponse.Merge(m, src)
}
func (m *WatchSubscriptionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchSubscriptionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchSubscriptionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchSubscriptionsResponse proto.InternalMessageInfo

func (m *WatchSubscriptionsResponse) GetEvent() SubscriptionEvent {
	if m != nil {
		return m.Event
	}
	return SubscriptionEvent{}
}

type SubscriptionEvent struct {
	Type         SubscriptionEventType `protobuf:"varint,1,opt,name=type,proto3,enum=onos.e2t.e2.v1beta1.SubscriptionEventType" json:"type,omitempty"`
	Subscription Subscription          `protobuf:"bytes,2,opt,name=subscription,proto3" json:"subscription"`
}

func (m *SubscriptionEvent) Reset()         { *m = SubscriptionEvent{} }
func (m *SubscriptionEvent) String() string { return proto.CompactTextString(m) }
func (*SubscriptionEvent) ProtoMessage()    {}
func (*SubscriptionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{23}
}
func (m *SubscriptionEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionEvent.Merge(m, src)
}
func (m *SubscriptionEvent) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionEvent proto.InternalMessageInfo

func (m *SubscriptionEvent) GetType() SubscriptionEventType {
	if m != nil {
		return m.Type
	}
	return SubscriptionEventType_SUBSCRIPTION_EVENT_UNKNOWN
}

func (m *SubscriptionEvent) GetSubscription() Subscription {
	if m != nil {
		return m.Subscription
	}
	return Subscription{}
}

// ChannelMeta contains metadata relating to a subscription channel
type ChannelMeta struct {
	// app_id is an identifier for the application that created the channel shared across all instances of the application
	AppID AppID `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3,casttype=AppID" json:"app_id,omitempty"`
	// app_instance_id is an identifier unique to a single node within the application that created the channel
	AppInstanceID AppInstanceID `protobuf:"bytes,2,opt,name=app_instance_id,json=appInstanceId,proto3,casttype=AppInstanceID" json:"app_instance_id,omitempty"`
	// e2_node_id is the identifier for the E2 node to which the subscription is targeted
	E2NodeID E2NodeID `protobuf:"bytes,3,opt,name=e2_node_id,json=e2NodeId,proto3,casttype=E2NodeID" json:"e2_node_id,omitempty"`
	// transaction_id is a persistent identifier for the transaction
	TransactionID TransactionID `protobuf:"bytes,4,opt,name=transaction_id,json=transactionId,proto3,casttype=TransactionID" json:"transaction_id,omitempty"`
	// subscription_id is the identifier for the underlying subscription
	SubscriptionID SubscriptionID `protobuf:"bytes,5,opt,name=subscription_id,json=subscriptionId,proto3,casttype=SubscriptionID" json:"subscription_id,omitempty"`
	// service_model is the service model specification
	ServiceModel ServiceModel `protobuf:"bytes,6,opt,name=service_model,json=serviceModel,proto3" json:"service_model"`
	// encoding indicates the type of encoding used within the parent message
	Encoding   Encoding `protobuf:"varint,7,opt,name=encoding,proto3,enum=onos.e2t.e2.v1beta1.Encoding" json:"encoding,omitempty"`
	Revision   Revision `protobuf:"varint,8,opt,name=revision,proto3,casttype=Revision" json:"revision,omitempty"`
	Finalizers []string `protobuf:"bytes,9,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
}

func (m *ChannelMeta) Reset()         { *m = ChannelMeta{} }
func (m *ChannelMeta) String() string { return proto.CompactTextString(m) }
func (*ChannelMeta) ProtoMessage()    {}
func (*ChannelMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{24}
}
func (m *ChannelMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelMeta.Merge(m, src)
}
func (m *ChannelMeta) XXX_Size() int {
	return m.Size()
}
func (m *ChannelMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelMeta proto.InternalMessageInfo

func (m *ChannelMeta) GetAppID() AppID {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *ChannelMeta) GetAppInstanceID() AppInstanceID {
	if m != nil {
		return m.AppInstanceID
	}
	return ""
}

func (m *ChannelMeta) GetE2NodeID() E2NodeID {
	if m != nil {
		return m.E2NodeID
	}
	return ""
}

func (m *ChannelMeta) GetTransactionID() TransactionID {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

func (m *ChannelMeta) GetSubscriptionID() SubscriptionID {
	if m != nil {
		return m.SubscriptionID
	}
	return ""
}

func (m *ChannelMeta) GetServiceModel() ServiceModel {
	if m != nil {
		return m.ServiceModel
	}
	return ServiceModel{}
}

func (m *ChannelMeta) GetEncoding() Encoding {
	if m != nil {
		return m.Encoding
	}
	return Encoding_PROTO
}

func (m *ChannelMeta) GetRevision() Revision {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *ChannelMeta) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

type Channel struct {
	ID          ChannelID `protobuf:"bytes,1,opt,name=id,proto3,casttype=ChannelID" json:"id,omitempty"`
	ChannelMeta `protobuf:"bytes,2,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Spec        ChannelSpec   `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec"`
	Status      ChannelStatus `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
}

func (m *Channel) Reset()         { *m = Channel{} }
func (m *Channel) String() string { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()    {}
func (*Channel) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{25}
}
func (m *Channel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Channel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Channel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Channel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Channel.Merge(m, src)
}
func (m *Channel) XXX_Size() int {
	return m.Size()
}
func (m *Channel) XXX_DiscardUnknown() {
	xxx_messageInfo_Channel.DiscardUnknown(m)
}

var xxx_messageInfo_Channel proto.InternalMessageInfo

func (m *Channel) GetID() ChannelID {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Channel) GetSpec() ChannelSpec {
	if m != nil {
		return m.Spec
	}
	return ChannelSpec{}
}

func (m *Channel) GetStatus() ChannelStatus {
	if m != nil {
		return m.Status
	}
	return ChannelStatus{}
}

type ChannelSpec struct {
	SubscriptionSpec   `protobuf:"bytes,1,opt,name=subscription,proto3,embedded=subscription" json:"subscription"`
	TransactionTimeout *time.Duration `protobuf:"bytes,2,opt,name=transaction_timeout,json=transactionTimeout,proto3,stdduration" json:"transaction_timeout,omitempty"`
}

func (m *ChannelSpec) Reset()         { *m = ChannelSpec{} }
func (m *ChannelSpec) String() string { return proto.CompactTextString(m) }
func (*ChannelSpec) ProtoMessage()    {}
func (*ChannelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{26}
}
func (m *ChannelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelSpec.Merge(m, src)
}
func (m *ChannelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChannelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelSpec proto.InternalMessageInfo

func (m *ChannelSpec) GetTransactionTimeout() *time.Duration {
	if m != nil {
		return m.TransactionTimeout
	}
	return nil
}

type ChannelStatus struct {
	Phase     ChannelPhase `protobuf:"varint,1,opt,name=phase,proto3,enum=onos.e2t.e2.v1beta1.ChannelPhase" json:"phase,omitempty"`
	State     ChannelState `protobuf:"varint,2,opt,name=state,proto3,enum=onos.e2t.e2.v1beta1.ChannelState" json:"state,omitempty"`
	Error     *Error       `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Timestamp *time.Time   `protobuf:"bytes,4,opt,name=timestamp,proto3,stdtime" json:"timestamp,omitempty"`
	Term      TermID       `protobuf:"varint,5,opt,name=term,proto3,casttype=TermID" json:"term,omitempty"`
	Master    MasterID     `protobuf:"bytes,6,opt,name=master,proto3,casttype=MasterID" json:"master,omitempty"`
}

func (m *ChannelStatus) Reset()         { *m = ChannelStatus{} }
func (m *ChannelStatus) String() string { return proto.CompactTextString(m) }
func (*ChannelStatus) ProtoMessage()    {}
func (*ChannelStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{27}
}
func (m *ChannelStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelStatus.Merge(m, src)
}
func (m *ChannelStatus) XXX_Size() int {
	return m.Size()
}
func (m *ChannelStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelStatus proto.InternalMessageInfo

func (m *ChannelStatus) GetPhase() ChannelPhase {
	if m != nil {
		return m.Phase
	}
	return ChannelPhase_CHANNEL_CLOSED
}

func (m *ChannelStatus) GetState() ChannelState {
	if m != nil {
		return m.State
	}
	return ChannelState_CHANNEL_PENDING
}

func (m *ChannelStatus) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ChannelStatus) GetTimestamp() *time.Time {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *ChannelStatus) GetTerm() TermID {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ChannelStatus) GetMaster() MasterID {
	if m != nil {
		return m.Master
	}
	return ""
}

type SubscriptionMeta struct {
	E2NodeID     E2NodeID     `protobuf:"bytes,1,opt,name=e2_node_id,json=e2NodeId,proto3,casttype=E2NodeID" json:"e2_node_id,omitempty"`
	ServiceModel ServiceModel `protobuf:"bytes,2,opt,name=service_model,json=serviceModel,proto3" json:"service_model"`
	Encoding     Encoding     `protobuf:"varint,3,opt,name=encoding,proto3,enum=onos.e2t.e2.v1beta1.Encoding" json:"encoding,omitempty"`
	Revision     Revision     `protobuf:"varint,4,opt,name=revision,proto3,casttype=Revision" json:"revision,omitempty"`
	Finalizers   []string     `protobuf:"bytes,5,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
}

func (m *SubscriptionMeta) Reset()         { *m = SubscriptionMeta{} }
func (m *SubscriptionMeta) String() string { return proto.CompactTextString(m) }
func (*SubscriptionMeta) ProtoMessage()    {}
func (*SubscriptionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{28}
}
func (m *SubscriptionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionMeta.Merge(m, src)
}
func (m *SubscriptionMeta) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionMeta proto.InternalMessageInfo

func (m *SubscriptionMeta) GetE2NodeID() E2NodeID {
	if m != nil {
		return m.E2NodeID
	}
	return ""
}

func (m *SubscriptionMeta) GetServiceModel() ServiceModel {
	if m != nil {
		return m.ServiceModel
	}
	return ServiceModel{}
}

func (m *SubscriptionMeta) GetEncoding() Encoding {
	if m != nil {
		return m.Encoding
	}
	return Encoding_PROTO
}

func (m *SubscriptionMeta) GetRevision() Revision {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *SubscriptionMeta) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

type Subscription struct {
	ID               SubscriptionID `protobuf:"bytes,1,opt,name=id,proto3,casttype=SubscriptionID" json:"id,omitempty"`
	SubscriptionMeta `protobuf:"bytes,2,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Spec             SubscriptionSpec   `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec"`
	Status           SubscriptionStatus `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
}

func (m *Subscription) Reset()         { *m = Subscription{} }
func (m *Subscription) String() string { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()    {}
func (*Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{29}
}
func (m *Subscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscription.Merge(m, src)
}
func (m *Subscription) XXX_Size() int {
	return m.Size()
}
func (m *Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Subscription proto.InternalMessageInfo

func (m *Subscription) GetID() SubscriptionID {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Subscription) GetSpec() SubscriptionSpec {
	if m != nil {
		return m.Spec
	}
	return SubscriptionSpec{}
}

func (m *Subscription) GetStatus() SubscriptionStatus {
	if m != nil {
		return m.Status
	}
	return SubscriptionStatus{}
}

type SubscriptionStatus struct {
	Phase    SubscriptionPhase `protobuf:"varint,1,opt,name=phase,proto3,enum=onos.e2t.e2.v1beta1.SubscriptionPhase" json:"phase,omitempty"`
	State    SubscriptionState `protobuf:"varint,2,opt,name=state,proto3,enum=onos.e2t.e2.v1beta1.SubscriptionState" json:"state,omitempty"`
	Error    *Error            `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Channels []ChannelID       `protobuf:"bytes,4,rep,name=channels,proto3,casttype=ChannelID" json:"channels,omitempty"`
	Term     TermID            `protobuf:"varint,5,opt,name=term,proto3,casttype=TermID" json:"term,omitempty"`
	Master   MasterID          `protobuf:"bytes,6,opt,name=master,proto3,casttype=MasterID" json:"master,omitempty"`
}

func (m *SubscriptionStatus) Reset()         { *m = SubscriptionStatus{} }
func (m *SubscriptionStatus) String() string { return proto.CompactTextString(m) }
func (*SubscriptionStatus) ProtoMessage()    {}
func (*SubscriptionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcfc9e59554ac999, []int{30}
}
func (m *SubscriptionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionStatus.Merge(m, src)
}
func (m *SubscriptionStatus) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionStatus proto.InternalMessageInfo

func (m *SubscriptionStatus) GetPhase() SubscriptionPhase {
	if m != nil {
		return m.Phase
	}
	return SubscriptionPhase_SUBSCRIPTION_CLOSED
}

func (m *SubscriptionStatus) GetState() SubscriptionState {
	if m != nil {
		return m.State
	}
	return SubscriptionState_SUBSCRIPTION_PENDING
}

func (m *SubscriptionStatus) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SubscriptionStatus) GetChannels() []ChannelID {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *SubscriptionStatus) GetTerm() TermID {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *SubscriptionStatus) GetMaster() MasterID {
	if m != nil {
		return m.Master
	}
	return ""
}

func init() {
	proto.RegisterEnum("onos.e2t.e2.v1beta1.ActionType", ActionType_name, ActionType_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.SubsequentActionType", SubsequentActionType_name, SubsequentActionType_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.SubsequentActionType", SubsequentActionType_name, SubsequentActionType_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.TimeToWait", TimeToWait_name, TimeToWait_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.TimeToWait", TimeToWait_name, TimeToWait_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.ChannelEventType", ChannelEventType_name, ChannelEventType_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.ChannelEventType", ChannelEventType_name, ChannelEventType_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.SubscriptionEventType", SubscriptionEventType_name, SubscriptionEventType_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.SubscriptionEventType", SubscriptionEventType_name, SubscriptionEventType_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.ChannelPhase", ChannelPhase_name, ChannelPhase_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.ChannelPhase", ChannelPhase_name, ChannelPhase_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.ChannelState", ChannelState_name, ChannelState_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.ChannelState", ChannelState_name, ChannelState_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.SubscriptionPhase", SubscriptionPhase_name, SubscriptionPhase_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.SubscriptionPhase", SubscriptionPhase_name, SubscriptionPhase_value)
	proto.RegisterEnum("onos.e2t.e2.v1beta1.SubscriptionState", SubscriptionState_name, SubscriptionState_value)
	golang_proto.RegisterEnum("onos.e2t.e2.v1beta1.SubscriptionState", SubscriptionState_name, SubscriptionState_value)
	proto.RegisterType((*SubscribeRequest)(nil), "onos.e2t.e2.v1beta1.SubscribeRequest")
	golang_proto.RegisterType((*SubscribeRequest)(nil), "onos.e2t.e2.v1beta1.SubscribeRequest")
	proto.RegisterType((*SubscribeResponse)(nil), "onos.e2t.e2.v1beta1.SubscribeResponse")
	golang_proto.RegisterType((*SubscribeResponse)(nil), "onos.e2t.e2.v1beta1.SubscribeResponse")
	proto.RegisterType((*UnsubscribeRequest)(nil), "onos.e2t.e2.v1beta1.UnsubscribeRequest")
	golang_proto.RegisterType((*UnsubscribeRequest)(nil), "onos.e2t.e2.v1beta1.UnsubscribeRequest")
	proto.RegisterType((*UnsubscribeResponse)(nil), "onos.e2t.e2.v1beta1.UnsubscribeResponse")
	golang_proto.RegisterType((*UnsubscribeResponse)(nil), "onos.e2t.e2.v1beta1.UnsubscribeResponse")
	proto.RegisterType((*SubscriptionSpec)(nil), "onos.e2t.e2.v1beta1.SubscriptionSpec")
	golang_proto.RegisterType((*SubscriptionSpec)(nil), "onos.e2t.e2.v1beta1.SubscriptionSpec")
	proto.RegisterType((*EventTrigger)(nil), "onos.e2t.e2.v1beta1.EventTrigger")
	golang_proto.RegisterType((*EventTrigger)(nil), "onos.e2t.e2.v1beta1.EventTrigger")
	proto.RegisterType((*Action)(nil), "onos.e2t.e2.v1beta1.Action")
	golang_proto.RegisterType((*Action)(nil), "onos.e2t.e2.v1beta1.Action")
	proto.RegisterType((*SubsequentAction)(nil), "onos.e2t.e2.v1beta1.SubsequentAction")
	golang_proto.RegisterType((*SubsequentAction)(nil), "onos.e2t.e2.v1beta1.SubsequentAction")
	proto.RegisterType((*Acknowledgement)(nil), "onos.e2t.e2.v1beta1.Acknowledgement")
	golang_proto.RegisterType((*Acknowledgement)(nil), "onos.e2t.e2.v1beta1.Acknowledgement")
	proto.RegisterType((*Indication)(nil), "onos.e2t.e2.v1beta1.Indication")
	golang_proto.RegisterType((*Indication)(nil), "onos.e2t.e2.v1beta1.Indication")
	proto.RegisterType((*GetChannelRequest)(nil), "onos.e2t.e2.v1beta1.GetChannelRequest")
	golang_proto.RegisterType((*GetChannelRequest)(nil), "onos.e2t.e2.v1beta1.GetChannelRequest")
	proto.RegisterType((*GetChannelResponse)(nil), "onos.e2t.e2.v1beta1.GetChannelResponse")
	golang_proto.RegisterType((*GetChannelResponse)(nil), "onos.e2t.e2.v1beta1.GetChannelResponse")
	proto.RegisterType((*ListChannelsRequest)(nil), "onos.e2t.e2.v1beta1.ListChannelsRequest")
	golang_proto.RegisterType((*ListChannelsRequest)(nil), "onos.e2t.e2.v1beta1.ListChannelsRequest")
	proto.RegisterType((*ListChannelsResponse)(nil), "onos.e2t.e2.v1beta1.ListChannelsResponse")
	golang_proto.RegisterType((*ListChannelsResponse)(nil), "onos.e2t.e2.v1beta1.ListChannelsResponse")
	proto.RegisterType((*WatchChannelsRequest)(nil), "onos.e2t.e2.v1beta1.WatchChannelsRequest")
	golang_proto.RegisterType((*WatchChannelsRequest)(nil), "onos.e2t.e2.v1beta1.WatchChannelsRequest")
	proto.RegisterType((*WatchChannelsResponse)(nil), "onos.e2t.e2.v1beta1.WatchChannelsResponse")
	golang_proto.RegisterType((*WatchChannelsResponse)(nil), "onos.e2t.e2.v1beta1.WatchChannelsResponse")
	proto.RegisterType((*ChannelEvent)(nil), "onos.e2t.e2.v1beta1.ChannelEvent")
	golang_proto.RegisterType((*ChannelEvent)(nil), "onos.e2t.e2.v1beta1.ChannelEvent")
	proto.RegisterType((*GetSubscriptionRequest)(nil), "onos.e2t.e2.v1beta1.GetSubscriptionRequest")
	golang_proto.RegisterType((*GetSubscriptionRequest)(nil), "onos.e2t.e2.v1beta1.GetSubscriptionRequest")
	proto.RegisterType((*GetSubscriptionResponse)(nil), "onos.e2t.e2.v1beta1.GetSubscriptionResponse")
	golang_proto.RegisterType((*GetSubscriptionResponse)(nil), "onos.e2t.e2.v1beta1.GetSubscriptionResponse")
	proto.RegisterType((*ListSubscriptionsRequest)(nil), "onos.e2t.e2.v1beta1.ListSubscriptionsRequest")
	golang_proto.RegisterType((*ListSubscriptionsRequest)(nil), "onos.e2t.e2.v1beta1.ListSubscriptionsRequest")
	proto.RegisterType((*ListSubscriptionsResponse)(nil), "onos.e2t.e2.v1beta1.ListSubscriptionsResponse")
	golang_proto.RegisterType((*ListSubscriptionsResponse)(nil), "onos.e2t.e2.v1beta1.ListSubscriptionsResponse")
	proto.RegisterType((*WatchSubscriptionsRequest)(nil), "onos.e2t.e2.v1beta1.WatchSubscriptionsRequest")
	golang_proto.RegisterType((*WatchSubscriptionsRequest)(nil), "onos.e2t.e2.v1beta1.WatchSubscriptionsRequest")
	proto.RegisterType((*WatchSubscriptionsResponse)(nil), "onos.e2t.e2.v1beta1.WatchSubscriptionsResponse")
	golang_proto.RegisterType((*WatchSubscriptionsResponse)(nil), "onos.e2t.e2.v1beta1.WatchSubscriptionsResponse")
	proto.RegisterType((*SubscriptionEvent)(nil), "onos.e2t.e2.v1beta1.SubscriptionEvent")
	golang_proto.RegisterType((*SubscriptionEvent)(nil), "onos.e2t.e2.v1beta1.SubscriptionEvent")
	proto.RegisterType((*ChannelMeta)(nil), "onos.e2t.e2.v1beta1.ChannelMeta")
	golang_proto.RegisterType((*ChannelMeta)(nil), "onos.e2t.e2.v1beta1.ChannelMeta")
	proto.RegisterType((*Channel)(nil), "onos.e2t.e2.v1beta1.Channel")
	golang_proto.RegisterType((*Channel)(nil), "onos.e2t.e2.v1beta1.Channel")
	proto.RegisterType((*ChannelSpec)(nil), "onos.e2t.e2.v1beta1.ChannelSpec")
	golang_proto.RegisterType((*ChannelSpec)(nil), "onos.e2t.e2.v1beta1.ChannelSpec")
	proto.RegisterType((*ChannelStatus)(nil), "onos.e2t.e2.v1beta1.ChannelStatus")
	golang_proto.RegisterType((*ChannelStatus)(nil), "onos.e2t.e2.v1beta1.ChannelStatus")
	proto.RegisterType((*SubscriptionMeta)(nil), "onos.e2t.e2.v1beta1.SubscriptionMeta")
	golang_proto.RegisterType((*SubscriptionMeta)(nil), "onos.e2t.e2.v1beta1.SubscriptionMeta")
	proto.RegisterType((*Subscription)(nil), "onos.e2t.e2.v1beta1.Subscription")
	golang_proto.RegisterType((*Subscription)(nil), "onos.e2t.e2.v1beta1.Subscription")
	proto.RegisterType((*SubscriptionStatus)(nil), "onos.e2t.e2.v1beta1.SubscriptionStatus")
	golang_proto.RegisterType((*SubscriptionStatus)(nil), "onos.e2t.e2.v1beta1.SubscriptionStatus")
}

func init() {
	proto.RegisterFile("onos/e2t/e2/v1beta1/subscription.proto", fileDescriptor_dcfc9e59554ac999)
}
func init() {
	golang_proto.RegisterFile("onos/e2t/e2/v1beta1/subscription.proto", fileDescriptor_dcfc9e59554ac999)
}

var fileDescriptor_dcfc9e59554ac999 = []byte{
	// 2105 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x73, 0x1b, 0x59,
	0xd5, 0x57, 0xeb, 0x65, 0xe9, 0x44, 0xb6, 0xdb, 0xd7, 0x76, 0x22, 0x2b, 0xf9, 0x24, 0x4f, 0x27,
	0x93, 0x71, 0xfc, 0x81, 0xec, 0x28, 0x93, 0x61, 0x02, 0x19, 0x83, 0x1e, 0x4d, 0xd2, 0x8c, 0xf5,
	0xa0, 0x25, 0xc7, 0x15, 0x18, 0x4a, 0xd3, 0x96, 0x6e, 0x64, 0x31, 0x56, 0xb7, 0x50, 0xb7, 0x93,
	0x0a, 0x4b, 0xaa, 0x28, 0xb6, 0xb3, 0x60, 0xc1, 0x66, 0xaa, 0xa6, 0x0a, 0x36, 0x6c, 0x81, 0x0d,
	0x3b, 0xaa, 0x28, 0xaa, 0x66, 0x99, 0x0d, 0x55, 0xac, 0x0c, 0x38, 0x5b, 0xfe, 0x82, 0x59, 0x51,
	0xf7, 0xf6, 0x55, 0xeb, 0xf6, 0x43, 0xb2, 0xf2, 0x58, 0xb0, 0x93, 0xce, 0xf9, 0x9d, 0x73, 0x7e,
	0xf7, 0xdc, 0x73, 0x4e, 0xdf, 0x7b, 0xe1, 0xa6, 0xa1, 0x1b, 0xe6, 0x0e, 0x2e, 0x58, 0x3b, 0xb8,
	0xb0, 0xf3, 0xf4, 0xf6, 0x11, 0xb6, 0xb4, 0xdb, 0x3b, 0xe6, 0xe9, 0x91, 0xd9, 0x19, 0xf5, 0x87,
	0x56, 0xdf, 0xd0, 0xf3, 0xc3, 0x91, 0x61, 0x19, 0x68, 0x95, 0xe0, 0xf2, 0xb8, 0x60, 0xe5, 0x71,
	0x21, 0xcf, 0x70, 0x99, 0xb5, 0x9e, 0xd1, 0x33, 0xa8, 0x7e, 0x87, 0xfc, 0xb2, 0xa1, 0x99, 0x6b,
	0x41, 0x2e, 0x71, 0x81, 0x69, 0x73, 0x3d, 0xc3, 0xe8, 0x9d, 0xe0, 0x1d, 0xfa, 0xef, 0xe8, 0xf4,
	0xc9, 0x8e, 0xd5, 0x1f, 0x60, 0xd3, 0xd2, 0x06, 0x43, 0x06, 0xc8, 0x7a, 0x01, 0xdd, 0xd3, 0x91,
	0x36, 0x61, 0x22, 0xfd, 0x2d, 0x0c, 0x62, 0xd3, 0x26, 0x78, 0x84, 0x55, 0xfc, 0xb3, 0x53, 0x6c,
	0x5a, 0xa8, 0x0c, 0x0b, 0xc7, 0x58, 0xeb, 0xe2, 0x91, 0x99, 0x16, 0x36, 0x85, 0xad, 0x4b, 0x85,
	0xeb, 0xf9, 0x00, 0xc2, 0x79, 0x06, 0x7f, 0x68, 0x43, 0x4b, 0xd1, 0xaf, 0xce, 0x72, 0x21, 0x75,
	0x6c, 0x89, 0x14, 0x58, 0xb2, 0x46, 0x9a, 0x6e, 0x6a, 0x1d, 0x12, 0xae, 0xdd, 0xef, 0xa6, 0xc3,
	0x9b, 0xc2, 0x56, 0xb2, 0x24, 0x9d, 0x9f, 0xe5, 0x16, 0x5b, 0x13, 0x8d, 0x52, 0xf9, 0xda, 0x2b,
	0x50, 0x17, 0x39, 0x4b, 0xa5, 0x8b, 0xea, 0x90, 0xe2, 0x93, 0x98, 0x8e, 0x50, 0x52, 0xef, 0x06,
	0x92, 0x6a, 0x72, 0xc0, 0xe6, 0x10, 0x77, 0x18, 0x2d, 0x97, 0x03, 0xd4, 0x80, 0x55, 0x9e, 0x1b,
	0x49, 0x9a, 0x71, 0x6a, 0xa5, 0xa3, 0xd4, 0xef, 0x46, 0xde, 0xce, 0x59, 0x7e, 0x9c, 0xb3, 0x7c,
	0x85, 0xe5, 0xac, 0x14, 0xfd, 0xcd, 0x3f, 0x73, 0x82, 0x8a, 0x38, 0xdb, 0x96, 0x6d, 0x2a, 0xfd,
	0x5b, 0x80, 0x15, 0x2e, 0x8f, 0xe6, 0xd0, 0xd0, 0x4d, 0x8c, 0x2a, 0xde, 0x44, 0xde, 0x98, 0x92,
	0x48, 0x1b, 0x3f, 0x25, 0x93, 0x1f, 0x42, 0x44, 0xeb, 0x7c, 0x46, 0xd3, 0x37, 0xcd, 0x43, 0xb1,
	0xf3, 0x99, 0x6e, 0x3c, 0x3b, 0xc1, 0xdd, 0x1e, 0x1e, 0x60, 0xdd, 0x7a, 0x18, 0x52, 0x89, 0x09,
	0x2a, 0x02, 0xf4, 0xf5, 0x6e, 0xbf, 0xa3, 0x71, 0x69, 0xcb, 0x05, 0x3a, 0x50, 0x1c, 0xd8, 0xc3,
	0x90, 0xca, 0x19, 0x95, 0x92, 0xb0, 0x30, 0xc0, 0xa6, 0xa9, 0xf5, 0xb0, 0xf4, 0x3b, 0x01, 0xd0,
	0x81, 0x6e, 0xfe, 0x8f, 0x57, 0x8b, 0xf4, 0x63, 0x58, 0x75, 0xb1, 0x7c, 0x9b, 0x7b, 0x21, 0x7d,
	0x21, 0x38, 0xfd, 0xe2, 0x94, 0x18, 0xda, 0x87, 0x45, 0xfc, 0x14, 0xeb, 0x56, 0xdb, 0x1a, 0xf5,
	0x7b, 0x3d, 0x3c, 0x62, 0x01, 0xde, 0x09, 0x0c, 0x20, 0x13, 0x64, 0xcb, 0x06, 0x8e, 0x8b, 0x13,
	0x73, 0x32, 0xf4, 0x1d, 0x58, 0xb0, 0xd7, 0x62, 0xa6, 0xc3, 0x9b, 0x91, 0xad, 0x4b, 0x85, 0xab,
	0x53, 0xb6, 0xdc, 0x2e, 0x49, 0x9b, 0x1f, 0xb3, 0x90, 0xb6, 0x20, 0xc5, 0x07, 0x40, 0x69, 0x58,
	0x18, 0x6a, 0xcf, 0x4f, 0x0c, 0xad, 0x4b, 0x49, 0xa5, 0xd4, 0xf1, 0x5f, 0xe9, 0xaf, 0x02, 0xc4,
	0x6d, 0x1f, 0xe8, 0x32, 0x84, 0xfb, 0xb6, 0x3e, 0x56, 0x8a, 0x9f, 0x9f, 0xe5, 0xc2, 0x4a, 0x45,
	0x0d, 0xf7, 0xbb, 0xe8, 0x0e, 0x44, 0xad, 0xe7, 0x43, 0x4c, 0xb7, 0x62, 0x69, 0x4a, 0xe1, 0xd8,
	0x2e, 0x5a, 0xcf, 0x87, 0x58, 0xa5, 0x60, 0x3e, 0x62, 0xc4, 0x15, 0x11, 0xa9, 0xb0, 0x42, 0xb6,
	0x85, 0xd4, 0x81, 0x6e, 0xb5, 0x6d, 0xc6, 0xac, 0xe7, 0xa6, 0xf7, 0xb2, 0x8d, 0xb6, 0xa3, 0xa8,
	0xa2, 0xe9, 0x91, 0x48, 0xbf, 0x66, 0xfb, 0xc1, 0x0b, 0xd1, 0x47, 0x8c, 0xb7, 0x40, 0x79, 0xdf,
	0x9a, 0xcb, 0x37, 0xb7, 0x82, 0x22, 0xa4, 0xc8, 0x44, 0x68, 0x5b, 0x46, 0xfb, 0x99, 0xd6, 0xb7,
	0x66, 0x2e, 0x9f, 0xf4, 0x7f, 0xcb, 0x38, 0xd4, 0xfa, 0x96, 0x0a, 0x96, 0xf3, 0x5b, 0xda, 0x87,
	0x65, 0x4f, 0x4b, 0xa2, 0x7b, 0x00, 0x9d, 0x63, 0x4d, 0xd7, 0xf1, 0x49, 0x9b, 0x25, 0x3b, 0x59,
	0xca, 0x9c, 0x9f, 0xe5, 0x92, 0x65, 0x5b, 0x4a, 0x2b, 0x7b, 0xf2, 0x47, 0x4d, 0x32, 0xb4, 0xd2,
	0x95, 0xf6, 0x00, 0x26, 0xfd, 0x89, 0x2e, 0x43, 0xdc, 0xae, 0x46, 0xb6, 0xa3, 0xec, 0x1f, 0x9f,
	0xf8, 0xb0, 0x7b, 0xab, 0x6b, 0xb0, 0xf2, 0x00, 0x5b, 0xcc, 0xf5, 0xb8, 0x6d, 0xdf, 0x80, 0x8f,
	0x0a, 0x88, 0xf7, 0xc7, 0x1a, 0xec, 0x3e, 0x2c, 0x30, 0x08, 0xab, 0xff, 0x6b, 0x81, 0x19, 0x63,
	0x66, 0xe3, 0xc2, 0x65, 0x26, 0xd2, 0x3a, 0xac, 0xee, 0xf7, 0xcd, 0xb1, 0x53, 0x93, 0xb1, 0x94,
	0x1e, 0xc1, 0x9a, 0x5b, 0xcc, 0x82, 0xed, 0x41, 0x82, 0x59, 0x92, 0x76, 0x8e, 0xcc, 0x19, 0xcd,
	0xb1, 0x91, 0xee, 0xc0, 0xda, 0xa1, 0x66, 0x75, 0x8e, 0x3d, 0xf1, 0xd0, 0x55, 0x48, 0xea, 0x46,
	0x7b, 0x84, 0x87, 0x27, 0xda, 0x73, 0xba, 0x8c, 0x84, 0x9a, 0xd0, 0x0d, 0x95, 0xfe, 0x97, 0x1e,
	0xc1, 0xba, 0xc7, 0x88, 0xb1, 0xf9, 0x08, 0x62, 0xb4, 0x85, 0x67, 0x36, 0x3e, 0xb3, 0xa2, 0xed,
	0xc9, 0xf8, 0xd8, 0x56, 0xd2, 0xaf, 0x04, 0x48, 0xf1, 0x5a, 0x74, 0xcf, 0x55, 0xc0, 0xef, 0x5e,
	0xe8, 0x8e, 0x2b, 0x5e, 0x6e, 0x17, 0xc2, 0xaf, 0xbe, 0x0b, 0x3d, 0xb8, 0xfc, 0x00, 0x5b, 0xfc,
	0x80, 0x1b, 0x27, 0xa6, 0x0a, 0xcb, 0xfc, 0x27, 0x74, 0x52, 0x33, 0x37, 0xce, 0xcf, 0x72, 0x4b,
	0xbc, 0x05, 0x2d, 0x1c, 0x8f, 0x44, 0x5d, 0xe2, 0x8d, 0x95, 0xae, 0xf4, 0x04, 0xae, 0xf8, 0x02,
	0xb1, 0x64, 0x7e, 0xec, 0xf9, 0xda, 0xcf, 0xca, 0x29, 0xef, 0x20, 0xe8, 0x4b, 0x2f, 0x65, 0x20,
	0x4d, 0xea, 0x87, 0xc7, 0x39, 0xb5, 0xf5, 0x53, 0xd8, 0x08, 0xd0, 0x31, 0x16, 0x55, 0x58, 0xe4,
	0x1d, 0x8d, 0xab, 0x6c, 0x6e, 0x1a, 0x6e, 0x6b, 0xe9, 0x43, 0xd8, 0xa0, 0xa5, 0x13, 0x44, 0x64,
	0x76, 0xd1, 0x7d, 0x0a, 0x99, 0x20, 0x4b, 0x46, 0xb3, 0xe4, 0xae, 0xbc, 0x9b, 0x17, 0xd2, 0x0b,
	0x28, 0xbf, 0x2f, 0x27, 0x67, 0x97, 0x09, 0x04, 0xed, 0xb9, 0x6a, 0x70, 0x7b, 0x3e, 0xc7, 0x5c,
	0x21, 0x7a, 0xb7, 0x31, 0xfc, 0x26, 0xdb, 0xf8, 0xfb, 0x28, 0x5c, 0x62, 0x25, 0x5b, 0xc5, 0x96,
	0x86, 0x6e, 0x41, 0x5c, 0x1b, 0x0e, 0x27, 0x45, 0x88, 0xce, 0xcf, 0x72, 0xb1, 0xe2, 0x70, 0x48,
	0x6b, 0xcf, 0xfe, 0xa1, 0xc6, 0xb4, 0xe1, 0x50, 0xe9, 0xa2, 0x1f, 0xc0, 0x32, 0x85, 0xea, 0xa6,
	0xa5, 0xe9, 0x1d, 0xec, 0x39, 0x5a, 0x10, 0x28, 0xd3, 0xd8, 0x47, 0x0b, 0x97, 0x40, 0x5d, 0xd4,
	0xb8, 0xbf, 0x5d, 0xf4, 0x01, 0x00, 0x2e, 0xb4, 0x75, 0xa3, 0x4b, 0xdd, 0x44, 0xa8, 0x9b, 0xf4,
	0xf9, 0x59, 0x2e, 0x21, 0x17, 0x6a, 0x46, 0xd7, 0xf6, 0xe0, 0xfc, 0x56, 0x13, 0xd8, 0xfe, 0xd5,
	0x0d, 0x38, 0xdd, 0x44, 0x5f, 0xf7, 0x2c, 0x1c, 0xd0, 0x87, 0xb1, 0xd7, 0xef, 0x43, 0x72, 0x74,
	0x31, 0xf1, 0xe8, 0x69, 0xbf, 0x83, 0xdb, 0x03, 0xa3, 0x8b, 0x4f, 0xd2, 0xf1, 0x59, 0xdb, 0x64,
	0x23, 0xab, 0x04, 0xe8, 0x6c, 0x13, 0x27, 0x43, 0xf7, 0x20, 0x81, 0xf5, 0x8e, 0xd1, 0xed, 0xeb,
	0xbd, 0xf4, 0x02, 0xad, 0x9b, 0xff, 0x0b, 0x3e, 0x03, 0x31, 0x90, 0xea, 0xc0, 0xd1, 0x16, 0x24,
	0x46, 0xf8, 0x69, 0xdf, 0x24, 0xa5, 0x92, 0xd8, 0x14, 0xb6, 0xa2, 0xa5, 0x14, 0x49, 0xa6, 0xca,
	0x64, 0xaa, 0xa3, 0x45, 0x59, 0x80, 0x27, 0x7d, 0x5d, 0x3b, 0xe9, 0xff, 0x9c, 0x9c, 0xe5, 0x92,
	0x9b, 0x91, 0xad, 0xa4, 0xca, 0x49, 0xa4, 0xff, 0x08, 0xb0, 0xc0, 0x6a, 0x05, 0x5d, 0x77, 0x4e,
	0x36, 0xc9, 0xd2, 0xaa, 0x7d, 0xb2, 0x71, 0x7f, 0xd5, 0xc8, 0x31, 0x67, 0x0f, 0xa2, 0x03, 0x6c,
	0x69, 0xac, 0x42, 0x37, 0x67, 0xcd, 0x4b, 0x52, 0x7c, 0xa5, 0x04, 0x59, 0xf9, 0x8b, 0xb3, 0x9c,
	0xa0, 0x52, 0x3b, 0xf4, 0x6d, 0x88, 0x9a, 0x43, 0xdc, 0x61, 0xe7, 0xeb, 0x99, 0xf6, 0xdc, 0x8d,
	0x84, 0xda, 0xa0, 0xef, 0x41, 0xdc, 0xb4, 0x34, 0xeb, 0xd4, 0x64, 0x07, 0x21, 0x69, 0xa6, 0x35,
	0x45, 0x32, 0x7b, 0x66, 0x27, 0xfd, 0x49, 0x70, 0x5a, 0x83, 0x1e, 0x46, 0x9b, 0x81, 0xe3, 0x73,
	0xce, 0xcb, 0xd2, 0x64, 0x69, 0x73, 0x5d, 0x98, 0xc2, 0xaf, 0x7f, 0x61, 0xfa, 0x73, 0x18, 0x16,
	0x5d, 0xcb, 0x42, 0xdf, 0x82, 0xd8, 0xf0, 0x58, 0x33, 0xc7, 0x13, 0x67, 0xe6, 0x47, 0xb4, 0x41,
	0x80, 0xaa, 0x8d, 0x27, 0x86, 0x24, 0x17, 0xe3, 0x73, 0xea, 0x3b, 0x17, 0xa5, 0x10, 0xab, 0x36,
	0x1e, 0xed, 0x42, 0x0c, 0x8f, 0x46, 0xc6, 0x88, 0xed, 0x5c, 0x26, 0xb8, 0x56, 0x09, 0x42, 0xb5,
	0x81, 0x68, 0x0f, 0x92, 0xce, 0x0d, 0x9b, 0xed, 0x58, 0xc6, 0xb7, 0xfa, 0xd6, 0x18, 0x51, 0x8a,
	0x7e, 0x4e, 0x96, 0x3f, 0x31, 0x41, 0x59, 0x88, 0x5a, 0x78, 0x34, 0xa0, 0x2d, 0x1b, 0x2d, 0xc1,
	0xd7, 0x67, 0xb9, 0x78, 0x0b, 0x8f, 0x06, 0x4a, 0x45, 0xa5, 0x72, 0x74, 0x03, 0xe2, 0x03, 0xcd,
	0xb4, 0xf0, 0x88, 0xf6, 0x61, 0xd2, 0xee, 0x81, 0x2a, 0x95, 0x28, 0x15, 0x95, 0xe9, 0xa4, 0x2f,
	0xc2, 0xee, 0x4b, 0x08, 0x1d, 0x89, 0xee, 0xd9, 0x24, 0xcc, 0x3d, 0x9b, 0x7c, 0x13, 0x20, 0xfc,
	0xb6, 0x26, 0x40, 0xe4, 0xf5, 0x27, 0x40, 0xf4, 0x15, 0x26, 0x40, 0xcc, 0x37, 0x01, 0x7e, 0x19,
	0x86, 0x14, 0x9f, 0x1f, 0xb4, 0xc5, 0x8d, 0x81, 0xb4, 0x33, 0x06, 0xbc, 0xb3, 0x91, 0xcc, 0x82,
	0xb2, 0x6b, 0x16, 0x5c, 0xdc, 0x35, 0x81, 0x03, 0xe1, 0xbb, 0xae, 0x81, 0xf0, 0x4a, 0xef, 0x14,
	0xf6, 0x54, 0x90, 0x3d, 0x53, 0xe1, 0xbd, 0x8b, 0x5d, 0x04, 0x8d, 0x86, 0x3f, 0x86, 0x01, 0xf9,
	0x41, 0xe8, 0xbe, 0xbb, 0xd1, 0x2e, 0x3e, 0x33, 0xb8, 0xba, 0xed, 0xbe, 0xbb, 0xdb, 0x6e, 0xce,
	0x45, 0xed, 0x0d, 0x5a, 0xee, 0x16, 0x77, 0xd2, 0x8f, 0x92, 0xad, 0x2e, 0x2d, 0xba, 0x47, 0xb8,
	0xa3, 0x7e, 0x3b, 0xdd, 0xb5, 0xdd, 0x02, 0x98, 0x5c, 0x09, 0xd1, 0x65, 0x40, 0xc5, 0x72, 0x4b,
	0xa9, 0xd7, 0xda, 0xad, 0xc7, 0x0d, 0xb9, 0xad, 0xca, 0x8d, 0xba, 0xda, 0x12, 0x43, 0x5e, 0xb9,
	0x52, 0x6b, 0xca, 0x6a, 0x4b, 0x14, 0xbc, 0xf2, 0x46, 0x7d, 0x5f, 0x29, 0x3f, 0x16, 0xc3, 0xdb,
	0x9f, 0xc0, 0x5a, 0xd0, 0x95, 0x13, 0x5d, 0x87, 0x5c, 0xf3, 0xa0, 0xd4, 0x94, 0x7f, 0x78, 0x20,
	0xd7, 0x5a, 0x6d, 0xde, 0xb4, 0x5c, 0xaf, 0xb5, 0x94, 0xda, 0x81, 0x2c, 0x86, 0x50, 0x0e, 0xae,
	0x4e, 0x01, 0x1d, 0x16, 0x95, 0x96, 0x28, 0x6c, 0xff, 0x21, 0x02, 0x30, 0xb9, 0x8a, 0xa2, 0x75,
	0x58, 0x69, 0x29, 0x55, 0xb9, 0xdd, 0xaa, 0x53, 0x40, 0xfb, 0x47, 0xb2, 0x5a, 0x17, 0x43, 0x3e,
	0xf1, 0xe1, 0xed, 0x6a, 0x53, 0x14, 0xfc, 0xe2, 0x42, 0xb5, 0x29, 0x86, 0xfd, 0xe2, 0xbb, 0xd5,
	0xa6, 0x18, 0x21, 0x0b, 0xf4, 0x38, 0xd9, 0xad, 0x36, 0xc5, 0xa8, 0x5f, 0x5e, 0x20, 0xf2, 0x98,
	0x5f, 0x7e, 0x87, 0xc8, 0xe3, 0x7e, 0xf9, 0xfb, 0x44, 0xbe, 0xe0, 0x97, 0xdf, 0x25, 0xf2, 0x04,
	0xba, 0x02, 0xab, 0xde, 0xb8, 0x44, 0x91, 0xf4, 0x2b, 0x0a, 0x54, 0x01, 0x7e, 0xc5, 0x5d, 0xaa,
	0xb8, 0x84, 0xd6, 0x40, 0xf4, 0xb8, 0x6a, 0x8a, 0x29, 0xbf, 0xb4, 0xd0, 0x14, 0x17, 0xfd, 0xd2,
	0xbb, 0x4d, 0x71, 0x29, 0x20, 0x93, 0xbb, 0x4d, 0x71, 0x39, 0x20, 0x93, 0xbb, 0x4d, 0x51, 0xf4,
	0x8b, 0x3f, 0xd8, 0x6d, 0x8a, 0x2b, 0xdb, 0xbf, 0x10, 0x40, 0xf4, 0xde, 0xe2, 0xd0, 0x06, 0xac,
	0x97, 0x1f, 0x16, 0x6b, 0x35, 0x79, 0xbf, 0x2d, 0x3f, 0x22, 0xbb, 0x7d, 0x50, 0xfb, 0xb8, 0x56,
	0x3f, 0xac, 0x89, 0x21, 0xb4, 0x0a, 0xcb, 0x63, 0x55, 0x59, 0x95, 0x8b, 0x2d, 0xb9, 0x22, 0x0a,
	0xbc, 0xf0, 0xa0, 0x51, 0xa1, 0xc2, 0x30, 0x2f, 0xac, 0xc8, 0xfb, 0x32, 0x11, 0x46, 0xc8, 0x4a,
	0xc6, 0x42, 0x55, 0x6e, 0xec, 0x17, 0x1f, 0xcb, 0x15, 0x31, 0xba, 0xfd, 0xa5, 0x00, 0xeb, 0x81,
	0xc7, 0x78, 0x94, 0x85, 0x0c, 0x29, 0xba, 0xb2, 0xaa, 0x34, 0x68, 0xbd, 0x79, 0xe9, 0xa4, 0x61,
	0xcd, 0xa5, 0x9f, 0x70, 0xf2, 0x6a, 0x26, 0xc4, 0xbc, 0x9a, 0x09, 0xbb, 0x0d, 0x58, 0x77, 0x69,
	0x38, 0x8a, 0xef, 0x3b, 0xb7, 0x63, 0x3a, 0x88, 0x10, 0x82, 0x25, 0x27, 0x0f, 0xfb, 0xf5, 0xa6,
	0x5c, 0x11, 0x43, 0x48, 0x84, 0xd4, 0x58, 0x56, 0x6f, 0xc8, 0x35, 0x51, 0xd8, 0xae, 0x3a, 0x56,
	0x74, 0x00, 0xf1, 0x39, 0x69, 0xc8, 0xb5, 0x8a, 0x52, 0x7b, 0x20, 0x86, 0xf8, 0x9c, 0x94, 0xeb,
	0xd5, 0x06, 0x21, 0x23, 0x0a, 0x7c, 0x80, 0xef, 0x17, 0x95, 0x7d, 0xc2, 0x7c, 0xbb, 0xec, 0xbe,
	0x23, 0xd9, 0x4c, 0xae, 0xc0, 0xaa, 0x3b, 0x05, 0x63, 0x3a, 0xeb, 0xb0, 0xe2, 0x52, 0x30, 0x4e,
	0x9a, 0xdb, 0x89, 0x4d, 0xcc, 0x9b, 0x93, 0x09, 0x3b, 0x6f, 0x4e, 0x38, 0x8a, 0xde, 0xc8, 0x63,
	0x9e, 0x85, 0xbf, 0x0b, 0xb0, 0xea, 0x8a, 0x61, 0x7f, 0x9d, 0xd1, 0x27, 0x90, 0x74, 0xde, 0xa7,
	0xd1, 0xcc, 0x4f, 0x92, 0xf3, 0xb2, 0x9b, 0xb9, 0x79, 0x11, 0xcc, 0xbe, 0x84, 0xee, 0x0a, 0xe8,
	0x53, 0xb8, 0xc4, 0xbd, 0xb9, 0xa2, 0xe0, 0xef, 0x95, 0xff, 0xed, 0x38, 0xb3, 0x75, 0x31, 0xd0,
	0x8e, 0x51, 0xf8, 0x6d, 0x0c, 0xd2, 0xfc, 0xba, 0x8a, 0xdd, 0x41, 0xdf, 0x59, 0xdc, 0x4f, 0x00,
	0x26, 0x0f, 0x52, 0x28, 0x98, 0xb6, 0xef, 0x05, 0x2c, 0xf3, 0xde, 0x85, 0x38, 0x76, 0xc9, 0xee,
	0x40, 0x8a, 0x7f, 0x84, 0x42, 0xc1, 0xac, 0x03, 0x9e, 0xaf, 0x32, 0xb7, 0xe6, 0x40, 0xb2, 0x20,
	0xc7, 0xb0, 0xe8, 0x7a, 0x5c, 0x42, 0xc1, 0xb6, 0x41, 0xaf, 0x56, 0x99, 0xed, 0x79, 0xa0, 0xce,
	0x66, 0x9d, 0xc0, 0xb2, 0xe7, 0xed, 0x05, 0xfd, 0xff, 0xb4, 0x54, 0x04, 0x3c, 0x05, 0x65, 0xbe,
	0x31, 0x1f, 0x98, 0xad, 0x6b, 0x04, 0x2b, 0xbe, 0x57, 0x16, 0xf4, 0xcd, 0xa9, 0x79, 0x09, 0x7a,
	0x20, 0xc9, 0xe4, 0xe7, 0x85, 0xb3, 0x98, 0xcf, 0x00, 0xf9, 0xdf, 0x4c, 0x50, 0x7e, 0x7a, 0x96,
	0x02, 0xa3, 0xee, 0xcc, 0x8d, 0x1f, 0xa7, 0xb6, 0x74, 0xed, 0xab, 0xf3, 0xac, 0xf0, 0xe2, 0x3c,
	0x2b, 0xfc, 0xeb, 0x3c, 0x2b, 0x7c, 0xfe, 0x32, 0x1b, 0xfa, 0xcb, 0xcb, 0xac, 0xf0, 0xe2, 0x65,
	0x36, 0xf4, 0x8f, 0x97, 0xd9, 0xd0, 0x51, 0x9c, 0x5e, 0x11, 0xee, 0xfc, 0x37, 0x00, 0x00, 0xff,
	0xff, 0x3b, 0x57, 0xaa, 0x86, 0x27, 0x1c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubscriptionServiceClient interface {
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (SubscriptionService_SubscribeClient, error)
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
}

type subscriptionServiceClient struct {
	cc *grpc.ClientConn
}

func NewSubscriptionServiceClient(cc *grpc.ClientConn) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

func (c *subscriptionServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (SubscriptionService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SubscriptionService_serviceDesc.Streams[0], "/onos.e2t.e2.v1beta1.SubscriptionService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscriptionServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SubscriptionService_SubscribeClient interface {
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type subscriptionServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *subscriptionServiceSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *subscriptionServiceClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, "/onos.e2t.e2.v1beta1.SubscriptionService/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionServiceServer is the server API for SubscriptionService service.
type SubscriptionServiceServer interface {
	Subscribe(*SubscribeRequest, SubscriptionService_SubscribeServer) error
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
}

// UnimplementedSubscriptionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSubscriptionServiceServer struct {
}

func (*UnimplementedSubscriptionServiceServer) Subscribe(req *SubscribeRequest, srv SubscriptionService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedSubscriptionServiceServer) Unsubscribe(ctx context.Context, req *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}

func RegisterSubscriptionServiceServer(s *grpc.Server, srv SubscriptionServiceServer) {
	s.RegisterService(&_SubscriptionService_serviceDesc, srv)
}

func _SubscriptionService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionServiceServer).Subscribe(m, &subscriptionServiceSubscribeServer{stream})
}

type SubscriptionService_SubscribeServer interface {
	Send(*SubscribeResponse) error
	grpc.ServerStream
}

type subscriptionServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *subscriptionServiceSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SubscriptionService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.e2t.e2.v1beta1.SubscriptionService/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubscriptionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.e2t.e2.v1beta1.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Unsubscribe",
			Handler:    _SubscriptionService_Unsubscribe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _SubscriptionService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/e2t/e2/v1beta1/subscription.proto",
}

// SubscriptionAdminServiceClient is the client API for SubscriptionAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubscriptionAdminServiceClient interface {
	GetChannel(ctx context.Context, in *GetChannelRequest, opts ...grpc.CallOption) (*GetChannelResponse, error)
	ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error)
	WatchChannels(ctx context.Context, in *WatchChannelsRequest, opts ...grpc.CallOption) (SubscriptionAdminService_WatchChannelsClient, error)
	GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*GetSubscriptionResponse, error)
	ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error)
	WatchSubscriptions(ctx context.Context, in *WatchSubscriptionsRequest, opts ...grpc.CallOption) (SubscriptionAdminService_WatchSubscriptionsClient, error)
}

type subscriptionAdminServiceClient struct {
	cc *grpc.ClientConn
}

func NewSubscriptionAdminServiceClient(cc *grpc.ClientConn) SubscriptionAdminServiceClient {
	return &subscriptionAdminServiceClient{cc}
}

func (c *subscriptionAdminServiceClient) GetChannel(ctx context.Context, in *GetChannelRequest, opts ...grpc.CallOption) (*GetChannelResponse, error) {
	out := new(GetChannelResponse)
	err := c.cc.Invoke(ctx, "/onos.e2t.e2.v1beta1.SubscriptionAdminService/GetChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionAdminServiceClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {
	out := new(ListChannelsResponse)
	err := c.cc.Invoke(ctx, "/onos.e2t.e2.v1beta1.SubscriptionAdminService/ListChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionAdminServiceClient) WatchChannels(ctx context.Context, in *WatchChannelsRequest, opts ...grpc.CallOption) (SubscriptionAdminService_WatchChannelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SubscriptionAdminService_serviceDesc.Streams[0], "/onos.e2t.e2.v1beta1.SubscriptionAdminService/WatchChannels", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscriptionAdminServiceWatchChannelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SubscriptionAdminService_WatchChannelsClient interface {
	Recv() (*WatchChannelsResponse, error)
	grpc.ClientStream
}

type subscriptionAdminServiceWatchChannelsClient struct {
	grpc.ClientStream
}

func (x *subscriptionAdminServiceWatchChannelsClient) Recv() (*WatchChannelsResponse, error) {
	m := new(WatchChannelsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *subscriptionAdminServiceClient) GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*GetSubscriptionResponse, error) {
	out := new(GetSubscriptionResponse)
	err := c.cc.Invoke(ctx, "/onos.e2t.e2.v1beta1.SubscriptionAdminService/GetSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionAdminServiceClient) ListSubscriptions(ctx context.Context, in *ListSubscriptionsRequest, opts ...grpc.CallOption) (*ListSubscriptionsResponse, error) {
	out := new(ListSubscriptionsResponse)
	err := c.cc.Invoke(ctx, "/onos.e2t.e2.v1beta1.SubscriptionAdminService/ListSubscriptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionAdminServiceClient) WatchSubscriptions(ctx context.Context, in *WatchSubscriptionsRequest, opts ...grpc.CallOption) (SubscriptionAdminService_WatchSubscriptionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SubscriptionAdminService_serviceDesc.Streams[1], "/onos.e2t.e2.v1beta1.SubscriptionAdminService/WatchSubscriptions", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscriptionAdminServiceWatchSubscriptionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SubscriptionAdminService_WatchSubscriptionsClient interface {
	Recv() (*WatchSubscriptionsResponse, error)
	grpc.ClientStream
}

type subscriptionAdminServiceWatchSubscriptionsClient struct {
	grpc.ClientStream
}

func (x *subscriptionAdminServiceWatchSubscriptionsClient) Recv() (*WatchSubscriptionsResponse, error) {
	m := new(WatchSubscriptionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SubscriptionAdminServiceServer is the server API for SubscriptionAdminService service.
type SubscriptionAdminServiceServer interface {
	GetChannel(context.Context, *GetChannelRequest) (*GetChannelResponse, error)
	ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error)
	WatchChannels(*WatchChannelsRequest, SubscriptionAdminService_WatchChannelsServer) error
	GetSubscription(context.Context, *GetSubscriptionRequest) (*GetSubscriptionResponse, error)
	ListSubscriptions(context.Context, *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error)
	WatchSubscriptions(*WatchSubscriptionsRequest, SubscriptionAdminService_WatchSubscriptionsServer) error
}

// UnimplementedSubscriptionAdminServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSubscriptionAdminServiceServer struct {
}

func (*UnimplementedSubscriptionAdminServiceServer) GetChannel(ctx context.Context, req *GetChannelRequest) (*GetChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannel not implemented")
}
func (*UnimplementedSubscriptionAdminServiceServer) ListChannels(ctx context.Context, req *ListChannelsRequest) (*ListChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChannels not implemented")
}
func (*UnimplementedSubscriptionAdminServiceServer) WatchChannels(req *WatchChannelsRequest, srv SubscriptionAdminService_WatchChannelsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchChannels not implemented")
}
func (*UnimplementedSubscriptionAdminServiceServer) GetSubscription(ctx context.Context, req *GetSubscriptionRequest) (*GetSubscriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubscription not implemented")
}
func (*UnimplementedSubscriptionAdminServiceServer) ListSubscriptions(ctx context.Context, req *ListSubscriptionsRequest) (*ListSubscriptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSubscriptions not implemented")
}
func (*UnimplementedSubscriptionAdminServiceServer) WatchSubscriptions(req *WatchSubscriptionsRequest, srv SubscriptionAdminService_WatchSubscriptionsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchSubscriptions not implemented")
}

func RegisterSubscriptionAdminServiceServer(s *grpc.Server, srv SubscriptionAdminServiceServer) {
	s.RegisterService(&_SubscriptionAdminService_serviceDesc, srv)
}

func _SubscriptionAdminService_GetChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionAdminServiceServer).GetChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.e2t.e2.v1beta1.SubscriptionAdminService/GetChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionAdminServiceServer).GetChannel(ctx, req.(*GetChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionAdminService_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionAdminServiceServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.e2t.e2.v1beta1.SubscriptionAdminService/ListChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionAdminServiceServer).ListChannels(ctx, req.(*ListChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionAdminService_WatchChannels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchChannelsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionAdminServiceServer).WatchChannels(m, &subscriptionAdminServiceWatchChannelsServer{stream})
}

type SubscriptionAdminService_WatchChannelsServer interface {
	Send(*WatchChannelsResponse) error
	grpc.ServerStream
}

type subscriptionAdminServiceWatchChannelsServer struct {
	grpc.ServerStream
}

func (x *subscriptionAdminServiceWatchChannelsServer) Send(m *WatchChannelsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SubscriptionAdminService_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionAdminServiceServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.e2t.e2.v1beta1.SubscriptionAdminService/GetSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionAdminServiceServer).GetSubscription(ctx, req.(*GetSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionAdminService_ListSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubscriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionAdminServiceServer).ListSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/onos.e2t.e2.v1beta1.SubscriptionAdminService/ListSubscriptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionAdminServiceServer).ListSubscriptions(ctx, req.(*ListSubscriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionAdminService_WatchSubscriptions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSubscriptionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscriptionAdminServiceServer).WatchSubscriptions(m, &subscriptionAdminServiceWatchSubscriptionsServer{stream})
}

type SubscriptionAdminService_WatchSubscriptionsServer interface {
	Send(*WatchSubscriptionsResponse) error
	grpc.ServerStream
}

type subscriptionAdminServiceWatchSubscriptionsServer struct {
	grpc.ServerStream
}

func (x *subscriptionAdminServiceWatchSubscriptionsServer) Send(m *WatchSubscriptionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SubscriptionAdminService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.e2t.e2.v1beta1.SubscriptionAdminService",
	HandlerType: (*SubscriptionAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetChannel",
			Handler:    _SubscriptionAdminService_GetChannel_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _SubscriptionAdminService_ListChannels_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _SubscriptionAdminService_GetSubscription_Handler,
		},
		{
			MethodName: "ListSubscriptions",
			Handler:    _SubscriptionAdminService_ListSubscriptions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchChannels",
			Handler:       _SubscriptionAdminService_WatchChannels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchSubscriptions",
			Handler:       _SubscriptionAdminService_WatchSubscriptions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "onos/e2t/e2/v1beta1/subscription.proto",
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionTimeout != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TransactionTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TransactionTimeout):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintSubscription(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Subscription.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubscribeResponse_Ack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse_Ack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ack != nil {
		{
			size, err := m.Ack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SubscribeResponse_Indication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse_Indication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Indication != nil {
		{
			size, err := m.Indication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *UnsubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnsubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Headers.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubscriptionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.EventTrigger.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubsequentAction != nil {
		{
			size, err := m.SubsequentAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubsequentAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubsequentAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubsequentAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeToWait != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.TimeToWait))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Acknowledgement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Acknowledgement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Acknowledgement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelID) > 0 {
		i -= len(m.ChannelID)
		copy(dAtA[i:], m.ChannelID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.ChannelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Indication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Indication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Indication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetChannelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetChannelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelID) > 0 {
		i -= len(m.ChannelID)
		copy(dAtA[i:], m.ChannelID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.ChannelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetChannelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetChannelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListChannelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListChannelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListChannelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListChannelsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListChannelsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListChannelsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for iNdEx := len(m.Channels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Channels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WatchChannelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchChannelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchChannelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoReplay {
		i--
		if m.NoReplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WatchChannelsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchChannelsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchChannelsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChannelEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubscriptionID) > 0 {
		i -= len(m.SubscriptionID)
		copy(dAtA[i:], m.SubscriptionID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.SubscriptionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Subscription.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListSubscriptionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSubscriptionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSubscriptionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListSubscriptionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSubscriptionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSubscriptionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Subscriptions) > 0 {
		for iNdEx := len(m.Subscriptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subscriptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubscription(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WatchSubscriptionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchSubscriptionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchSubscriptionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoReplay {
		i--
		if m.NoReplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WatchSubscriptionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchSubscriptionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchSubscriptionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubscriptionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Subscription.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChannelMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Finalizers) > 0 {
		for iNdEx := len(m.Finalizers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Finalizers[iNdEx])
			copy(dAtA[i:], m.Finalizers[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.Finalizers[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Revision != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x40
	}
	if m.Encoding != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Encoding))
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.ServiceModel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.SubscriptionID) > 0 {
		i -= len(m.SubscriptionID)
		copy(dAtA[i:], m.SubscriptionID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.SubscriptionID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.E2NodeID) > 0 {
		i -= len(m.E2NodeID)
		copy(dAtA[i:], m.E2NodeID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.E2NodeID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppInstanceID) > 0 {
		i -= len(m.AppInstanceID)
		copy(dAtA[i:], m.AppInstanceID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.AppInstanceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppID) > 0 {
		i -= len(m.AppID)
		copy(dAtA[i:], m.AppID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.AppID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Channel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Channel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Channel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ChannelMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChannelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionTimeout != nil {
		n21, err21 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.TransactionTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TransactionTimeout):])
		if err21 != nil {
			return 0, err21
		}
		i -= n21
		i = encodeVarintSubscription(dAtA, i, uint64(n21))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.SubscriptionSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChannelStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Master) > 0 {
		i -= len(m.Master)
		copy(dAtA[i:], m.Master)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Master)))
		i--
		dAtA[i] = 0x32
	}
	if m.Term != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x28
	}
	if m.Timestamp != nil {
		n23, err23 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Timestamp):])
		if err23 != nil {
			return 0, err23
		}
		i -= n23
		i = encodeVarintSubscription(dAtA, i, uint64(n23))
		i--
		dAtA[i] = 0x22
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Phase != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Finalizers) > 0 {
		for iNdEx := len(m.Finalizers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Finalizers[iNdEx])
			copy(dAtA[i:], m.Finalizers[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.Finalizers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Revision != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x20
	}
	if m.Encoding != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Encoding))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.ServiceModel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.E2NodeID) > 0 {
		i -= len(m.E2NodeID)
		copy(dAtA[i:], m.E2NodeID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.E2NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.SubscriptionMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubscription(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Master) > 0 {
		i -= len(m.Master)
		copy(dAtA[i:], m.Master)
		i = encodeVarintSubscription(dAtA, i, uint64(len(m.Master)))
		i--
		dAtA[i] = 0x32
	}
	if m.Term != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Channels) > 0 {
		for iNdEx := len(m.Channels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Channels[iNdEx])
			copy(dAtA[i:], m.Channels[iNdEx])
			i = encodeVarintSubscription(dAtA, i, uint64(len(m.Channels[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubscription(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Phase != 0 {
		i = encodeVarintSubscription(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSubscription(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubscription(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Headers.Size()
	n += 1 + l + sovSubscription(uint64(l))
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = m.Subscription.Size()
	n += 1 + l + sovSubscription(uint64(l))
	if m.TransactionTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TransactionTimeout)
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *SubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Headers.Size()
	n += 1 + l + sovSubscription(uint64(l))
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *SubscribeResponse_Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ack != nil {
		l = m.Ack.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}
func (m *SubscribeResponse_Indication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Indication != nil {
		l = m.Indication.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}
func (m *UnsubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Headers.Size()
	n += 1 + l + sovSubscription(uint64(l))
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *UnsubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Headers.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *SubscriptionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.EventTrigger.Size()
	n += 1 + l + sovSubscription(uint64(l))
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *EventTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubscription(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovSubscription(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.SubsequentAction != nil {
		l = m.SubsequentAction.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *SubsequentAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSubscription(uint64(m.Type))
	}
	if m.TimeToWait != 0 {
		n += 1 + sovSubscription(uint64(m.TimeToWait))
	}
	return n
}

func (m *Acknowledgement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *Indication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *GetChannelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *GetChannelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Channel.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *ListChannelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListChannelsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *WatchChannelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoReplay {
		n += 2
	}
	return n
}

func (m *WatchChannelsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Event.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *ChannelEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSubscription(uint64(m.Type))
	}
	l = m.Channel.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *GetSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *GetSubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Subscription.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *ListSubscriptionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListSubscriptionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subscriptions) > 0 {
		for _, e := range m.Subscriptions {
			l = e.Size()
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *WatchSubscriptionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoReplay {
		n += 2
	}
	return n
}

func (m *WatchSubscriptionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Event.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *SubscriptionEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSubscription(uint64(m.Type))
	}
	l = m.Subscription.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *ChannelMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.AppInstanceID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.E2NodeID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = m.ServiceModel.Size()
	n += 1 + l + sovSubscription(uint64(l))
	if m.Encoding != 0 {
		n += 1 + sovSubscription(uint64(m.Encoding))
	}
	if m.Revision != 0 {
		n += 1 + sovSubscription(uint64(m.Revision))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *Channel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = m.ChannelMeta.Size()
	n += 1 + l + sovSubscription(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovSubscription(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *ChannelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SubscriptionSpec.Size()
	n += 1 + l + sovSubscription(uint64(l))
	if m.TransactionTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.TransactionTimeout)
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *ChannelStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovSubscription(uint64(m.Phase))
	}
	if m.State != 0 {
		n += 1 + sovSubscription(uint64(m.State))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Timestamp != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Timestamp)
		n += 1 + l + sovSubscription(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovSubscription(uint64(m.Term))
	}
	l = len(m.Master)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func (m *SubscriptionMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.E2NodeID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = m.ServiceModel.Size()
	n += 1 + l + sovSubscription(uint64(l))
	if m.Encoding != 0 {
		n += 1 + sovSubscription(uint64(m.Encoding))
	}
	if m.Revision != 0 {
		n += 1 + sovSubscription(uint64(m.Revision))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	return n
}

func (m *Subscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	l = m.SubscriptionMeta.Size()
	n += 1 + l + sovSubscription(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovSubscription(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSubscription(uint64(l))
	return n
}

func (m *SubscriptionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovSubscription(uint64(m.Phase))
	}
	if m.State != 0 {
		n += 1 + sovSubscription(uint64(m.State))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSubscription(uint64(l))
	}
	if len(m.Channels) > 0 {
		for _, s := range m.Channels {
			l = len(s)
			n += 1 + l + sovSubscription(uint64(l))
		}
	}
	if m.Term != 0 {
		n += 1 + sovSubscription(uint64(m.Term))
	}
	l = len(m.Master)
	if l > 0 {
		n += 1 + l + sovSubscription(uint64(l))
	}
	return n
}

func sovSubscription(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubscription(x uint64) (n int) {
	return sovSubscription(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = TransactionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionTimeout == nil {
				m.TransactionTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TransactionTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Acknowledgement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &SubscribeResponse_Ack{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Indication{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &SubscribeResponse_Indication{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = TransactionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EventTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsequentAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubsequentAction == nil {
				m.SubsequentAction = &SubsequentAction{}
			}
			if err := m.SubsequentAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubsequentAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubsequentAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubsequentAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SubsequentActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToWait", wireType)
			}
			m.TimeToWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeToWait |= TimeToWait(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Acknowledgement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Acknowledgement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Acknowledgement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = ChannelID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Indication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Indication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Indication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = ChannelID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListChannelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListChannelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListChannelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListChannelsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListChannelsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListChannelsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, Channel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchChannelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchChannelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchChannelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoReplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchChannelsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchChannelsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchChannelsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ChannelEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = SubscriptionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSubscriptionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSubscriptionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSubscriptionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSubscriptionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSubscriptionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSubscriptionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, Subscription{})
			if err := m.Subscriptions[len(m.Subscriptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchSubscriptionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchSubscriptionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchSubscriptionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoReplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchSubscriptionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchSubscriptionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchSubscriptionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SubscriptionEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = AppID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppInstanceID = AppInstanceID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.E2NodeID = E2NodeID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = TransactionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = SubscriptionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceModel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= Revision(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Channel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Channel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Channel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = ChannelID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChannelMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubscriptionSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionTimeout == nil {
				m.TransactionTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.TransactionTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= ChannelPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ChannelState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= TermID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Master = MasterID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.E2NodeID = E2NodeID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceModel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= Revision(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = SubscriptionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubscriptionMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= SubscriptionPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SubscriptionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, ChannelID(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= TermID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubscription
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubscription
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Master = MasterID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubscription(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubscription
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubscription(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubscription
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubscription
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubscription
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSubscription
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSubscription
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSubscription        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubscription          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSubscription = fmt.Errorf("proto: unexpected end of group")
)
