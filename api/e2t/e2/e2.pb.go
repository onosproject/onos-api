// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/e2t/e2.proto

// Package e2t.e2 defines the interior gRPC interfaces for xApps to interact with E2T.

package e2

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EncodingType determines encoding type for the response messages
type EncodingType int32

const (
	EncodingType_PROTO    EncodingType = 0
	EncodingType_ASN1_PER EncodingType = 1
	EncodingType_ASN1_XER EncodingType = 2
)

var EncodingType_name = map[int32]string{
	0: "PROTO",
	1: "ASN1_PER",
	2: "ASN1_XER",
}

var EncodingType_value = map[string]int32{
	"PROTO":    0,
	"ASN1_PER": 1,
	"ASN1_XER": 2,
}

func (x EncodingType) String() string {
	return proto.EnumName(EncodingType_name, int32(x))
}

func (EncodingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{0}
}

// ResponseStatus
type ResponseStatus int32

const (
	ResponseStatus_FAILED    ResponseStatus = 0
	ResponseStatus_SUCCEEDED ResponseStatus = 1
)

var ResponseStatus_name = map[int32]string{
	0: "FAILED",
	1: "SUCCEEDED",
}

var ResponseStatus_value = map[string]int32{
	"FAILED":    0,
	"SUCCEEDED": 1,
}

func (x ResponseStatus) String() string {
	return proto.EnumName(ResponseStatus_name, int32(x))
}

func (ResponseStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{1}
}

// ServiceModelInfo E2 service model information
type ServiceModelInfo struct {
	ServiceModelId       string   `protobuf:"bytes,1,opt,name=service_model_id,json=serviceModelId,proto3" json:"service_model_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceModelInfo) Reset()         { *m = ServiceModelInfo{} }
func (m *ServiceModelInfo) String() string { return proto.CompactTextString(m) }
func (*ServiceModelInfo) ProtoMessage()    {}
func (*ServiceModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{0}
}
func (m *ServiceModelInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServiceModelInfo.Unmarshal(m, b)
}
func (m *ServiceModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServiceModelInfo.Marshal(b, m, deterministic)
}
func (m *ServiceModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceModelInfo.Merge(m, src)
}
func (m *ServiceModelInfo) XXX_Size() int {
	return xxx_messageInfo_ServiceModelInfo.Size(m)
}
func (m *ServiceModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceModelInfo proto.InternalMessageInfo

func (m *ServiceModelInfo) GetServiceModelId() string {
	if m != nil {
		return m.ServiceModelId
	}
	return ""
}

// RequestHeader a common request header for all requests including encoding type, client/xApp/session info, ordering info, etc
type RequestHeader struct {
	EncodingType         EncodingType      `protobuf:"varint,1,opt,name=encoding_type,json=encodingType,proto3,enum=e2t.e2.EncodingType" json:"encoding_type,omitempty"`
	ServiceModelInfo     *ServiceModelInfo `protobuf:"bytes,2,opt,name=service_model_info,json=serviceModelInfo,proto3" json:"service_model_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{1}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestHeader.Unmarshal(m, b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestHeader.Marshal(b, m, deterministic)
}
func (m *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(m, src)
}
func (m *RequestHeader) XXX_Size() int {
	return xxx_messageInfo_RequestHeader.Size(m)
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

func (m *RequestHeader) GetEncodingType() EncodingType {
	if m != nil {
		return m.EncodingType
	}
	return EncodingType_PROTO
}

func (m *RequestHeader) GetServiceModelInfo() *ServiceModelInfo {
	if m != nil {
		return m.ServiceModelInfo
	}
	return nil
}

// ResponseHeader a common response header for all responses including encoding type, client/xApp/session info, ordering info, etc
type ResponseHeader struct {
	EncodingType         EncodingType      `protobuf:"varint,1,opt,name=encoding_type,json=encodingType,proto3,enum=e2t.e2.EncodingType" json:"encoding_type,omitempty"`
	ServiceModelInfo     *ServiceModelInfo `protobuf:"bytes,2,opt,name=service_model_info,json=serviceModelInfo,proto3" json:"service_model_info,omitempty"`
	ResponseStatus       ResponseStatus    `protobuf:"varint,3,opt,name=response_status,json=responseStatus,proto3,enum=e2t.e2.ResponseStatus" json:"response_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{2}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseHeader.Unmarshal(m, b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return xxx_messageInfo_ResponseHeader.Size(m)
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

func (m *ResponseHeader) GetEncodingType() EncodingType {
	if m != nil {
		return m.EncodingType
	}
	return EncodingType_PROTO
}

func (m *ResponseHeader) GetServiceModelInfo() *ServiceModelInfo {
	if m != nil {
		return m.ServiceModelInfo
	}
	return nil
}

func (m *ResponseHeader) GetResponseStatus() ResponseStatus {
	if m != nil {
		return m.ResponseStatus
	}
	return ResponseStatus_FAILED
}

// StreamRequest
type StreamRequest struct {
	Header               *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	AppID                AppID          `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3,casttype=AppID" json:"app_id,omitempty"`
	InstanceID           InstanceID     `protobuf:"bytes,3,opt,name=instance_id,json=instanceId,proto3,casttype=InstanceID" json:"instance_id,omitempty"`
	SubscriptionID       SubscriptionID `protobuf:"bytes,4,opt,name=subscription_id,json=subscriptionId,proto3,casttype=SubscriptionID" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *StreamRequest) Reset()         { *m = StreamRequest{} }
func (m *StreamRequest) String() string { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()    {}
func (*StreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{3}
}
func (m *StreamRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamRequest.Unmarshal(m, b)
}
func (m *StreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamRequest.Marshal(b, m, deterministic)
}
func (m *StreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamRequest.Merge(m, src)
}
func (m *StreamRequest) XXX_Size() int {
	return xxx_messageInfo_StreamRequest.Size(m)
}
func (m *StreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamRequest proto.InternalMessageInfo

func (m *StreamRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *StreamRequest) GetAppID() AppID {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *StreamRequest) GetInstanceID() InstanceID {
	if m != nil {
		return m.InstanceID
	}
	return ""
}

func (m *StreamRequest) GetSubscriptionID() SubscriptionID {
	if m != nil {
		return m.SubscriptionID
	}
	return ""
}

// StreamResponse
type StreamResponse struct {
	Header               *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Payload              []byte          `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StreamResponse) Reset()         { *m = StreamResponse{} }
func (m *StreamResponse) String() string { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()    {}
func (*StreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6402bfae1c127dd3, []int{4}
}
func (m *StreamResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamResponse.Unmarshal(m, b)
}
func (m *StreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamResponse.Marshal(b, m, deterministic)
}
func (m *StreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamResponse.Merge(m, src)
}
func (m *StreamResponse) XXX_Size() int {
	return xxx_messageInfo_StreamResponse.Size(m)
}
func (m *StreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamResponse proto.InternalMessageInfo

func (m *StreamResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *StreamResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterEnum("e2t.e2.EncodingType", EncodingType_name, EncodingType_value)
	proto.RegisterEnum("e2t.e2.ResponseStatus", ResponseStatus_name, ResponseStatus_value)
	proto.RegisterType((*ServiceModelInfo)(nil), "e2t.e2.ServiceModelInfo")
	proto.RegisterType((*RequestHeader)(nil), "e2t.e2.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "e2t.e2.ResponseHeader")
	proto.RegisterType((*StreamRequest)(nil), "e2t.e2.StreamRequest")
	proto.RegisterType((*StreamResponse)(nil), "e2t.e2.StreamResponse")
}

func init() { proto.RegisterFile("api/e2t/e2.proto", fileDescriptor_6402bfae1c127dd3) }

var fileDescriptor_6402bfae1c127dd3 = []byte{
	// 501 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x53, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xed, 0xb4, 0x5f, 0xfc, 0x91, 0x9b, 0xc4, 0xb5, 0x46, 0xa5, 0x8a, 0x2a, 0xa4, 0x54, 0x16,
	0x8b, 0x50, 0x84, 0x03, 0x46, 0x2c, 0x10, 0x20, 0x94, 0x36, 0xae, 0xb0, 0x44, 0x69, 0x35, 0x0e,
	0x12, 0xea, 0xc6, 0x72, 0xe3, 0xdb, 0x60, 0xa9, 0xf5, 0x0c, 0x9e, 0x09, 0x52, 0x5e, 0x83, 0x67,
	0x63, 0x9d, 0x45, 0x5e, 0x02, 0x89, 0x15, 0xf2, 0xd8, 0x6e, 0x5c, 0xf3, 0x02, 0xec, 0xe6, 0x9e,
	0xfb, 0x33, 0xe7, 0xdc, 0x33, 0x03, 0x56, 0x24, 0x92, 0x11, 0xba, 0x6a, 0x84, 0xae, 0x23, 0x32,
	0xae, 0x38, 0x35, 0xd0, 0x55, 0x0e, 0xba, 0x07, 0x7b, 0x73, 0x3e, 0xe7, 0x1a, 0x1a, 0xe5, 0xa7,
	0x22, 0x6b, 0xbf, 0x05, 0x2b, 0xc0, 0xec, 0x7b, 0x32, 0xc3, 0x33, 0x1e, 0xe3, 0x8d, 0x9f, 0x5e,
	0x73, 0x3a, 0x04, 0x4b, 0x16, 0x58, 0x78, 0x9b, 0x83, 0x61, 0x12, 0xf7, 0xc9, 0x21, 0x19, 0xb6,
	0x99, 0x29, 0xeb, 0xb5, 0xb1, 0xfd, 0x83, 0x40, 0x8f, 0xe1, 0xb7, 0x05, 0x4a, 0xf5, 0x01, 0xa3,
	0x18, 0x33, 0xfa, 0x1a, 0x7a, 0x98, 0xce, 0x78, 0x9c, 0xa4, 0xf3, 0x50, 0x2d, 0x05, 0xea, 0x46,
	0xd3, 0xdd, 0x73, 0x0a, 0x16, 0x8e, 0x57, 0x26, 0xa7, 0x4b, 0x81, 0xac, 0x8b, 0xb5, 0x88, 0x9e,
	0x02, 0x6d, 0x5c, 0x9b, 0x5e, 0xf3, 0xfe, 0xf6, 0x21, 0x19, 0x76, 0xdc, 0x7e, 0xd5, 0xdf, 0x24,
	0xcb, 0x2c, 0xd9, 0x40, 0xec, 0x9f, 0x04, 0x4c, 0x86, 0x52, 0xf0, 0x54, 0xe2, 0x3f, 0xc3, 0x8a,
	0xbe, 0x87, 0xdd, 0xac, 0x24, 0x15, 0x4a, 0x15, 0xa9, 0x85, 0xec, 0xef, 0x68, 0x12, 0xfb, 0xd5,
	0x90, 0x8a, 0x73, 0xa0, 0xb3, 0xcc, 0xcc, 0xee, 0xc5, 0xf6, 0x2f, 0x02, 0xbd, 0x40, 0x65, 0x18,
	0xdd, 0x96, 0x1b, 0xa7, 0xcf, 0xc0, 0xf8, 0xaa, 0xf5, 0x69, 0x39, 0x1d, 0xf7, 0xe1, 0x66, 0x52,
	0xcd, 0x12, 0x56, 0x16, 0xd1, 0x27, 0x60, 0x44, 0x42, 0xe4, 0x66, 0xe6, 0xec, 0xdb, 0xc7, 0x74,
	0xbd, 0x1a, 0xb4, 0xc6, 0x42, 0xf8, 0x93, 0xdf, 0xd5, 0x81, 0xb5, 0x22, 0x21, 0xfc, 0x98, 0xbe,
	0x83, 0x4e, 0x92, 0x4a, 0x15, 0xa5, 0x33, 0xcc, 0xeb, 0x77, 0x74, 0xfd, 0xa3, 0xf5, 0x6a, 0x00,
	0x7e, 0x09, 0xeb, 0xa6, 0x5a, 0xc4, 0xa0, 0x6a, 0xf0, 0x63, 0x7a, 0x06, 0xbb, 0x72, 0x71, 0x25,
	0x67, 0x59, 0x22, 0x54, 0xc2, 0xd3, 0x7c, 0xc4, 0x7f, 0x7a, 0xc4, 0xe3, 0xf5, 0x6a, 0x60, 0x06,
	0xb5, 0x94, 0x1e, 0xd3, 0x40, 0x98, 0x59, 0x6f, 0xf6, 0x63, 0xfb, 0x12, 0xcc, 0x4a, 0x78, 0xb1,
	0x11, 0xea, 0x34, 0x94, 0xff, 0xb5, 0xc3, 0x86, 0xf4, 0x3e, 0xfc, 0x2f, 0xa2, 0xe5, 0x0d, 0x8f,
	0x0a, 0xed, 0x5d, 0x56, 0x85, 0x47, 0xaf, 0xa0, 0x5b, 0x37, 0x9f, 0xb6, 0xa1, 0x75, 0xc1, 0xce,
	0xa7, 0xe7, 0xd6, 0x16, 0xed, 0xc2, 0x83, 0x71, 0xf0, 0xe9, 0x45, 0x78, 0xe1, 0x31, 0x8b, 0xdc,
	0x45, 0x5f, 0x3c, 0x66, 0x6d, 0x1f, 0x3d, 0xdd, 0x3c, 0xb1, 0xc2, 0x1e, 0x0a, 0x60, 0x9c, 0x8e,
	0xfd, 0x8f, 0xde, 0xc4, 0xda, 0xa2, 0x3d, 0x68, 0x07, 0x9f, 0x4f, 0x4e, 0x3c, 0x6f, 0xe2, 0x4d,
	0x2c, 0xe2, 0xfa, 0x00, 0x9e, 0x3b, 0x2d, 0xdf, 0x08, 0x7d, 0x03, 0x46, 0xa1, 0x86, 0xde, 0xf9,
	0x75, 0xcf, 0xd6, 0x83, 0xfd, 0x26, 0x5c, 0xdc, 0x33, 0x24, 0xcf, 0xc9, 0x71, 0xf7, 0x12, 0x36,
	0x1f, 0xfc, 0xca, 0xd0, 0x7f, 0xf8, 0xe5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x07, 0x23, 0x30,
	0x6a, 0xf5, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// E2TServiceClient is the client API for E2TService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type E2TServiceClient interface {
	// Stream opens an indications stream
	Stream(ctx context.Context, opts ...grpc.CallOption) (E2TService_StreamClient, error)
}

type e2TServiceClient struct {
	cc *grpc.ClientConn
}

func NewE2TServiceClient(cc *grpc.ClientConn) E2TServiceClient {
	return &e2TServiceClient{cc}
}

func (c *e2TServiceClient) Stream(ctx context.Context, opts ...grpc.CallOption) (E2TService_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_E2TService_serviceDesc.Streams[0], "/e2t.e2.E2TService/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &e2TServiceStreamClient{stream}
	return x, nil
}

type E2TService_StreamClient interface {
	Send(*StreamRequest) error
	Recv() (*StreamResponse, error)
	grpc.ClientStream
}

type e2TServiceStreamClient struct {
	grpc.ClientStream
}

func (x *e2TServiceStreamClient) Send(m *StreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *e2TServiceStreamClient) Recv() (*StreamResponse, error) {
	m := new(StreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// E2TServiceServer is the server API for E2TService service.
type E2TServiceServer interface {
	// Stream opens an indications stream
	Stream(E2TService_StreamServer) error
}

// UnimplementedE2TServiceServer can be embedded to have forward compatible implementations.
type UnimplementedE2TServiceServer struct {
}

func (*UnimplementedE2TServiceServer) Stream(srv E2TService_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}

func RegisterE2TServiceServer(s *grpc.Server, srv E2TServiceServer) {
	s.RegisterService(&_E2TService_serviceDesc, srv)
}

func _E2TService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(E2TServiceServer).Stream(&e2TServiceStreamServer{stream})
}

type E2TService_StreamServer interface {
	Send(*StreamResponse) error
	Recv() (*StreamRequest, error)
	grpc.ServerStream
}

type e2TServiceStreamServer struct {
	grpc.ServerStream
}

func (x *e2TServiceStreamServer) Send(m *StreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *e2TServiceStreamServer) Recv() (*StreamRequest, error) {
	m := new(StreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _E2TService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "e2t.e2.E2TService",
	HandlerType: (*E2TServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _E2TService_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/e2t/e2.proto",
}
